// ------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
// ------------------------------------------------------------------------------

using System;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using HexaGen.Runtime;
using System.Numerics;

namespace Hexa.NET.Box2D
{
	public unsafe partial class Box2D
	{
		/// <summary>
		/// This allows the user to override the allocation functions. These should be<br/>
		/// set during application startup.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2SetAllocator")]
		[return: NativeName(NativeNameType.Type, "void")]
		internal static void SetAllocatorNative([NativeName(NativeNameType.Param, "allocFcn")] [NativeName(NativeNameType.Type, "b2AllocFcn*")] delegate*<uint, int, void*>* allocFcn, [NativeName(NativeNameType.Param, "freeFcn")] [NativeName(NativeNameType.Type, "b2FreeFcn*")] delegate*<void*, void>* freeFcn)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<delegate*<uint, int, void*>*, delegate*<void*, void>*, void>)vt[0])(allocFcn, freeFcn);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, void>)vt[0])((nint)allocFcn, (nint)freeFcn);
			#endif
		}

		/// <summary>
		/// This allows the user to override the allocation functions. These should be<br/>
		/// set during application startup.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2SetAllocator")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SetAllocator([NativeName(NativeNameType.Param, "allocFcn")] [NativeName(NativeNameType.Type, "b2AllocFcn*")] delegate*<uint, int, void*>* allocFcn, [NativeName(NativeNameType.Param, "freeFcn")] [NativeName(NativeNameType.Type, "b2FreeFcn*")] delegate*<void*, void>* freeFcn)
		{
			SetAllocatorNative(allocFcn, freeFcn);
		}

		/// <summary>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2GetByteCount")]
		[return: NativeName(NativeNameType.Type, "int")]
		internal static int GetByteCountNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<int>)vt[1])();
			#else
			return (int)((delegate* unmanaged[Cdecl]<int>)vt[1])();
			#endif
		}

		/// <summary>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2GetByteCount")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int GetByteCount()
		{
			int ret = GetByteCountNative();
			return ret;
		}

		/// <summary>
		/// Override the default assert callback<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2SetAssertFcn")]
		[return: NativeName(NativeNameType.Type, "void")]
		internal static void SetAssertFcnNative([NativeName(NativeNameType.Param, "assertFcn")] [NativeName(NativeNameType.Type, "b2AssertFcn*")] delegate*<byte*, byte*, int, int>* assertFcn)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<delegate*<byte*, byte*, int, int>*, void>)vt[2])(assertFcn);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)vt[2])((nint)assertFcn);
			#endif
		}

		/// <summary>
		/// Override the default assert callback<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2SetAssertFcn")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SetAssertFcn([NativeName(NativeNameType.Param, "assertFcn")] [NativeName(NativeNameType.Type, "b2AssertFcn*")] delegate*<byte*, byte*, int, int>* assertFcn)
		{
			SetAssertFcnNative(assertFcn);
		}

		/// <summary>
		/// Get the current version of Box2D<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2GetVersion")]
		[return: NativeName(NativeNameType.Type, "b2Version")]
		internal static B2Version GetVersionNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<B2Version>)vt[3])();
			#else
			return (B2Version)((delegate* unmanaged[Cdecl]<B2Version>)vt[3])();
			#endif
		}

		/// <summary>
		/// Get the current version of Box2D<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2GetVersion")]
		[return: NativeName(NativeNameType.Type, "b2Version")]
		public static B2Version GetVersion()
		{
			B2Version ret = GetVersionNative();
			return ret;
		}

		[NativeName(NativeNameType.Func, "b2CreateTimer")]
		[return: NativeName(NativeNameType.Type, "b2Timer")]
		internal static B2Timer CreateTimerNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<B2Timer>)vt[4])();
			#else
			return (B2Timer)((delegate* unmanaged[Cdecl]<B2Timer>)vt[4])();
			#endif
		}

		[NativeName(NativeNameType.Func, "b2CreateTimer")]
		[return: NativeName(NativeNameType.Type, "b2Timer")]
		public static B2Timer CreateTimer()
		{
			B2Timer ret = CreateTimerNative();
			return ret;
		}

		[NativeName(NativeNameType.Func, "b2GetTicks")]
		[return: NativeName(NativeNameType.Type, "int64_t")]
		internal static long GetTicksNative([NativeName(NativeNameType.Param, "timer")] [NativeName(NativeNameType.Type, "b2Timer*")] B2Timer* timer)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<B2Timer*, long>)vt[5])(timer);
			#else
			return (long)((delegate* unmanaged[Cdecl]<nint, long>)vt[5])((nint)timer);
			#endif
		}

		[NativeName(NativeNameType.Func, "b2GetTicks")]
		[return: NativeName(NativeNameType.Type, "int64_t")]
		public static long GetTicks([NativeName(NativeNameType.Param, "timer")] [NativeName(NativeNameType.Type, "b2Timer*")] B2Timer* timer)
		{
			long ret = GetTicksNative(timer);
			return ret;
		}

		[NativeName(NativeNameType.Func, "b2GetTicks")]
		[return: NativeName(NativeNameType.Type, "int64_t")]
		public static long GetTicks([NativeName(NativeNameType.Param, "timer")] [NativeName(NativeNameType.Type, "b2Timer*")] ref B2Timer timer)
		{
			fixed (B2Timer* ptimer = &timer)
			{
				long ret = GetTicksNative((B2Timer*)ptimer);
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "b2GetMilliseconds")]
		[return: NativeName(NativeNameType.Type, "float")]
		internal static float GetMillisecondsNative([NativeName(NativeNameType.Param, "timer")] [NativeName(NativeNameType.Type, "const b2Timer*")] B2Timer* timer)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<B2Timer*, float>)vt[6])(timer);
			#else
			return (float)((delegate* unmanaged[Cdecl]<nint, float>)vt[6])((nint)timer);
			#endif
		}

		[NativeName(NativeNameType.Func, "b2GetMilliseconds")]
		[return: NativeName(NativeNameType.Type, "float")]
		public static float GetMilliseconds([NativeName(NativeNameType.Param, "timer")] [NativeName(NativeNameType.Type, "const b2Timer*")] B2Timer* timer)
		{
			float ret = GetMillisecondsNative(timer);
			return ret;
		}

		[NativeName(NativeNameType.Func, "b2GetMilliseconds")]
		[return: NativeName(NativeNameType.Type, "float")]
		public static float GetMilliseconds([NativeName(NativeNameType.Param, "timer")] [NativeName(NativeNameType.Type, "const b2Timer*")] ref B2Timer timer)
		{
			fixed (B2Timer* ptimer = &timer)
			{
				float ret = GetMillisecondsNative((B2Timer*)ptimer);
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "b2GetMillisecondsAndReset")]
		[return: NativeName(NativeNameType.Type, "float")]
		internal static float GetMillisecondsAndResetNative([NativeName(NativeNameType.Param, "timer")] [NativeName(NativeNameType.Type, "b2Timer*")] B2Timer* timer)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<B2Timer*, float>)vt[7])(timer);
			#else
			return (float)((delegate* unmanaged[Cdecl]<nint, float>)vt[7])((nint)timer);
			#endif
		}

		[NativeName(NativeNameType.Func, "b2GetMillisecondsAndReset")]
		[return: NativeName(NativeNameType.Type, "float")]
		public static float GetMillisecondsAndReset([NativeName(NativeNameType.Param, "timer")] [NativeName(NativeNameType.Type, "b2Timer*")] B2Timer* timer)
		{
			float ret = GetMillisecondsAndResetNative(timer);
			return ret;
		}

		[NativeName(NativeNameType.Func, "b2GetMillisecondsAndReset")]
		[return: NativeName(NativeNameType.Type, "float")]
		public static float GetMillisecondsAndReset([NativeName(NativeNameType.Param, "timer")] [NativeName(NativeNameType.Type, "b2Timer*")] ref B2Timer timer)
		{
			fixed (B2Timer* ptimer = &timer)
			{
				float ret = GetMillisecondsAndResetNative((B2Timer*)ptimer);
				return ret;
			}
		}

		[NativeName(NativeNameType.Func, "b2SleepMilliseconds")]
		[return: NativeName(NativeNameType.Type, "void")]
		internal static void SleepMillisecondsNative([NativeName(NativeNameType.Param, "milliseconds")] [NativeName(NativeNameType.Type, "int")] int milliseconds)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<int, void>)vt[8])(milliseconds);
			#else
			((delegate* unmanaged[Cdecl]<int, void>)vt[8])(milliseconds);
			#endif
		}

		[NativeName(NativeNameType.Func, "b2SleepMilliseconds")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SleepMilliseconds([NativeName(NativeNameType.Param, "milliseconds")] [NativeName(NativeNameType.Type, "int")] int milliseconds)
		{
			SleepMillisecondsNative(milliseconds);
		}

		[NativeName(NativeNameType.Func, "b2Yield")]
		[return: NativeName(NativeNameType.Type, "void")]
		internal static void YieldNative()
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<void>)vt[9])();
			#else
			((delegate* unmanaged[Cdecl]<void>)vt[9])();
			#endif
		}

		[NativeName(NativeNameType.Func, "b2Yield")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void Yield()
		{
			YieldNative();
		}

		/// <summary>
		/// Is this a valid number? Not NaN or infinity.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2IsValid")]
		[return: NativeName(NativeNameType.Type, "bool")]
		internal static byte IsValidNative([NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "float")] float a)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<float, byte>)vt[10])(a);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<float, byte>)vt[10])(a);
			#endif
		}

		/// <summary>
		/// Is this a valid number? Not NaN or infinity.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2IsValid")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool IsValid([NativeName(NativeNameType.Param, "a")] [NativeName(NativeNameType.Type, "float")] float a)
		{
			byte ret = IsValidNative(a);
			return ret != 0;
		}

		/// <summary>
		/// Is this a valid vector? Not NaN or infinity.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2Vec2_IsValid")]
		[return: NativeName(NativeNameType.Type, "bool")]
		internal static byte Vec2IsValidNative([NativeName(NativeNameType.Param, "v")] [NativeName(NativeNameType.Type, "b2Vec2")] Vector2 v)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<Vector2, byte>)vt[11])(v);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<Vector2, byte>)vt[11])(v);
			#endif
		}

		/// <summary>
		/// Is this a valid vector? Not NaN or infinity.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2Vec2_IsValid")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool Vec2IsValid([NativeName(NativeNameType.Param, "v")] [NativeName(NativeNameType.Type, "b2Vec2")] Vector2 v)
		{
			byte ret = Vec2IsValidNative(v);
			return ret != 0;
		}

		/// <summary>
		/// Is this a valid rotation? Not NaN or infinity. Is normalized.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2Rot_IsValid")]
		[return: NativeName(NativeNameType.Type, "bool")]
		internal static byte RotIsValidNative([NativeName(NativeNameType.Param, "q")] [NativeName(NativeNameType.Type, "b2Rot")] B2Rot q)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<B2Rot, byte>)vt[12])(q);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<B2Rot, byte>)vt[12])(q);
			#endif
		}

		/// <summary>
		/// Is this a valid rotation? Not NaN or infinity. Is normalized.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2Rot_IsValid")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool RotIsValid([NativeName(NativeNameType.Param, "q")] [NativeName(NativeNameType.Type, "b2Rot")] B2Rot q)
		{
			byte ret = RotIsValidNative(q);
			return ret != 0;
		}

		/// <summary>
		/// Is this a valid bounding box? Not Nan or infinity. Upper bound greater than or equal to lower bound.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2AABB_IsValid")]
		[return: NativeName(NativeNameType.Type, "bool")]
		internal static byte AABBIsValidNative([NativeName(NativeNameType.Param, "aabb")] [NativeName(NativeNameType.Type, "b2AABB")] B2AABB aabb)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<B2AABB, byte>)vt[13])(aabb);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<B2AABB, byte>)vt[13])(aabb);
			#endif
		}

		/// <summary>
		/// Is this a valid bounding box? Not Nan or infinity. Upper bound greater than or equal to lower bound.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2AABB_IsValid")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool AABBIsValid([NativeName(NativeNameType.Param, "aabb")] [NativeName(NativeNameType.Type, "b2AABB")] B2AABB aabb)
		{
			byte ret = AABBIsValidNative(aabb);
			return ret != 0;
		}

		/// <summary>
		/// Convert a vector into a unit vector if possible, otherwise returns the zero vector.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2Normalize")]
		[return: NativeName(NativeNameType.Type, "b2Vec2")]
		internal static Vector2 NormalizeNative([NativeName(NativeNameType.Param, "v")] [NativeName(NativeNameType.Type, "b2Vec2")] Vector2 v)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<Vector2, Vector2>)vt[14])(v);
			#else
			return (Vector2)((delegate* unmanaged[Cdecl]<Vector2, Vector2>)vt[14])(v);
			#endif
		}

		/// <summary>
		/// Convert a vector into a unit vector if possible, otherwise returns the zero vector.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2Normalize")]
		[return: NativeName(NativeNameType.Type, "b2Vec2")]
		public static Vector2 Normalize([NativeName(NativeNameType.Param, "v")] [NativeName(NativeNameType.Type, "b2Vec2")] Vector2 v)
		{
			Vector2 ret = NormalizeNative(v);
			return ret;
		}

		/// <summary>
		/// Convert a vector into a unit vector if possible, otherwise asserts.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2NormalizeChecked")]
		[return: NativeName(NativeNameType.Type, "b2Vec2")]
		internal static Vector2 NormalizeCheckedNative([NativeName(NativeNameType.Param, "v")] [NativeName(NativeNameType.Type, "b2Vec2")] Vector2 v)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<Vector2, Vector2>)vt[15])(v);
			#else
			return (Vector2)((delegate* unmanaged[Cdecl]<Vector2, Vector2>)vt[15])(v);
			#endif
		}

		/// <summary>
		/// Convert a vector into a unit vector if possible, otherwise asserts.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2NormalizeChecked")]
		[return: NativeName(NativeNameType.Type, "b2Vec2")]
		public static Vector2 NormalizeChecked([NativeName(NativeNameType.Param, "v")] [NativeName(NativeNameType.Type, "b2Vec2")] Vector2 v)
		{
			Vector2 ret = NormalizeCheckedNative(v);
			return ret;
		}

		/// <summary>
		/// Convert a vector into a unit vector if possible, otherwise returns the zero vector. Also<br/>
		/// outputs the length.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2GetLengthAndNormalize")]
		[return: NativeName(NativeNameType.Type, "b2Vec2")]
		internal static Vector2 GetLengthAndNormalizeNative([NativeName(NativeNameType.Param, "length")] [NativeName(NativeNameType.Type, "float*")] float* length, [NativeName(NativeNameType.Param, "v")] [NativeName(NativeNameType.Type, "b2Vec2")] Vector2 v)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<float*, Vector2, Vector2>)vt[16])(length, v);
			#else
			return (Vector2)((delegate* unmanaged[Cdecl]<nint, Vector2, Vector2>)vt[16])((nint)length, v);
			#endif
		}

		/// <summary>
		/// Convert a vector into a unit vector if possible, otherwise returns the zero vector. Also<br/>
		/// outputs the length.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2GetLengthAndNormalize")]
		[return: NativeName(NativeNameType.Type, "b2Vec2")]
		public static Vector2 GetLengthAndNormalize([NativeName(NativeNameType.Param, "length")] [NativeName(NativeNameType.Type, "float*")] float* length, [NativeName(NativeNameType.Param, "v")] [NativeName(NativeNameType.Type, "b2Vec2")] Vector2 v)
		{
			Vector2 ret = GetLengthAndNormalizeNative(length, v);
			return ret;
		}

		/// <summary>
		/// Convert a vector into a unit vector if possible, otherwise returns the zero vector. Also<br/>
		/// outputs the length.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2GetLengthAndNormalize")]
		[return: NativeName(NativeNameType.Type, "b2Vec2")]
		public static Vector2 GetLengthAndNormalize([NativeName(NativeNameType.Param, "length")] [NativeName(NativeNameType.Type, "float*")] ref float length, [NativeName(NativeNameType.Param, "v")] [NativeName(NativeNameType.Type, "b2Vec2")] Vector2 v)
		{
			fixed (float* plength = &length)
			{
				Vector2 ret = GetLengthAndNormalizeNative((float*)plength, v);
				return ret;
			}
		}

		/// <summary>
		/// Box2D bases all length units on meters, but you may need different units for your game.<br/>
		/// You can set this value to use different units. This should be done at application startup<br/>
		/// and only modified once. Default value is 1.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2SetLengthUnitsPerMeter")]
		[return: NativeName(NativeNameType.Type, "void")]
		internal static void SetLengthUnitsPerMeterNative([NativeName(NativeNameType.Param, "lengthUnits")] [NativeName(NativeNameType.Type, "float")] float lengthUnits)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<float, void>)vt[17])(lengthUnits);
			#else
			((delegate* unmanaged[Cdecl]<float, void>)vt[17])(lengthUnits);
			#endif
		}

		/// <summary>
		/// Box2D bases all length units on meters, but you may need different units for your game.<br/>
		/// You can set this value to use different units. This should be done at application startup<br/>
		/// and only modified once. Default value is 1.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2SetLengthUnitsPerMeter")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void SetLengthUnitsPerMeter([NativeName(NativeNameType.Param, "lengthUnits")] [NativeName(NativeNameType.Type, "float")] float lengthUnits)
		{
			SetLengthUnitsPerMeterNative(lengthUnits);
		}

		/// <summary>
		/// Get the current length units per meter.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2GetLengthUnitsPerMeter")]
		[return: NativeName(NativeNameType.Type, "float")]
		internal static float GetLengthUnitsPerMeterNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<float>)vt[18])();
			#else
			return (float)((delegate* unmanaged[Cdecl]<float>)vt[18])();
			#endif
		}

		/// <summary>
		/// Get the current length units per meter.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2GetLengthUnitsPerMeter")]
		[return: NativeName(NativeNameType.Type, "float")]
		public static float GetLengthUnitsPerMeter()
		{
			float ret = GetLengthUnitsPerMeterNative();
			return ret;
		}

		/// <summary>
		/// Validate ray cast input data (NaN, etc)<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2IsValidRay")]
		[return: NativeName(NativeNameType.Type, "bool")]
		internal static byte IsValidRayNative([NativeName(NativeNameType.Param, "input")] [NativeName(NativeNameType.Type, "const b2RayCastInput*")] B2RayCastInput* input)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<B2RayCastInput*, byte>)vt[19])(input);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, byte>)vt[19])((nint)input);
			#endif
		}

		/// <summary>
		/// Validate ray cast input data (NaN, etc)<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2IsValidRay")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool IsValidRay([NativeName(NativeNameType.Param, "input")] [NativeName(NativeNameType.Type, "const b2RayCastInput*")] B2RayCastInput* input)
		{
			byte ret = IsValidRayNative(input);
			return ret != 0;
		}

		/// <summary>
		/// Validate ray cast input data (NaN, etc)<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2IsValidRay")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool IsValidRay([NativeName(NativeNameType.Param, "input")] [NativeName(NativeNameType.Type, "const b2RayCastInput*")] ref B2RayCastInput input)
		{
			fixed (B2RayCastInput* pinput = &input)
			{
				byte ret = IsValidRayNative((B2RayCastInput*)pinput);
				return ret != 0;
			}
		}

		/// <summary>
		/// Make a convex polygon from a convex hull. This will assert if the hull is not valid.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2MakePolygon")]
		[return: NativeName(NativeNameType.Type, "b2Polygon")]
		internal static B2Polygon MakePolygonNative([NativeName(NativeNameType.Param, "hull")] [NativeName(NativeNameType.Type, "const b2Hull*")] B2Hull* hull, [NativeName(NativeNameType.Param, "radius")] [NativeName(NativeNameType.Type, "float")] float radius)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<B2Hull*, float, B2Polygon>)vt[20])(hull, radius);
			#else
			return (B2Polygon)((delegate* unmanaged[Cdecl]<nint, float, B2Polygon>)vt[20])((nint)hull, radius);
			#endif
		}

		/// <summary>
		/// Make a convex polygon from a convex hull. This will assert if the hull is not valid.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2MakePolygon")]
		[return: NativeName(NativeNameType.Type, "b2Polygon")]
		public static B2Polygon MakePolygon([NativeName(NativeNameType.Param, "hull")] [NativeName(NativeNameType.Type, "const b2Hull*")] B2Hull* hull, [NativeName(NativeNameType.Param, "radius")] [NativeName(NativeNameType.Type, "float")] float radius)
		{
			B2Polygon ret = MakePolygonNative(hull, radius);
			return ret;
		}

		/// <summary>
		/// Make a convex polygon from a convex hull. This will assert if the hull is not valid.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2MakePolygon")]
		[return: NativeName(NativeNameType.Type, "b2Polygon")]
		public static B2Polygon MakePolygon([NativeName(NativeNameType.Param, "hull")] [NativeName(NativeNameType.Type, "const b2Hull*")] ref B2Hull hull, [NativeName(NativeNameType.Param, "radius")] [NativeName(NativeNameType.Type, "float")] float radius)
		{
			fixed (B2Hull* phull = &hull)
			{
				B2Polygon ret = MakePolygonNative((B2Hull*)phull, radius);
				return ret;
			}
		}

		/// <summary>
		/// Make an offset convex polygon from a convex hull. This will assert if the hull is not valid.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2MakeOffsetPolygon")]
		[return: NativeName(NativeNameType.Type, "b2Polygon")]
		internal static B2Polygon MakeOffsetPolygonNative([NativeName(NativeNameType.Param, "hull")] [NativeName(NativeNameType.Type, "const b2Hull*")] B2Hull* hull, [NativeName(NativeNameType.Param, "radius")] [NativeName(NativeNameType.Type, "float")] float radius, [NativeName(NativeNameType.Param, "transform")] [NativeName(NativeNameType.Type, "b2Transform")] B2Transform transform)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<B2Hull*, float, B2Transform, B2Polygon>)vt[21])(hull, radius, transform);
			#else
			return (B2Polygon)((delegate* unmanaged[Cdecl]<nint, float, B2Transform, B2Polygon>)vt[21])((nint)hull, radius, transform);
			#endif
		}

		/// <summary>
		/// Make an offset convex polygon from a convex hull. This will assert if the hull is not valid.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2MakeOffsetPolygon")]
		[return: NativeName(NativeNameType.Type, "b2Polygon")]
		public static B2Polygon MakeOffsetPolygon([NativeName(NativeNameType.Param, "hull")] [NativeName(NativeNameType.Type, "const b2Hull*")] B2Hull* hull, [NativeName(NativeNameType.Param, "radius")] [NativeName(NativeNameType.Type, "float")] float radius, [NativeName(NativeNameType.Param, "transform")] [NativeName(NativeNameType.Type, "b2Transform")] B2Transform transform)
		{
			B2Polygon ret = MakeOffsetPolygonNative(hull, radius, transform);
			return ret;
		}

		/// <summary>
		/// Make an offset convex polygon from a convex hull. This will assert if the hull is not valid.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2MakeOffsetPolygon")]
		[return: NativeName(NativeNameType.Type, "b2Polygon")]
		public static B2Polygon MakeOffsetPolygon([NativeName(NativeNameType.Param, "hull")] [NativeName(NativeNameType.Type, "const b2Hull*")] ref B2Hull hull, [NativeName(NativeNameType.Param, "radius")] [NativeName(NativeNameType.Type, "float")] float radius, [NativeName(NativeNameType.Param, "transform")] [NativeName(NativeNameType.Type, "b2Transform")] B2Transform transform)
		{
			fixed (B2Hull* phull = &hull)
			{
				B2Polygon ret = MakeOffsetPolygonNative((B2Hull*)phull, radius, transform);
				return ret;
			}
		}

		/// <summary>
		/// Make a square polygon, bypassing the need for a convex hull.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2MakeSquare")]
		[return: NativeName(NativeNameType.Type, "b2Polygon")]
		internal static B2Polygon MakeSquareNative([NativeName(NativeNameType.Param, "h")] [NativeName(NativeNameType.Type, "float")] float h)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<float, B2Polygon>)vt[22])(h);
			#else
			return (B2Polygon)((delegate* unmanaged[Cdecl]<float, B2Polygon>)vt[22])(h);
			#endif
		}

		/// <summary>
		/// Make a square polygon, bypassing the need for a convex hull.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2MakeSquare")]
		[return: NativeName(NativeNameType.Type, "b2Polygon")]
		public static B2Polygon MakeSquare([NativeName(NativeNameType.Param, "h")] [NativeName(NativeNameType.Type, "float")] float h)
		{
			B2Polygon ret = MakeSquareNative(h);
			return ret;
		}

		/// <summary>
		/// Make a box (rectangle) polygon, bypassing the need for a convex hull.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2MakeBox")]
		[return: NativeName(NativeNameType.Type, "b2Polygon")]
		internal static B2Polygon MakeBoxNative([NativeName(NativeNameType.Param, "hx")] [NativeName(NativeNameType.Type, "float")] float hx, [NativeName(NativeNameType.Param, "hy")] [NativeName(NativeNameType.Type, "float")] float hy)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<float, float, B2Polygon>)vt[23])(hx, hy);
			#else
			return (B2Polygon)((delegate* unmanaged[Cdecl]<float, float, B2Polygon>)vt[23])(hx, hy);
			#endif
		}

		/// <summary>
		/// Make a box (rectangle) polygon, bypassing the need for a convex hull.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2MakeBox")]
		[return: NativeName(NativeNameType.Type, "b2Polygon")]
		public static B2Polygon MakeBox([NativeName(NativeNameType.Param, "hx")] [NativeName(NativeNameType.Type, "float")] float hx, [NativeName(NativeNameType.Param, "hy")] [NativeName(NativeNameType.Type, "float")] float hy)
		{
			B2Polygon ret = MakeBoxNative(hx, hy);
			return ret;
		}

		/// <summary>
		/// Make a rounded box, bypassing the need for a convex hull.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2MakeRoundedBox")]
		[return: NativeName(NativeNameType.Type, "b2Polygon")]
		internal static B2Polygon MakeRoundedBoxNative([NativeName(NativeNameType.Param, "hx")] [NativeName(NativeNameType.Type, "float")] float hx, [NativeName(NativeNameType.Param, "hy")] [NativeName(NativeNameType.Type, "float")] float hy, [NativeName(NativeNameType.Param, "radius")] [NativeName(NativeNameType.Type, "float")] float radius)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<float, float, float, B2Polygon>)vt[24])(hx, hy, radius);
			#else
			return (B2Polygon)((delegate* unmanaged[Cdecl]<float, float, float, B2Polygon>)vt[24])(hx, hy, radius);
			#endif
		}

		/// <summary>
		/// Make a rounded box, bypassing the need for a convex hull.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2MakeRoundedBox")]
		[return: NativeName(NativeNameType.Type, "b2Polygon")]
		public static B2Polygon MakeRoundedBox([NativeName(NativeNameType.Param, "hx")] [NativeName(NativeNameType.Type, "float")] float hx, [NativeName(NativeNameType.Param, "hy")] [NativeName(NativeNameType.Type, "float")] float hy, [NativeName(NativeNameType.Param, "radius")] [NativeName(NativeNameType.Type, "float")] float radius)
		{
			B2Polygon ret = MakeRoundedBoxNative(hx, hy, radius);
			return ret;
		}

		/// <summary>
		/// Make an offset box, bypassing the need for a convex hull.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2MakeOffsetBox")]
		[return: NativeName(NativeNameType.Type, "b2Polygon")]
		internal static B2Polygon MakeOffsetBoxNative([NativeName(NativeNameType.Param, "hx")] [NativeName(NativeNameType.Type, "float")] float hx, [NativeName(NativeNameType.Param, "hy")] [NativeName(NativeNameType.Type, "float")] float hy, [NativeName(NativeNameType.Param, "center")] [NativeName(NativeNameType.Type, "b2Vec2")] Vector2 center, [NativeName(NativeNameType.Param, "angle")] [NativeName(NativeNameType.Type, "float")] float angle)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<float, float, Vector2, float, B2Polygon>)vt[25])(hx, hy, center, angle);
			#else
			return (B2Polygon)((delegate* unmanaged[Cdecl]<float, float, Vector2, float, B2Polygon>)vt[25])(hx, hy, center, angle);
			#endif
		}

		/// <summary>
		/// Make an offset box, bypassing the need for a convex hull.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2MakeOffsetBox")]
		[return: NativeName(NativeNameType.Type, "b2Polygon")]
		public static B2Polygon MakeOffsetBox([NativeName(NativeNameType.Param, "hx")] [NativeName(NativeNameType.Type, "float")] float hx, [NativeName(NativeNameType.Param, "hy")] [NativeName(NativeNameType.Type, "float")] float hy, [NativeName(NativeNameType.Param, "center")] [NativeName(NativeNameType.Type, "b2Vec2")] Vector2 center, [NativeName(NativeNameType.Param, "angle")] [NativeName(NativeNameType.Type, "float")] float angle)
		{
			B2Polygon ret = MakeOffsetBoxNative(hx, hy, center, angle);
			return ret;
		}

		/// <summary>
		/// Transform a polygon. This is useful for transferring a shape from one body to another.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2TransformPolygon")]
		[return: NativeName(NativeNameType.Type, "b2Polygon")]
		internal static B2Polygon TransformPolygonNative([NativeName(NativeNameType.Param, "transform")] [NativeName(NativeNameType.Type, "b2Transform")] B2Transform transform, [NativeName(NativeNameType.Param, "polygon")] [NativeName(NativeNameType.Type, "const b2Polygon*")] B2Polygon* polygon)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<B2Transform, B2Polygon*, B2Polygon>)vt[26])(transform, polygon);
			#else
			return (B2Polygon)((delegate* unmanaged[Cdecl]<B2Transform, nint, B2Polygon>)vt[26])(transform, (nint)polygon);
			#endif
		}

		/// <summary>
		/// Transform a polygon. This is useful for transferring a shape from one body to another.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2TransformPolygon")]
		[return: NativeName(NativeNameType.Type, "b2Polygon")]
		public static B2Polygon TransformPolygon([NativeName(NativeNameType.Param, "transform")] [NativeName(NativeNameType.Type, "b2Transform")] B2Transform transform, [NativeName(NativeNameType.Param, "polygon")] [NativeName(NativeNameType.Type, "const b2Polygon*")] B2Polygon* polygon)
		{
			B2Polygon ret = TransformPolygonNative(transform, polygon);
			return ret;
		}

		/// <summary>
		/// Transform a polygon. This is useful for transferring a shape from one body to another.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2TransformPolygon")]
		[return: NativeName(NativeNameType.Type, "b2Polygon")]
		public static B2Polygon TransformPolygon([NativeName(NativeNameType.Param, "transform")] [NativeName(NativeNameType.Type, "b2Transform")] B2Transform transform, [NativeName(NativeNameType.Param, "polygon")] [NativeName(NativeNameType.Type, "const b2Polygon*")] ref B2Polygon polygon)
		{
			fixed (B2Polygon* ppolygon = &polygon)
			{
				B2Polygon ret = TransformPolygonNative(transform, (B2Polygon*)ppolygon);
				return ret;
			}
		}

		/// <summary>
		/// Compute mass properties of a circle<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2ComputeCircleMass")]
		[return: NativeName(NativeNameType.Type, "b2MassData")]
		internal static B2MassData ComputeCircleMassNative([NativeName(NativeNameType.Param, "shape")] [NativeName(NativeNameType.Type, "const b2Circle*")] B2Circle* shape, [NativeName(NativeNameType.Param, "density")] [NativeName(NativeNameType.Type, "float")] float density)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<B2Circle*, float, B2MassData>)vt[27])(shape, density);
			#else
			return (B2MassData)((delegate* unmanaged[Cdecl]<nint, float, B2MassData>)vt[27])((nint)shape, density);
			#endif
		}

		/// <summary>
		/// Compute mass properties of a circle<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2ComputeCircleMass")]
		[return: NativeName(NativeNameType.Type, "b2MassData")]
		public static B2MassData ComputeCircleMass([NativeName(NativeNameType.Param, "shape")] [NativeName(NativeNameType.Type, "const b2Circle*")] B2Circle* shape, [NativeName(NativeNameType.Param, "density")] [NativeName(NativeNameType.Type, "float")] float density)
		{
			B2MassData ret = ComputeCircleMassNative(shape, density);
			return ret;
		}

		/// <summary>
		/// Compute mass properties of a circle<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2ComputeCircleMass")]
		[return: NativeName(NativeNameType.Type, "b2MassData")]
		public static B2MassData ComputeCircleMass([NativeName(NativeNameType.Param, "shape")] [NativeName(NativeNameType.Type, "const b2Circle*")] ref B2Circle shape, [NativeName(NativeNameType.Param, "density")] [NativeName(NativeNameType.Type, "float")] float density)
		{
			fixed (B2Circle* pshape = &shape)
			{
				B2MassData ret = ComputeCircleMassNative((B2Circle*)pshape, density);
				return ret;
			}
		}

		/// <summary>
		/// Compute mass properties of a capsule<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2ComputeCapsuleMass")]
		[return: NativeName(NativeNameType.Type, "b2MassData")]
		internal static B2MassData ComputeCapsuleMassNative([NativeName(NativeNameType.Param, "shape")] [NativeName(NativeNameType.Type, "const b2Capsule*")] B2Capsule* shape, [NativeName(NativeNameType.Param, "density")] [NativeName(NativeNameType.Type, "float")] float density)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<B2Capsule*, float, B2MassData>)vt[28])(shape, density);
			#else
			return (B2MassData)((delegate* unmanaged[Cdecl]<nint, float, B2MassData>)vt[28])((nint)shape, density);
			#endif
		}

		/// <summary>
		/// Compute mass properties of a capsule<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2ComputeCapsuleMass")]
		[return: NativeName(NativeNameType.Type, "b2MassData")]
		public static B2MassData ComputeCapsuleMass([NativeName(NativeNameType.Param, "shape")] [NativeName(NativeNameType.Type, "const b2Capsule*")] B2Capsule* shape, [NativeName(NativeNameType.Param, "density")] [NativeName(NativeNameType.Type, "float")] float density)
		{
			B2MassData ret = ComputeCapsuleMassNative(shape, density);
			return ret;
		}

		/// <summary>
		/// Compute mass properties of a capsule<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2ComputeCapsuleMass")]
		[return: NativeName(NativeNameType.Type, "b2MassData")]
		public static B2MassData ComputeCapsuleMass([NativeName(NativeNameType.Param, "shape")] [NativeName(NativeNameType.Type, "const b2Capsule*")] ref B2Capsule shape, [NativeName(NativeNameType.Param, "density")] [NativeName(NativeNameType.Type, "float")] float density)
		{
			fixed (B2Capsule* pshape = &shape)
			{
				B2MassData ret = ComputeCapsuleMassNative((B2Capsule*)pshape, density);
				return ret;
			}
		}

		/// <summary>
		/// Compute mass properties of a polygon<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2ComputePolygonMass")]
		[return: NativeName(NativeNameType.Type, "b2MassData")]
		internal static B2MassData ComputePolygonMassNative([NativeName(NativeNameType.Param, "shape")] [NativeName(NativeNameType.Type, "const b2Polygon*")] B2Polygon* shape, [NativeName(NativeNameType.Param, "density")] [NativeName(NativeNameType.Type, "float")] float density)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<B2Polygon*, float, B2MassData>)vt[29])(shape, density);
			#else
			return (B2MassData)((delegate* unmanaged[Cdecl]<nint, float, B2MassData>)vt[29])((nint)shape, density);
			#endif
		}

		/// <summary>
		/// Compute mass properties of a polygon<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2ComputePolygonMass")]
		[return: NativeName(NativeNameType.Type, "b2MassData")]
		public static B2MassData ComputePolygonMass([NativeName(NativeNameType.Param, "shape")] [NativeName(NativeNameType.Type, "const b2Polygon*")] B2Polygon* shape, [NativeName(NativeNameType.Param, "density")] [NativeName(NativeNameType.Type, "float")] float density)
		{
			B2MassData ret = ComputePolygonMassNative(shape, density);
			return ret;
		}

		/// <summary>
		/// Compute mass properties of a polygon<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2ComputePolygonMass")]
		[return: NativeName(NativeNameType.Type, "b2MassData")]
		public static B2MassData ComputePolygonMass([NativeName(NativeNameType.Param, "shape")] [NativeName(NativeNameType.Type, "const b2Polygon*")] ref B2Polygon shape, [NativeName(NativeNameType.Param, "density")] [NativeName(NativeNameType.Type, "float")] float density)
		{
			fixed (B2Polygon* pshape = &shape)
			{
				B2MassData ret = ComputePolygonMassNative((B2Polygon*)pshape, density);
				return ret;
			}
		}

		/// <summary>
		/// Compute the bounding box of a transformed circle<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2ComputeCircleAABB")]
		[return: NativeName(NativeNameType.Type, "b2AABB")]
		internal static B2AABB ComputeCircleAABBNative([NativeName(NativeNameType.Param, "shape")] [NativeName(NativeNameType.Type, "const b2Circle*")] B2Circle* shape, [NativeName(NativeNameType.Param, "transform")] [NativeName(NativeNameType.Type, "b2Transform")] B2Transform transform)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<B2Circle*, B2Transform, B2AABB>)vt[30])(shape, transform);
			#else
			return (B2AABB)((delegate* unmanaged[Cdecl]<nint, B2Transform, B2AABB>)vt[30])((nint)shape, transform);
			#endif
		}

		/// <summary>
		/// Compute the bounding box of a transformed circle<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2ComputeCircleAABB")]
		[return: NativeName(NativeNameType.Type, "b2AABB")]
		public static B2AABB ComputeCircleAABB([NativeName(NativeNameType.Param, "shape")] [NativeName(NativeNameType.Type, "const b2Circle*")] B2Circle* shape, [NativeName(NativeNameType.Param, "transform")] [NativeName(NativeNameType.Type, "b2Transform")] B2Transform transform)
		{
			B2AABB ret = ComputeCircleAABBNative(shape, transform);
			return ret;
		}

		/// <summary>
		/// Compute the bounding box of a transformed circle<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2ComputeCircleAABB")]
		[return: NativeName(NativeNameType.Type, "b2AABB")]
		public static B2AABB ComputeCircleAABB([NativeName(NativeNameType.Param, "shape")] [NativeName(NativeNameType.Type, "const b2Circle*")] ref B2Circle shape, [NativeName(NativeNameType.Param, "transform")] [NativeName(NativeNameType.Type, "b2Transform")] B2Transform transform)
		{
			fixed (B2Circle* pshape = &shape)
			{
				B2AABB ret = ComputeCircleAABBNative((B2Circle*)pshape, transform);
				return ret;
			}
		}

		/// <summary>
		/// Compute the bounding box of a transformed capsule<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2ComputeCapsuleAABB")]
		[return: NativeName(NativeNameType.Type, "b2AABB")]
		internal static B2AABB ComputeCapsuleAABBNative([NativeName(NativeNameType.Param, "shape")] [NativeName(NativeNameType.Type, "const b2Capsule*")] B2Capsule* shape, [NativeName(NativeNameType.Param, "transform")] [NativeName(NativeNameType.Type, "b2Transform")] B2Transform transform)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<B2Capsule*, B2Transform, B2AABB>)vt[31])(shape, transform);
			#else
			return (B2AABB)((delegate* unmanaged[Cdecl]<nint, B2Transform, B2AABB>)vt[31])((nint)shape, transform);
			#endif
		}

		/// <summary>
		/// Compute the bounding box of a transformed capsule<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2ComputeCapsuleAABB")]
		[return: NativeName(NativeNameType.Type, "b2AABB")]
		public static B2AABB ComputeCapsuleAABB([NativeName(NativeNameType.Param, "shape")] [NativeName(NativeNameType.Type, "const b2Capsule*")] B2Capsule* shape, [NativeName(NativeNameType.Param, "transform")] [NativeName(NativeNameType.Type, "b2Transform")] B2Transform transform)
		{
			B2AABB ret = ComputeCapsuleAABBNative(shape, transform);
			return ret;
		}

		/// <summary>
		/// Compute the bounding box of a transformed capsule<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2ComputeCapsuleAABB")]
		[return: NativeName(NativeNameType.Type, "b2AABB")]
		public static B2AABB ComputeCapsuleAABB([NativeName(NativeNameType.Param, "shape")] [NativeName(NativeNameType.Type, "const b2Capsule*")] ref B2Capsule shape, [NativeName(NativeNameType.Param, "transform")] [NativeName(NativeNameType.Type, "b2Transform")] B2Transform transform)
		{
			fixed (B2Capsule* pshape = &shape)
			{
				B2AABB ret = ComputeCapsuleAABBNative((B2Capsule*)pshape, transform);
				return ret;
			}
		}

		/// <summary>
		/// Compute the bounding box of a transformed polygon<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2ComputePolygonAABB")]
		[return: NativeName(NativeNameType.Type, "b2AABB")]
		internal static B2AABB ComputePolygonAABBNative([NativeName(NativeNameType.Param, "shape")] [NativeName(NativeNameType.Type, "const b2Polygon*")] B2Polygon* shape, [NativeName(NativeNameType.Param, "transform")] [NativeName(NativeNameType.Type, "b2Transform")] B2Transform transform)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<B2Polygon*, B2Transform, B2AABB>)vt[32])(shape, transform);
			#else
			return (B2AABB)((delegate* unmanaged[Cdecl]<nint, B2Transform, B2AABB>)vt[32])((nint)shape, transform);
			#endif
		}

		/// <summary>
		/// Compute the bounding box of a transformed polygon<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2ComputePolygonAABB")]
		[return: NativeName(NativeNameType.Type, "b2AABB")]
		public static B2AABB ComputePolygonAABB([NativeName(NativeNameType.Param, "shape")] [NativeName(NativeNameType.Type, "const b2Polygon*")] B2Polygon* shape, [NativeName(NativeNameType.Param, "transform")] [NativeName(NativeNameType.Type, "b2Transform")] B2Transform transform)
		{
			B2AABB ret = ComputePolygonAABBNative(shape, transform);
			return ret;
		}

		/// <summary>
		/// Compute the bounding box of a transformed polygon<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2ComputePolygonAABB")]
		[return: NativeName(NativeNameType.Type, "b2AABB")]
		public static B2AABB ComputePolygonAABB([NativeName(NativeNameType.Param, "shape")] [NativeName(NativeNameType.Type, "const b2Polygon*")] ref B2Polygon shape, [NativeName(NativeNameType.Param, "transform")] [NativeName(NativeNameType.Type, "b2Transform")] B2Transform transform)
		{
			fixed (B2Polygon* pshape = &shape)
			{
				B2AABB ret = ComputePolygonAABBNative((B2Polygon*)pshape, transform);
				return ret;
			}
		}

		/// <summary>
		/// Compute the bounding box of a transformed line segment<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2ComputeSegmentAABB")]
		[return: NativeName(NativeNameType.Type, "b2AABB")]
		internal static B2AABB ComputeSegmentAABBNative([NativeName(NativeNameType.Param, "shape")] [NativeName(NativeNameType.Type, "const b2Segment*")] B2Segment* shape, [NativeName(NativeNameType.Param, "transform")] [NativeName(NativeNameType.Type, "b2Transform")] B2Transform transform)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<B2Segment*, B2Transform, B2AABB>)vt[33])(shape, transform);
			#else
			return (B2AABB)((delegate* unmanaged[Cdecl]<nint, B2Transform, B2AABB>)vt[33])((nint)shape, transform);
			#endif
		}

		/// <summary>
		/// Compute the bounding box of a transformed line segment<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2ComputeSegmentAABB")]
		[return: NativeName(NativeNameType.Type, "b2AABB")]
		public static B2AABB ComputeSegmentAABB([NativeName(NativeNameType.Param, "shape")] [NativeName(NativeNameType.Type, "const b2Segment*")] B2Segment* shape, [NativeName(NativeNameType.Param, "transform")] [NativeName(NativeNameType.Type, "b2Transform")] B2Transform transform)
		{
			B2AABB ret = ComputeSegmentAABBNative(shape, transform);
			return ret;
		}

		/// <summary>
		/// Compute the bounding box of a transformed line segment<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2ComputeSegmentAABB")]
		[return: NativeName(NativeNameType.Type, "b2AABB")]
		public static B2AABB ComputeSegmentAABB([NativeName(NativeNameType.Param, "shape")] [NativeName(NativeNameType.Type, "const b2Segment*")] ref B2Segment shape, [NativeName(NativeNameType.Param, "transform")] [NativeName(NativeNameType.Type, "b2Transform")] B2Transform transform)
		{
			fixed (B2Segment* pshape = &shape)
			{
				B2AABB ret = ComputeSegmentAABBNative((B2Segment*)pshape, transform);
				return ret;
			}
		}

		/// <summary>
		/// Test a point for overlap with a circle in local space<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2PointInCircle")]
		[return: NativeName(NativeNameType.Type, "bool")]
		internal static byte PointInCircleNative([NativeName(NativeNameType.Param, "point")] [NativeName(NativeNameType.Type, "b2Vec2")] Vector2 point, [NativeName(NativeNameType.Param, "shape")] [NativeName(NativeNameType.Type, "const b2Circle*")] B2Circle* shape)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<Vector2, B2Circle*, byte>)vt[34])(point, shape);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<Vector2, nint, byte>)vt[34])(point, (nint)shape);
			#endif
		}

		/// <summary>
		/// Test a point for overlap with a circle in local space<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2PointInCircle")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool PointInCircle([NativeName(NativeNameType.Param, "point")] [NativeName(NativeNameType.Type, "b2Vec2")] Vector2 point, [NativeName(NativeNameType.Param, "shape")] [NativeName(NativeNameType.Type, "const b2Circle*")] B2Circle* shape)
		{
			byte ret = PointInCircleNative(point, shape);
			return ret != 0;
		}

		/// <summary>
		/// Test a point for overlap with a circle in local space<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2PointInCircle")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool PointInCircle([NativeName(NativeNameType.Param, "point")] [NativeName(NativeNameType.Type, "b2Vec2")] Vector2 point, [NativeName(NativeNameType.Param, "shape")] [NativeName(NativeNameType.Type, "const b2Circle*")] ref B2Circle shape)
		{
			fixed (B2Circle* pshape = &shape)
			{
				byte ret = PointInCircleNative(point, (B2Circle*)pshape);
				return ret != 0;
			}
		}

		/// <summary>
		/// Test a point for overlap with a capsule in local space<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2PointInCapsule")]
		[return: NativeName(NativeNameType.Type, "bool")]
		internal static byte PointInCapsuleNative([NativeName(NativeNameType.Param, "point")] [NativeName(NativeNameType.Type, "b2Vec2")] Vector2 point, [NativeName(NativeNameType.Param, "shape")] [NativeName(NativeNameType.Type, "const b2Capsule*")] B2Capsule* shape)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<Vector2, B2Capsule*, byte>)vt[35])(point, shape);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<Vector2, nint, byte>)vt[35])(point, (nint)shape);
			#endif
		}

		/// <summary>
		/// Test a point for overlap with a capsule in local space<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2PointInCapsule")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool PointInCapsule([NativeName(NativeNameType.Param, "point")] [NativeName(NativeNameType.Type, "b2Vec2")] Vector2 point, [NativeName(NativeNameType.Param, "shape")] [NativeName(NativeNameType.Type, "const b2Capsule*")] B2Capsule* shape)
		{
			byte ret = PointInCapsuleNative(point, shape);
			return ret != 0;
		}

		/// <summary>
		/// Test a point for overlap with a capsule in local space<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2PointInCapsule")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool PointInCapsule([NativeName(NativeNameType.Param, "point")] [NativeName(NativeNameType.Type, "b2Vec2")] Vector2 point, [NativeName(NativeNameType.Param, "shape")] [NativeName(NativeNameType.Type, "const b2Capsule*")] ref B2Capsule shape)
		{
			fixed (B2Capsule* pshape = &shape)
			{
				byte ret = PointInCapsuleNative(point, (B2Capsule*)pshape);
				return ret != 0;
			}
		}

		/// <summary>
		/// Test a point for overlap with a convex polygon in local space<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2PointInPolygon")]
		[return: NativeName(NativeNameType.Type, "bool")]
		internal static byte PointInPolygonNative([NativeName(NativeNameType.Param, "point")] [NativeName(NativeNameType.Type, "b2Vec2")] Vector2 point, [NativeName(NativeNameType.Param, "shape")] [NativeName(NativeNameType.Type, "const b2Polygon*")] B2Polygon* shape)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<Vector2, B2Polygon*, byte>)vt[36])(point, shape);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<Vector2, nint, byte>)vt[36])(point, (nint)shape);
			#endif
		}

		/// <summary>
		/// Test a point for overlap with a convex polygon in local space<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2PointInPolygon")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool PointInPolygon([NativeName(NativeNameType.Param, "point")] [NativeName(NativeNameType.Type, "b2Vec2")] Vector2 point, [NativeName(NativeNameType.Param, "shape")] [NativeName(NativeNameType.Type, "const b2Polygon*")] B2Polygon* shape)
		{
			byte ret = PointInPolygonNative(point, shape);
			return ret != 0;
		}

		/// <summary>
		/// Test a point for overlap with a convex polygon in local space<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2PointInPolygon")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool PointInPolygon([NativeName(NativeNameType.Param, "point")] [NativeName(NativeNameType.Type, "b2Vec2")] Vector2 point, [NativeName(NativeNameType.Param, "shape")] [NativeName(NativeNameType.Type, "const b2Polygon*")] ref B2Polygon shape)
		{
			fixed (B2Polygon* pshape = &shape)
			{
				byte ret = PointInPolygonNative(point, (B2Polygon*)pshape);
				return ret != 0;
			}
		}

		/// <summary>
		/// Ray cast versus circle in shape local space. Initial overlap is treated as a miss.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2RayCastCircle")]
		[return: NativeName(NativeNameType.Type, "b2CastOutput")]
		internal static B2CastOutput RayCastCircleNative([NativeName(NativeNameType.Param, "input")] [NativeName(NativeNameType.Type, "const b2RayCastInput*")] B2RayCastInput* input, [NativeName(NativeNameType.Param, "shape")] [NativeName(NativeNameType.Type, "const b2Circle*")] B2Circle* shape)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<B2RayCastInput*, B2Circle*, B2CastOutput>)vt[37])(input, shape);
			#else
			return (B2CastOutput)((delegate* unmanaged[Cdecl]<nint, nint, B2CastOutput>)vt[37])((nint)input, (nint)shape);
			#endif
		}

		/// <summary>
		/// Ray cast versus circle in shape local space. Initial overlap is treated as a miss.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2RayCastCircle")]
		[return: NativeName(NativeNameType.Type, "b2CastOutput")]
		public static B2CastOutput RayCastCircle([NativeName(NativeNameType.Param, "input")] [NativeName(NativeNameType.Type, "const b2RayCastInput*")] B2RayCastInput* input, [NativeName(NativeNameType.Param, "shape")] [NativeName(NativeNameType.Type, "const b2Circle*")] B2Circle* shape)
		{
			B2CastOutput ret = RayCastCircleNative(input, shape);
			return ret;
		}

		/// <summary>
		/// Ray cast versus circle in shape local space. Initial overlap is treated as a miss.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2RayCastCircle")]
		[return: NativeName(NativeNameType.Type, "b2CastOutput")]
		public static B2CastOutput RayCastCircle([NativeName(NativeNameType.Param, "input")] [NativeName(NativeNameType.Type, "const b2RayCastInput*")] ref B2RayCastInput input, [NativeName(NativeNameType.Param, "shape")] [NativeName(NativeNameType.Type, "const b2Circle*")] B2Circle* shape)
		{
			fixed (B2RayCastInput* pinput = &input)
			{
				B2CastOutput ret = RayCastCircleNative((B2RayCastInput*)pinput, shape);
				return ret;
			}
		}

		/// <summary>
		/// Ray cast versus circle in shape local space. Initial overlap is treated as a miss.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2RayCastCircle")]
		[return: NativeName(NativeNameType.Type, "b2CastOutput")]
		public static B2CastOutput RayCastCircle([NativeName(NativeNameType.Param, "input")] [NativeName(NativeNameType.Type, "const b2RayCastInput*")] B2RayCastInput* input, [NativeName(NativeNameType.Param, "shape")] [NativeName(NativeNameType.Type, "const b2Circle*")] ref B2Circle shape)
		{
			fixed (B2Circle* pshape = &shape)
			{
				B2CastOutput ret = RayCastCircleNative(input, (B2Circle*)pshape);
				return ret;
			}
		}

		/// <summary>
		/// Ray cast versus circle in shape local space. Initial overlap is treated as a miss.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2RayCastCircle")]
		[return: NativeName(NativeNameType.Type, "b2CastOutput")]
		public static B2CastOutput RayCastCircle([NativeName(NativeNameType.Param, "input")] [NativeName(NativeNameType.Type, "const b2RayCastInput*")] ref B2RayCastInput input, [NativeName(NativeNameType.Param, "shape")] [NativeName(NativeNameType.Type, "const b2Circle*")] ref B2Circle shape)
		{
			fixed (B2RayCastInput* pinput = &input)
			{
				fixed (B2Circle* pshape = &shape)
				{
					B2CastOutput ret = RayCastCircleNative((B2RayCastInput*)pinput, (B2Circle*)pshape);
					return ret;
				}
			}
		}

		/// <summary>
		/// Ray cast versus capsule in shape local space. Initial overlap is treated as a miss.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2RayCastCapsule")]
		[return: NativeName(NativeNameType.Type, "b2CastOutput")]
		internal static B2CastOutput RayCastCapsuleNative([NativeName(NativeNameType.Param, "input")] [NativeName(NativeNameType.Type, "const b2RayCastInput*")] B2RayCastInput* input, [NativeName(NativeNameType.Param, "shape")] [NativeName(NativeNameType.Type, "const b2Capsule*")] B2Capsule* shape)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<B2RayCastInput*, B2Capsule*, B2CastOutput>)vt[38])(input, shape);
			#else
			return (B2CastOutput)((delegate* unmanaged[Cdecl]<nint, nint, B2CastOutput>)vt[38])((nint)input, (nint)shape);
			#endif
		}

		/// <summary>
		/// Ray cast versus capsule in shape local space. Initial overlap is treated as a miss.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2RayCastCapsule")]
		[return: NativeName(NativeNameType.Type, "b2CastOutput")]
		public static B2CastOutput RayCastCapsule([NativeName(NativeNameType.Param, "input")] [NativeName(NativeNameType.Type, "const b2RayCastInput*")] B2RayCastInput* input, [NativeName(NativeNameType.Param, "shape")] [NativeName(NativeNameType.Type, "const b2Capsule*")] B2Capsule* shape)
		{
			B2CastOutput ret = RayCastCapsuleNative(input, shape);
			return ret;
		}

		/// <summary>
		/// Ray cast versus capsule in shape local space. Initial overlap is treated as a miss.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2RayCastCapsule")]
		[return: NativeName(NativeNameType.Type, "b2CastOutput")]
		public static B2CastOutput RayCastCapsule([NativeName(NativeNameType.Param, "input")] [NativeName(NativeNameType.Type, "const b2RayCastInput*")] ref B2RayCastInput input, [NativeName(NativeNameType.Param, "shape")] [NativeName(NativeNameType.Type, "const b2Capsule*")] B2Capsule* shape)
		{
			fixed (B2RayCastInput* pinput = &input)
			{
				B2CastOutput ret = RayCastCapsuleNative((B2RayCastInput*)pinput, shape);
				return ret;
			}
		}

		/// <summary>
		/// Ray cast versus capsule in shape local space. Initial overlap is treated as a miss.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2RayCastCapsule")]
		[return: NativeName(NativeNameType.Type, "b2CastOutput")]
		public static B2CastOutput RayCastCapsule([NativeName(NativeNameType.Param, "input")] [NativeName(NativeNameType.Type, "const b2RayCastInput*")] B2RayCastInput* input, [NativeName(NativeNameType.Param, "shape")] [NativeName(NativeNameType.Type, "const b2Capsule*")] ref B2Capsule shape)
		{
			fixed (B2Capsule* pshape = &shape)
			{
				B2CastOutput ret = RayCastCapsuleNative(input, (B2Capsule*)pshape);
				return ret;
			}
		}

		/// <summary>
		/// Ray cast versus capsule in shape local space. Initial overlap is treated as a miss.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2RayCastCapsule")]
		[return: NativeName(NativeNameType.Type, "b2CastOutput")]
		public static B2CastOutput RayCastCapsule([NativeName(NativeNameType.Param, "input")] [NativeName(NativeNameType.Type, "const b2RayCastInput*")] ref B2RayCastInput input, [NativeName(NativeNameType.Param, "shape")] [NativeName(NativeNameType.Type, "const b2Capsule*")] ref B2Capsule shape)
		{
			fixed (B2RayCastInput* pinput = &input)
			{
				fixed (B2Capsule* pshape = &shape)
				{
					B2CastOutput ret = RayCastCapsuleNative((B2RayCastInput*)pinput, (B2Capsule*)pshape);
					return ret;
				}
			}
		}

		/// <summary>
		/// Ray cast versus segment in shape local space. Optionally treat the segment as one-sided with hits from<br/>
		/// the left side being treated as a miss.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2RayCastSegment")]
		[return: NativeName(NativeNameType.Type, "b2CastOutput")]
		internal static B2CastOutput RayCastSegmentNative([NativeName(NativeNameType.Param, "input")] [NativeName(NativeNameType.Type, "const b2RayCastInput*")] B2RayCastInput* input, [NativeName(NativeNameType.Param, "shape")] [NativeName(NativeNameType.Type, "const b2Segment*")] B2Segment* shape, [NativeName(NativeNameType.Param, "oneSided")] [NativeName(NativeNameType.Type, "bool")] byte oneSided)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<B2RayCastInput*, B2Segment*, byte, B2CastOutput>)vt[39])(input, shape, oneSided);
			#else
			return (B2CastOutput)((delegate* unmanaged[Cdecl]<nint, nint, byte, B2CastOutput>)vt[39])((nint)input, (nint)shape, oneSided);
			#endif
		}

		/// <summary>
		/// Ray cast versus segment in shape local space. Optionally treat the segment as one-sided with hits from<br/>
		/// the left side being treated as a miss.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2RayCastSegment")]
		[return: NativeName(NativeNameType.Type, "b2CastOutput")]
		public static B2CastOutput RayCastSegment([NativeName(NativeNameType.Param, "input")] [NativeName(NativeNameType.Type, "const b2RayCastInput*")] B2RayCastInput* input, [NativeName(NativeNameType.Param, "shape")] [NativeName(NativeNameType.Type, "const b2Segment*")] B2Segment* shape, [NativeName(NativeNameType.Param, "oneSided")] [NativeName(NativeNameType.Type, "bool")] bool oneSided)
		{
			B2CastOutput ret = RayCastSegmentNative(input, shape, oneSided ? (byte)1 : (byte)0);
			return ret;
		}

		/// <summary>
		/// Ray cast versus segment in shape local space. Optionally treat the segment as one-sided with hits from<br/>
		/// the left side being treated as a miss.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2RayCastSegment")]
		[return: NativeName(NativeNameType.Type, "b2CastOutput")]
		public static B2CastOutput RayCastSegment([NativeName(NativeNameType.Param, "input")] [NativeName(NativeNameType.Type, "const b2RayCastInput*")] ref B2RayCastInput input, [NativeName(NativeNameType.Param, "shape")] [NativeName(NativeNameType.Type, "const b2Segment*")] B2Segment* shape, [NativeName(NativeNameType.Param, "oneSided")] [NativeName(NativeNameType.Type, "bool")] bool oneSided)
		{
			fixed (B2RayCastInput* pinput = &input)
			{
				B2CastOutput ret = RayCastSegmentNative((B2RayCastInput*)pinput, shape, oneSided ? (byte)1 : (byte)0);
				return ret;
			}
		}

		/// <summary>
		/// Ray cast versus segment in shape local space. Optionally treat the segment as one-sided with hits from<br/>
		/// the left side being treated as a miss.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2RayCastSegment")]
		[return: NativeName(NativeNameType.Type, "b2CastOutput")]
		public static B2CastOutput RayCastSegment([NativeName(NativeNameType.Param, "input")] [NativeName(NativeNameType.Type, "const b2RayCastInput*")] B2RayCastInput* input, [NativeName(NativeNameType.Param, "shape")] [NativeName(NativeNameType.Type, "const b2Segment*")] ref B2Segment shape, [NativeName(NativeNameType.Param, "oneSided")] [NativeName(NativeNameType.Type, "bool")] bool oneSided)
		{
			fixed (B2Segment* pshape = &shape)
			{
				B2CastOutput ret = RayCastSegmentNative(input, (B2Segment*)pshape, oneSided ? (byte)1 : (byte)0);
				return ret;
			}
		}

		/// <summary>
		/// Ray cast versus segment in shape local space. Optionally treat the segment as one-sided with hits from<br/>
		/// the left side being treated as a miss.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2RayCastSegment")]
		[return: NativeName(NativeNameType.Type, "b2CastOutput")]
		public static B2CastOutput RayCastSegment([NativeName(NativeNameType.Param, "input")] [NativeName(NativeNameType.Type, "const b2RayCastInput*")] ref B2RayCastInput input, [NativeName(NativeNameType.Param, "shape")] [NativeName(NativeNameType.Type, "const b2Segment*")] ref B2Segment shape, [NativeName(NativeNameType.Param, "oneSided")] [NativeName(NativeNameType.Type, "bool")] bool oneSided)
		{
			fixed (B2RayCastInput* pinput = &input)
			{
				fixed (B2Segment* pshape = &shape)
				{
					B2CastOutput ret = RayCastSegmentNative((B2RayCastInput*)pinput, (B2Segment*)pshape, oneSided ? (byte)1 : (byte)0);
					return ret;
				}
			}
		}

		/// <summary>
		/// Ray cast versus polygon in shape local space. Initial overlap is treated as a miss.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2RayCastPolygon")]
		[return: NativeName(NativeNameType.Type, "b2CastOutput")]
		internal static B2CastOutput RayCastPolygonNative([NativeName(NativeNameType.Param, "input")] [NativeName(NativeNameType.Type, "const b2RayCastInput*")] B2RayCastInput* input, [NativeName(NativeNameType.Param, "shape")] [NativeName(NativeNameType.Type, "const b2Polygon*")] B2Polygon* shape)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<B2RayCastInput*, B2Polygon*, B2CastOutput>)vt[40])(input, shape);
			#else
			return (B2CastOutput)((delegate* unmanaged[Cdecl]<nint, nint, B2CastOutput>)vt[40])((nint)input, (nint)shape);
			#endif
		}

		/// <summary>
		/// Ray cast versus polygon in shape local space. Initial overlap is treated as a miss.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2RayCastPolygon")]
		[return: NativeName(NativeNameType.Type, "b2CastOutput")]
		public static B2CastOutput RayCastPolygon([NativeName(NativeNameType.Param, "input")] [NativeName(NativeNameType.Type, "const b2RayCastInput*")] B2RayCastInput* input, [NativeName(NativeNameType.Param, "shape")] [NativeName(NativeNameType.Type, "const b2Polygon*")] B2Polygon* shape)
		{
			B2CastOutput ret = RayCastPolygonNative(input, shape);
			return ret;
		}

		/// <summary>
		/// Ray cast versus polygon in shape local space. Initial overlap is treated as a miss.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2RayCastPolygon")]
		[return: NativeName(NativeNameType.Type, "b2CastOutput")]
		public static B2CastOutput RayCastPolygon([NativeName(NativeNameType.Param, "input")] [NativeName(NativeNameType.Type, "const b2RayCastInput*")] ref B2RayCastInput input, [NativeName(NativeNameType.Param, "shape")] [NativeName(NativeNameType.Type, "const b2Polygon*")] B2Polygon* shape)
		{
			fixed (B2RayCastInput* pinput = &input)
			{
				B2CastOutput ret = RayCastPolygonNative((B2RayCastInput*)pinput, shape);
				return ret;
			}
		}

		/// <summary>
		/// Ray cast versus polygon in shape local space. Initial overlap is treated as a miss.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2RayCastPolygon")]
		[return: NativeName(NativeNameType.Type, "b2CastOutput")]
		public static B2CastOutput RayCastPolygon([NativeName(NativeNameType.Param, "input")] [NativeName(NativeNameType.Type, "const b2RayCastInput*")] B2RayCastInput* input, [NativeName(NativeNameType.Param, "shape")] [NativeName(NativeNameType.Type, "const b2Polygon*")] ref B2Polygon shape)
		{
			fixed (B2Polygon* pshape = &shape)
			{
				B2CastOutput ret = RayCastPolygonNative(input, (B2Polygon*)pshape);
				return ret;
			}
		}

		/// <summary>
		/// Ray cast versus polygon in shape local space. Initial overlap is treated as a miss.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2RayCastPolygon")]
		[return: NativeName(NativeNameType.Type, "b2CastOutput")]
		public static B2CastOutput RayCastPolygon([NativeName(NativeNameType.Param, "input")] [NativeName(NativeNameType.Type, "const b2RayCastInput*")] ref B2RayCastInput input, [NativeName(NativeNameType.Param, "shape")] [NativeName(NativeNameType.Type, "const b2Polygon*")] ref B2Polygon shape)
		{
			fixed (B2RayCastInput* pinput = &input)
			{
				fixed (B2Polygon* pshape = &shape)
				{
					B2CastOutput ret = RayCastPolygonNative((B2RayCastInput*)pinput, (B2Polygon*)pshape);
					return ret;
				}
			}
		}

		/// <summary>
		/// Shape cast versus a circle. Initial overlap is treated as a miss.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2ShapeCastCircle")]
		[return: NativeName(NativeNameType.Type, "b2CastOutput")]
		internal static B2CastOutput ShapeCastCircleNative([NativeName(NativeNameType.Param, "input")] [NativeName(NativeNameType.Type, "const b2ShapeCastInput*")] B2ShapeCastInput* input, [NativeName(NativeNameType.Param, "shape")] [NativeName(NativeNameType.Type, "const b2Circle*")] B2Circle* shape)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<B2ShapeCastInput*, B2Circle*, B2CastOutput>)vt[41])(input, shape);
			#else
			return (B2CastOutput)((delegate* unmanaged[Cdecl]<nint, nint, B2CastOutput>)vt[41])((nint)input, (nint)shape);
			#endif
		}

		/// <summary>
		/// Shape cast versus a circle. Initial overlap is treated as a miss.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2ShapeCastCircle")]
		[return: NativeName(NativeNameType.Type, "b2CastOutput")]
		public static B2CastOutput ShapeCastCircle([NativeName(NativeNameType.Param, "input")] [NativeName(NativeNameType.Type, "const b2ShapeCastInput*")] B2ShapeCastInput* input, [NativeName(NativeNameType.Param, "shape")] [NativeName(NativeNameType.Type, "const b2Circle*")] B2Circle* shape)
		{
			B2CastOutput ret = ShapeCastCircleNative(input, shape);
			return ret;
		}

		/// <summary>
		/// Shape cast versus a circle. Initial overlap is treated as a miss.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2ShapeCastCircle")]
		[return: NativeName(NativeNameType.Type, "b2CastOutput")]
		public static B2CastOutput ShapeCastCircle([NativeName(NativeNameType.Param, "input")] [NativeName(NativeNameType.Type, "const b2ShapeCastInput*")] ref B2ShapeCastInput input, [NativeName(NativeNameType.Param, "shape")] [NativeName(NativeNameType.Type, "const b2Circle*")] B2Circle* shape)
		{
			fixed (B2ShapeCastInput* pinput = &input)
			{
				B2CastOutput ret = ShapeCastCircleNative((B2ShapeCastInput*)pinput, shape);
				return ret;
			}
		}

		/// <summary>
		/// Shape cast versus a circle. Initial overlap is treated as a miss.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2ShapeCastCircle")]
		[return: NativeName(NativeNameType.Type, "b2CastOutput")]
		public static B2CastOutput ShapeCastCircle([NativeName(NativeNameType.Param, "input")] [NativeName(NativeNameType.Type, "const b2ShapeCastInput*")] B2ShapeCastInput* input, [NativeName(NativeNameType.Param, "shape")] [NativeName(NativeNameType.Type, "const b2Circle*")] ref B2Circle shape)
		{
			fixed (B2Circle* pshape = &shape)
			{
				B2CastOutput ret = ShapeCastCircleNative(input, (B2Circle*)pshape);
				return ret;
			}
		}

		/// <summary>
		/// Shape cast versus a circle. Initial overlap is treated as a miss.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2ShapeCastCircle")]
		[return: NativeName(NativeNameType.Type, "b2CastOutput")]
		public static B2CastOutput ShapeCastCircle([NativeName(NativeNameType.Param, "input")] [NativeName(NativeNameType.Type, "const b2ShapeCastInput*")] ref B2ShapeCastInput input, [NativeName(NativeNameType.Param, "shape")] [NativeName(NativeNameType.Type, "const b2Circle*")] ref B2Circle shape)
		{
			fixed (B2ShapeCastInput* pinput = &input)
			{
				fixed (B2Circle* pshape = &shape)
				{
					B2CastOutput ret = ShapeCastCircleNative((B2ShapeCastInput*)pinput, (B2Circle*)pshape);
					return ret;
				}
			}
		}

		/// <summary>
		/// Shape cast versus a capsule. Initial overlap is treated as a miss.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2ShapeCastCapsule")]
		[return: NativeName(NativeNameType.Type, "b2CastOutput")]
		internal static B2CastOutput ShapeCastCapsuleNative([NativeName(NativeNameType.Param, "input")] [NativeName(NativeNameType.Type, "const b2ShapeCastInput*")] B2ShapeCastInput* input, [NativeName(NativeNameType.Param, "shape")] [NativeName(NativeNameType.Type, "const b2Capsule*")] B2Capsule* shape)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<B2ShapeCastInput*, B2Capsule*, B2CastOutput>)vt[42])(input, shape);
			#else
			return (B2CastOutput)((delegate* unmanaged[Cdecl]<nint, nint, B2CastOutput>)vt[42])((nint)input, (nint)shape);
			#endif
		}

		/// <summary>
		/// Shape cast versus a capsule. Initial overlap is treated as a miss.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2ShapeCastCapsule")]
		[return: NativeName(NativeNameType.Type, "b2CastOutput")]
		public static B2CastOutput ShapeCastCapsule([NativeName(NativeNameType.Param, "input")] [NativeName(NativeNameType.Type, "const b2ShapeCastInput*")] B2ShapeCastInput* input, [NativeName(NativeNameType.Param, "shape")] [NativeName(NativeNameType.Type, "const b2Capsule*")] B2Capsule* shape)
		{
			B2CastOutput ret = ShapeCastCapsuleNative(input, shape);
			return ret;
		}

		/// <summary>
		/// Shape cast versus a capsule. Initial overlap is treated as a miss.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2ShapeCastCapsule")]
		[return: NativeName(NativeNameType.Type, "b2CastOutput")]
		public static B2CastOutput ShapeCastCapsule([NativeName(NativeNameType.Param, "input")] [NativeName(NativeNameType.Type, "const b2ShapeCastInput*")] ref B2ShapeCastInput input, [NativeName(NativeNameType.Param, "shape")] [NativeName(NativeNameType.Type, "const b2Capsule*")] B2Capsule* shape)
		{
			fixed (B2ShapeCastInput* pinput = &input)
			{
				B2CastOutput ret = ShapeCastCapsuleNative((B2ShapeCastInput*)pinput, shape);
				return ret;
			}
		}

		/// <summary>
		/// Shape cast versus a capsule. Initial overlap is treated as a miss.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2ShapeCastCapsule")]
		[return: NativeName(NativeNameType.Type, "b2CastOutput")]
		public static B2CastOutput ShapeCastCapsule([NativeName(NativeNameType.Param, "input")] [NativeName(NativeNameType.Type, "const b2ShapeCastInput*")] B2ShapeCastInput* input, [NativeName(NativeNameType.Param, "shape")] [NativeName(NativeNameType.Type, "const b2Capsule*")] ref B2Capsule shape)
		{
			fixed (B2Capsule* pshape = &shape)
			{
				B2CastOutput ret = ShapeCastCapsuleNative(input, (B2Capsule*)pshape);
				return ret;
			}
		}

		/// <summary>
		/// Shape cast versus a capsule. Initial overlap is treated as a miss.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2ShapeCastCapsule")]
		[return: NativeName(NativeNameType.Type, "b2CastOutput")]
		public static B2CastOutput ShapeCastCapsule([NativeName(NativeNameType.Param, "input")] [NativeName(NativeNameType.Type, "const b2ShapeCastInput*")] ref B2ShapeCastInput input, [NativeName(NativeNameType.Param, "shape")] [NativeName(NativeNameType.Type, "const b2Capsule*")] ref B2Capsule shape)
		{
			fixed (B2ShapeCastInput* pinput = &input)
			{
				fixed (B2Capsule* pshape = &shape)
				{
					B2CastOutput ret = ShapeCastCapsuleNative((B2ShapeCastInput*)pinput, (B2Capsule*)pshape);
					return ret;
				}
			}
		}

		/// <summary>
		/// Shape cast versus a line segment. Initial overlap is treated as a miss.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2ShapeCastSegment")]
		[return: NativeName(NativeNameType.Type, "b2CastOutput")]
		internal static B2CastOutput ShapeCastSegmentNative([NativeName(NativeNameType.Param, "input")] [NativeName(NativeNameType.Type, "const b2ShapeCastInput*")] B2ShapeCastInput* input, [NativeName(NativeNameType.Param, "shape")] [NativeName(NativeNameType.Type, "const b2Segment*")] B2Segment* shape)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<B2ShapeCastInput*, B2Segment*, B2CastOutput>)vt[43])(input, shape);
			#else
			return (B2CastOutput)((delegate* unmanaged[Cdecl]<nint, nint, B2CastOutput>)vt[43])((nint)input, (nint)shape);
			#endif
		}

		/// <summary>
		/// Shape cast versus a line segment. Initial overlap is treated as a miss.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2ShapeCastSegment")]
		[return: NativeName(NativeNameType.Type, "b2CastOutput")]
		public static B2CastOutput ShapeCastSegment([NativeName(NativeNameType.Param, "input")] [NativeName(NativeNameType.Type, "const b2ShapeCastInput*")] B2ShapeCastInput* input, [NativeName(NativeNameType.Param, "shape")] [NativeName(NativeNameType.Type, "const b2Segment*")] B2Segment* shape)
		{
			B2CastOutput ret = ShapeCastSegmentNative(input, shape);
			return ret;
		}

		/// <summary>
		/// Shape cast versus a line segment. Initial overlap is treated as a miss.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2ShapeCastSegment")]
		[return: NativeName(NativeNameType.Type, "b2CastOutput")]
		public static B2CastOutput ShapeCastSegment([NativeName(NativeNameType.Param, "input")] [NativeName(NativeNameType.Type, "const b2ShapeCastInput*")] ref B2ShapeCastInput input, [NativeName(NativeNameType.Param, "shape")] [NativeName(NativeNameType.Type, "const b2Segment*")] B2Segment* shape)
		{
			fixed (B2ShapeCastInput* pinput = &input)
			{
				B2CastOutput ret = ShapeCastSegmentNative((B2ShapeCastInput*)pinput, shape);
				return ret;
			}
		}

		/// <summary>
		/// Shape cast versus a line segment. Initial overlap is treated as a miss.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2ShapeCastSegment")]
		[return: NativeName(NativeNameType.Type, "b2CastOutput")]
		public static B2CastOutput ShapeCastSegment([NativeName(NativeNameType.Param, "input")] [NativeName(NativeNameType.Type, "const b2ShapeCastInput*")] B2ShapeCastInput* input, [NativeName(NativeNameType.Param, "shape")] [NativeName(NativeNameType.Type, "const b2Segment*")] ref B2Segment shape)
		{
			fixed (B2Segment* pshape = &shape)
			{
				B2CastOutput ret = ShapeCastSegmentNative(input, (B2Segment*)pshape);
				return ret;
			}
		}

		/// <summary>
		/// Shape cast versus a line segment. Initial overlap is treated as a miss.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2ShapeCastSegment")]
		[return: NativeName(NativeNameType.Type, "b2CastOutput")]
		public static B2CastOutput ShapeCastSegment([NativeName(NativeNameType.Param, "input")] [NativeName(NativeNameType.Type, "const b2ShapeCastInput*")] ref B2ShapeCastInput input, [NativeName(NativeNameType.Param, "shape")] [NativeName(NativeNameType.Type, "const b2Segment*")] ref B2Segment shape)
		{
			fixed (B2ShapeCastInput* pinput = &input)
			{
				fixed (B2Segment* pshape = &shape)
				{
					B2CastOutput ret = ShapeCastSegmentNative((B2ShapeCastInput*)pinput, (B2Segment*)pshape);
					return ret;
				}
			}
		}

		/// <summary>
		/// Shape cast versus a convex polygon. Initial overlap is treated as a miss.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2ShapeCastPolygon")]
		[return: NativeName(NativeNameType.Type, "b2CastOutput")]
		internal static B2CastOutput ShapeCastPolygonNative([NativeName(NativeNameType.Param, "input")] [NativeName(NativeNameType.Type, "const b2ShapeCastInput*")] B2ShapeCastInput* input, [NativeName(NativeNameType.Param, "shape")] [NativeName(NativeNameType.Type, "const b2Polygon*")] B2Polygon* shape)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<B2ShapeCastInput*, B2Polygon*, B2CastOutput>)vt[44])(input, shape);
			#else
			return (B2CastOutput)((delegate* unmanaged[Cdecl]<nint, nint, B2CastOutput>)vt[44])((nint)input, (nint)shape);
			#endif
		}

		/// <summary>
		/// Shape cast versus a convex polygon. Initial overlap is treated as a miss.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2ShapeCastPolygon")]
		[return: NativeName(NativeNameType.Type, "b2CastOutput")]
		public static B2CastOutput ShapeCastPolygon([NativeName(NativeNameType.Param, "input")] [NativeName(NativeNameType.Type, "const b2ShapeCastInput*")] B2ShapeCastInput* input, [NativeName(NativeNameType.Param, "shape")] [NativeName(NativeNameType.Type, "const b2Polygon*")] B2Polygon* shape)
		{
			B2CastOutput ret = ShapeCastPolygonNative(input, shape);
			return ret;
		}

		/// <summary>
		/// Shape cast versus a convex polygon. Initial overlap is treated as a miss.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2ShapeCastPolygon")]
		[return: NativeName(NativeNameType.Type, "b2CastOutput")]
		public static B2CastOutput ShapeCastPolygon([NativeName(NativeNameType.Param, "input")] [NativeName(NativeNameType.Type, "const b2ShapeCastInput*")] ref B2ShapeCastInput input, [NativeName(NativeNameType.Param, "shape")] [NativeName(NativeNameType.Type, "const b2Polygon*")] B2Polygon* shape)
		{
			fixed (B2ShapeCastInput* pinput = &input)
			{
				B2CastOutput ret = ShapeCastPolygonNative((B2ShapeCastInput*)pinput, shape);
				return ret;
			}
		}

		/// <summary>
		/// Shape cast versus a convex polygon. Initial overlap is treated as a miss.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2ShapeCastPolygon")]
		[return: NativeName(NativeNameType.Type, "b2CastOutput")]
		public static B2CastOutput ShapeCastPolygon([NativeName(NativeNameType.Param, "input")] [NativeName(NativeNameType.Type, "const b2ShapeCastInput*")] B2ShapeCastInput* input, [NativeName(NativeNameType.Param, "shape")] [NativeName(NativeNameType.Type, "const b2Polygon*")] ref B2Polygon shape)
		{
			fixed (B2Polygon* pshape = &shape)
			{
				B2CastOutput ret = ShapeCastPolygonNative(input, (B2Polygon*)pshape);
				return ret;
			}
		}

		/// <summary>
		/// Shape cast versus a convex polygon. Initial overlap is treated as a miss.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2ShapeCastPolygon")]
		[return: NativeName(NativeNameType.Type, "b2CastOutput")]
		public static B2CastOutput ShapeCastPolygon([NativeName(NativeNameType.Param, "input")] [NativeName(NativeNameType.Type, "const b2ShapeCastInput*")] ref B2ShapeCastInput input, [NativeName(NativeNameType.Param, "shape")] [NativeName(NativeNameType.Type, "const b2Polygon*")] ref B2Polygon shape)
		{
			fixed (B2ShapeCastInput* pinput = &input)
			{
				fixed (B2Polygon* pshape = &shape)
				{
					B2CastOutput ret = ShapeCastPolygonNative((B2ShapeCastInput*)pinput, (B2Polygon*)pshape);
					return ret;
				}
			}
		}

		/// <summary>
		/// Compute the convex hull of a set of points. Returns an empty hull if it fails.<br/>
		/// Some failure cases:<br/>
		/// - all points very close together<br/>
		/// - all points on a line<br/>
		/// - less than 3 points<br/>
		/// - more than b2_maxPolygonVertices points<br/>
		/// This welds close points and removes collinear points.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2ComputeHull")]
		[return: NativeName(NativeNameType.Type, "b2Hull")]
		internal static B2Hull ComputeHullNative([NativeName(NativeNameType.Param, "points")] [NativeName(NativeNameType.Type, "const b2Vec2*")] Vector2* points, [NativeName(NativeNameType.Param, "count")] [NativeName(NativeNameType.Type, "int32_t")] int count)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<Vector2*, int, B2Hull>)vt[45])(points, count);
			#else
			return (B2Hull)((delegate* unmanaged[Cdecl]<nint, int, B2Hull>)vt[45])((nint)points, count);
			#endif
		}

		/// <summary>
		/// Compute the convex hull of a set of points. Returns an empty hull if it fails.<br/>
		/// Some failure cases:<br/>
		/// - all points very close together<br/>
		/// - all points on a line<br/>
		/// - less than 3 points<br/>
		/// - more than b2_maxPolygonVertices points<br/>
		/// This welds close points and removes collinear points.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2ComputeHull")]
		[return: NativeName(NativeNameType.Type, "b2Hull")]
		public static B2Hull ComputeHull([NativeName(NativeNameType.Param, "points")] [NativeName(NativeNameType.Type, "const b2Vec2*")] Vector2* points, [NativeName(NativeNameType.Param, "count")] [NativeName(NativeNameType.Type, "int32_t")] int count)
		{
			B2Hull ret = ComputeHullNative(points, count);
			return ret;
		}

		/// <summary>
		/// Compute the convex hull of a set of points. Returns an empty hull if it fails.<br/>
		/// Some failure cases:<br/>
		/// - all points very close together<br/>
		/// - all points on a line<br/>
		/// - less than 3 points<br/>
		/// - more than b2_maxPolygonVertices points<br/>
		/// This welds close points and removes collinear points.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2ComputeHull")]
		[return: NativeName(NativeNameType.Type, "b2Hull")]
		public static B2Hull ComputeHull([NativeName(NativeNameType.Param, "points")] [NativeName(NativeNameType.Type, "const b2Vec2*")] ref Vector2 points, [NativeName(NativeNameType.Param, "count")] [NativeName(NativeNameType.Type, "int32_t")] int count)
		{
			fixed (Vector2* ppoints = &points)
			{
				B2Hull ret = ComputeHullNative((Vector2*)ppoints, count);
				return ret;
			}
		}

		/// <summary>
		/// This determines if a hull is valid. Checks for:<br/>
		/// - convexity<br/>
		/// - collinear points<br/>
		/// This is expensive and should not be called at runtime.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2ValidateHull")]
		[return: NativeName(NativeNameType.Type, "bool")]
		internal static byte ValidateHullNative([NativeName(NativeNameType.Param, "hull")] [NativeName(NativeNameType.Type, "const b2Hull*")] B2Hull* hull)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<B2Hull*, byte>)vt[46])(hull);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<nint, byte>)vt[46])((nint)hull);
			#endif
		}

		/// <summary>
		/// This determines if a hull is valid. Checks for:<br/>
		/// - convexity<br/>
		/// - collinear points<br/>
		/// This is expensive and should not be called at runtime.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2ValidateHull")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool ValidateHull([NativeName(NativeNameType.Param, "hull")] [NativeName(NativeNameType.Type, "const b2Hull*")] B2Hull* hull)
		{
			byte ret = ValidateHullNative(hull);
			return ret != 0;
		}

		/// <summary>
		/// This determines if a hull is valid. Checks for:<br/>
		/// - convexity<br/>
		/// - collinear points<br/>
		/// This is expensive and should not be called at runtime.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2ValidateHull")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool ValidateHull([NativeName(NativeNameType.Param, "hull")] [NativeName(NativeNameType.Type, "const b2Hull*")] ref B2Hull hull)
		{
			fixed (B2Hull* phull = &hull)
			{
				byte ret = ValidateHullNative((B2Hull*)phull);
				return ret != 0;
			}
		}

		/// <summary>
		/// Compute the distance between two line segments, clamping at the end points if needed.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2SegmentDistance")]
		[return: NativeName(NativeNameType.Type, "b2SegmentDistanceResult")]
		internal static B2SegmentDistanceResult SegmentDistanceNative([NativeName(NativeNameType.Param, "p1")] [NativeName(NativeNameType.Type, "b2Vec2")] Vector2 p1, [NativeName(NativeNameType.Param, "q1")] [NativeName(NativeNameType.Type, "b2Vec2")] Vector2 q1, [NativeName(NativeNameType.Param, "p2")] [NativeName(NativeNameType.Type, "b2Vec2")] Vector2 p2, [NativeName(NativeNameType.Param, "q2")] [NativeName(NativeNameType.Type, "b2Vec2")] Vector2 q2)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<Vector2, Vector2, Vector2, Vector2, B2SegmentDistanceResult>)vt[47])(p1, q1, p2, q2);
			#else
			return (B2SegmentDistanceResult)((delegate* unmanaged[Cdecl]<Vector2, Vector2, Vector2, Vector2, B2SegmentDistanceResult>)vt[47])(p1, q1, p2, q2);
			#endif
		}

		/// <summary>
		/// Compute the distance between two line segments, clamping at the end points if needed.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2SegmentDistance")]
		[return: NativeName(NativeNameType.Type, "b2SegmentDistanceResult")]
		public static B2SegmentDistanceResult SegmentDistance([NativeName(NativeNameType.Param, "p1")] [NativeName(NativeNameType.Type, "b2Vec2")] Vector2 p1, [NativeName(NativeNameType.Param, "q1")] [NativeName(NativeNameType.Type, "b2Vec2")] Vector2 q1, [NativeName(NativeNameType.Param, "p2")] [NativeName(NativeNameType.Type, "b2Vec2")] Vector2 p2, [NativeName(NativeNameType.Param, "q2")] [NativeName(NativeNameType.Type, "b2Vec2")] Vector2 q2)
		{
			B2SegmentDistanceResult ret = SegmentDistanceNative(p1, q1, p2, q2);
			return ret;
		}

		/// <summary>
		/// Compute the closest points between two shapes represented as point clouds.<br/>
		/// b2DistanceCache cache is input/output. On the first call set b2DistanceCache.count to zero.<br/>
		/// The underlying GJK algorithm may be debugged by passing in debug simplexes and capacity. You may pass in NULL and 0 for these.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2ShapeDistance")]
		[return: NativeName(NativeNameType.Type, "b2DistanceOutput")]
		internal static B2DistanceOutput ShapeDistanceNative([NativeName(NativeNameType.Param, "cache")] [NativeName(NativeNameType.Type, "b2DistanceCache*")] B2DistanceCache* cache, [NativeName(NativeNameType.Param, "input")] [NativeName(NativeNameType.Type, "const b2DistanceInput*")] B2DistanceInput* input, [NativeName(NativeNameType.Param, "simplexes")] [NativeName(NativeNameType.Type, "b2Simplex*")] B2Simplex* simplexes, [NativeName(NativeNameType.Param, "simplexCapacity")] [NativeName(NativeNameType.Type, "int")] int simplexCapacity)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<B2DistanceCache*, B2DistanceInput*, B2Simplex*, int, B2DistanceOutput>)vt[48])(cache, input, simplexes, simplexCapacity);
			#else
			return (B2DistanceOutput)((delegate* unmanaged[Cdecl]<nint, nint, nint, int, B2DistanceOutput>)vt[48])((nint)cache, (nint)input, (nint)simplexes, simplexCapacity);
			#endif
		}

		/// <summary>
		/// Compute the closest points between two shapes represented as point clouds.<br/>
		/// b2DistanceCache cache is input/output. On the first call set b2DistanceCache.count to zero.<br/>
		/// The underlying GJK algorithm may be debugged by passing in debug simplexes and capacity. You may pass in NULL and 0 for these.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2ShapeDistance")]
		[return: NativeName(NativeNameType.Type, "b2DistanceOutput")]
		public static B2DistanceOutput ShapeDistance([NativeName(NativeNameType.Param, "cache")] [NativeName(NativeNameType.Type, "b2DistanceCache*")] B2DistanceCache* cache, [NativeName(NativeNameType.Param, "input")] [NativeName(NativeNameType.Type, "const b2DistanceInput*")] B2DistanceInput* input, [NativeName(NativeNameType.Param, "simplexes")] [NativeName(NativeNameType.Type, "b2Simplex*")] B2Simplex* simplexes, [NativeName(NativeNameType.Param, "simplexCapacity")] [NativeName(NativeNameType.Type, "int")] int simplexCapacity)
		{
			B2DistanceOutput ret = ShapeDistanceNative(cache, input, simplexes, simplexCapacity);
			return ret;
		}

		/// <summary>
		/// Compute the closest points between two shapes represented as point clouds.<br/>
		/// b2DistanceCache cache is input/output. On the first call set b2DistanceCache.count to zero.<br/>
		/// The underlying GJK algorithm may be debugged by passing in debug simplexes and capacity. You may pass in NULL and 0 for these.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2ShapeDistance")]
		[return: NativeName(NativeNameType.Type, "b2DistanceOutput")]
		public static B2DistanceOutput ShapeDistance([NativeName(NativeNameType.Param, "cache")] [NativeName(NativeNameType.Type, "b2DistanceCache*")] ref B2DistanceCache cache, [NativeName(NativeNameType.Param, "input")] [NativeName(NativeNameType.Type, "const b2DistanceInput*")] B2DistanceInput* input, [NativeName(NativeNameType.Param, "simplexes")] [NativeName(NativeNameType.Type, "b2Simplex*")] B2Simplex* simplexes, [NativeName(NativeNameType.Param, "simplexCapacity")] [NativeName(NativeNameType.Type, "int")] int simplexCapacity)
		{
			fixed (B2DistanceCache* pcache = &cache)
			{
				B2DistanceOutput ret = ShapeDistanceNative((B2DistanceCache*)pcache, input, simplexes, simplexCapacity);
				return ret;
			}
		}

		/// <summary>
		/// Compute the closest points between two shapes represented as point clouds.<br/>
		/// b2DistanceCache cache is input/output. On the first call set b2DistanceCache.count to zero.<br/>
		/// The underlying GJK algorithm may be debugged by passing in debug simplexes and capacity. You may pass in NULL and 0 for these.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2ShapeDistance")]
		[return: NativeName(NativeNameType.Type, "b2DistanceOutput")]
		public static B2DistanceOutput ShapeDistance([NativeName(NativeNameType.Param, "cache")] [NativeName(NativeNameType.Type, "b2DistanceCache*")] B2DistanceCache* cache, [NativeName(NativeNameType.Param, "input")] [NativeName(NativeNameType.Type, "const b2DistanceInput*")] ref B2DistanceInput input, [NativeName(NativeNameType.Param, "simplexes")] [NativeName(NativeNameType.Type, "b2Simplex*")] B2Simplex* simplexes, [NativeName(NativeNameType.Param, "simplexCapacity")] [NativeName(NativeNameType.Type, "int")] int simplexCapacity)
		{
			fixed (B2DistanceInput* pinput = &input)
			{
				B2DistanceOutput ret = ShapeDistanceNative(cache, (B2DistanceInput*)pinput, simplexes, simplexCapacity);
				return ret;
			}
		}

		/// <summary>
		/// Compute the closest points between two shapes represented as point clouds.<br/>
		/// b2DistanceCache cache is input/output. On the first call set b2DistanceCache.count to zero.<br/>
		/// The underlying GJK algorithm may be debugged by passing in debug simplexes and capacity. You may pass in NULL and 0 for these.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2ShapeDistance")]
		[return: NativeName(NativeNameType.Type, "b2DistanceOutput")]
		public static B2DistanceOutput ShapeDistance([NativeName(NativeNameType.Param, "cache")] [NativeName(NativeNameType.Type, "b2DistanceCache*")] ref B2DistanceCache cache, [NativeName(NativeNameType.Param, "input")] [NativeName(NativeNameType.Type, "const b2DistanceInput*")] ref B2DistanceInput input, [NativeName(NativeNameType.Param, "simplexes")] [NativeName(NativeNameType.Type, "b2Simplex*")] B2Simplex* simplexes, [NativeName(NativeNameType.Param, "simplexCapacity")] [NativeName(NativeNameType.Type, "int")] int simplexCapacity)
		{
			fixed (B2DistanceCache* pcache = &cache)
			{
				fixed (B2DistanceInput* pinput = &input)
				{
					B2DistanceOutput ret = ShapeDistanceNative((B2DistanceCache*)pcache, (B2DistanceInput*)pinput, simplexes, simplexCapacity);
					return ret;
				}
			}
		}

		/// <summary>
		/// Compute the closest points between two shapes represented as point clouds.<br/>
		/// b2DistanceCache cache is input/output. On the first call set b2DistanceCache.count to zero.<br/>
		/// The underlying GJK algorithm may be debugged by passing in debug simplexes and capacity. You may pass in NULL and 0 for these.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2ShapeDistance")]
		[return: NativeName(NativeNameType.Type, "b2DistanceOutput")]
		public static B2DistanceOutput ShapeDistance([NativeName(NativeNameType.Param, "cache")] [NativeName(NativeNameType.Type, "b2DistanceCache*")] B2DistanceCache* cache, [NativeName(NativeNameType.Param, "input")] [NativeName(NativeNameType.Type, "const b2DistanceInput*")] B2DistanceInput* input, [NativeName(NativeNameType.Param, "simplexes")] [NativeName(NativeNameType.Type, "b2Simplex*")] ref B2Simplex simplexes, [NativeName(NativeNameType.Param, "simplexCapacity")] [NativeName(NativeNameType.Type, "int")] int simplexCapacity)
		{
			fixed (B2Simplex* psimplexes = &simplexes)
			{
				B2DistanceOutput ret = ShapeDistanceNative(cache, input, (B2Simplex*)psimplexes, simplexCapacity);
				return ret;
			}
		}

		/// <summary>
		/// Compute the closest points between two shapes represented as point clouds.<br/>
		/// b2DistanceCache cache is input/output. On the first call set b2DistanceCache.count to zero.<br/>
		/// The underlying GJK algorithm may be debugged by passing in debug simplexes and capacity. You may pass in NULL and 0 for these.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2ShapeDistance")]
		[return: NativeName(NativeNameType.Type, "b2DistanceOutput")]
		public static B2DistanceOutput ShapeDistance([NativeName(NativeNameType.Param, "cache")] [NativeName(NativeNameType.Type, "b2DistanceCache*")] ref B2DistanceCache cache, [NativeName(NativeNameType.Param, "input")] [NativeName(NativeNameType.Type, "const b2DistanceInput*")] B2DistanceInput* input, [NativeName(NativeNameType.Param, "simplexes")] [NativeName(NativeNameType.Type, "b2Simplex*")] ref B2Simplex simplexes, [NativeName(NativeNameType.Param, "simplexCapacity")] [NativeName(NativeNameType.Type, "int")] int simplexCapacity)
		{
			fixed (B2DistanceCache* pcache = &cache)
			{
				fixed (B2Simplex* psimplexes = &simplexes)
				{
					B2DistanceOutput ret = ShapeDistanceNative((B2DistanceCache*)pcache, input, (B2Simplex*)psimplexes, simplexCapacity);
					return ret;
				}
			}
		}

		/// <summary>
		/// Compute the closest points between two shapes represented as point clouds.<br/>
		/// b2DistanceCache cache is input/output. On the first call set b2DistanceCache.count to zero.<br/>
		/// The underlying GJK algorithm may be debugged by passing in debug simplexes and capacity. You may pass in NULL and 0 for these.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2ShapeDistance")]
		[return: NativeName(NativeNameType.Type, "b2DistanceOutput")]
		public static B2DistanceOutput ShapeDistance([NativeName(NativeNameType.Param, "cache")] [NativeName(NativeNameType.Type, "b2DistanceCache*")] B2DistanceCache* cache, [NativeName(NativeNameType.Param, "input")] [NativeName(NativeNameType.Type, "const b2DistanceInput*")] ref B2DistanceInput input, [NativeName(NativeNameType.Param, "simplexes")] [NativeName(NativeNameType.Type, "b2Simplex*")] ref B2Simplex simplexes, [NativeName(NativeNameType.Param, "simplexCapacity")] [NativeName(NativeNameType.Type, "int")] int simplexCapacity)
		{
			fixed (B2DistanceInput* pinput = &input)
			{
				fixed (B2Simplex* psimplexes = &simplexes)
				{
					B2DistanceOutput ret = ShapeDistanceNative(cache, (B2DistanceInput*)pinput, (B2Simplex*)psimplexes, simplexCapacity);
					return ret;
				}
			}
		}

		/// <summary>
		/// Compute the closest points between two shapes represented as point clouds.<br/>
		/// b2DistanceCache cache is input/output. On the first call set b2DistanceCache.count to zero.<br/>
		/// The underlying GJK algorithm may be debugged by passing in debug simplexes and capacity. You may pass in NULL and 0 for these.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2ShapeDistance")]
		[return: NativeName(NativeNameType.Type, "b2DistanceOutput")]
		public static B2DistanceOutput ShapeDistance([NativeName(NativeNameType.Param, "cache")] [NativeName(NativeNameType.Type, "b2DistanceCache*")] ref B2DistanceCache cache, [NativeName(NativeNameType.Param, "input")] [NativeName(NativeNameType.Type, "const b2DistanceInput*")] ref B2DistanceInput input, [NativeName(NativeNameType.Param, "simplexes")] [NativeName(NativeNameType.Type, "b2Simplex*")] ref B2Simplex simplexes, [NativeName(NativeNameType.Param, "simplexCapacity")] [NativeName(NativeNameType.Type, "int")] int simplexCapacity)
		{
			fixed (B2DistanceCache* pcache = &cache)
			{
				fixed (B2DistanceInput* pinput = &input)
				{
					fixed (B2Simplex* psimplexes = &simplexes)
					{
						B2DistanceOutput ret = ShapeDistanceNative((B2DistanceCache*)pcache, (B2DistanceInput*)pinput, (B2Simplex*)psimplexes, simplexCapacity);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Perform a linear shape cast of shape B moving and shape A fixed. Determines the hit point, normal, and translation fraction.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2ShapeCast")]
		[return: NativeName(NativeNameType.Type, "b2CastOutput")]
		internal static B2CastOutput ShapeCastNative([NativeName(NativeNameType.Param, "input")] [NativeName(NativeNameType.Type, "const b2ShapeCastPairInput*")] B2ShapeCastPairInput* input)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<B2ShapeCastPairInput*, B2CastOutput>)vt[49])(input);
			#else
			return (B2CastOutput)((delegate* unmanaged[Cdecl]<nint, B2CastOutput>)vt[49])((nint)input);
			#endif
		}

		/// <summary>
		/// Perform a linear shape cast of shape B moving and shape A fixed. Determines the hit point, normal, and translation fraction.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2ShapeCast")]
		[return: NativeName(NativeNameType.Type, "b2CastOutput")]
		public static B2CastOutput ShapeCast([NativeName(NativeNameType.Param, "input")] [NativeName(NativeNameType.Type, "const b2ShapeCastPairInput*")] B2ShapeCastPairInput* input)
		{
			B2CastOutput ret = ShapeCastNative(input);
			return ret;
		}

		/// <summary>
		/// Perform a linear shape cast of shape B moving and shape A fixed. Determines the hit point, normal, and translation fraction.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2ShapeCast")]
		[return: NativeName(NativeNameType.Type, "b2CastOutput")]
		public static B2CastOutput ShapeCast([NativeName(NativeNameType.Param, "input")] [NativeName(NativeNameType.Type, "const b2ShapeCastPairInput*")] ref B2ShapeCastPairInput input)
		{
			fixed (B2ShapeCastPairInput* pinput = &input)
			{
				B2CastOutput ret = ShapeCastNative((B2ShapeCastPairInput*)pinput);
				return ret;
			}
		}

		/// <summary>
		/// Make a proxy for use in GJK and related functions.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2MakeProxy")]
		[return: NativeName(NativeNameType.Type, "b2DistanceProxy")]
		internal static B2DistanceProxy MakeProxyNative([NativeName(NativeNameType.Param, "vertices")] [NativeName(NativeNameType.Type, "const b2Vec2*")] Vector2* vertices, [NativeName(NativeNameType.Param, "count")] [NativeName(NativeNameType.Type, "int32_t")] int count, [NativeName(NativeNameType.Param, "radius")] [NativeName(NativeNameType.Type, "float")] float radius)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<Vector2*, int, float, B2DistanceProxy>)vt[50])(vertices, count, radius);
			#else
			return (B2DistanceProxy)((delegate* unmanaged[Cdecl]<nint, int, float, B2DistanceProxy>)vt[50])((nint)vertices, count, radius);
			#endif
		}

		/// <summary>
		/// Make a proxy for use in GJK and related functions.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2MakeProxy")]
		[return: NativeName(NativeNameType.Type, "b2DistanceProxy")]
		public static B2DistanceProxy MakeProxy([NativeName(NativeNameType.Param, "vertices")] [NativeName(NativeNameType.Type, "const b2Vec2*")] Vector2* vertices, [NativeName(NativeNameType.Param, "count")] [NativeName(NativeNameType.Type, "int32_t")] int count, [NativeName(NativeNameType.Param, "radius")] [NativeName(NativeNameType.Type, "float")] float radius)
		{
			B2DistanceProxy ret = MakeProxyNative(vertices, count, radius);
			return ret;
		}

		/// <summary>
		/// Make a proxy for use in GJK and related functions.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2MakeProxy")]
		[return: NativeName(NativeNameType.Type, "b2DistanceProxy")]
		public static B2DistanceProxy MakeProxy([NativeName(NativeNameType.Param, "vertices")] [NativeName(NativeNameType.Type, "const b2Vec2*")] ref Vector2 vertices, [NativeName(NativeNameType.Param, "count")] [NativeName(NativeNameType.Type, "int32_t")] int count, [NativeName(NativeNameType.Param, "radius")] [NativeName(NativeNameType.Type, "float")] float radius)
		{
			fixed (Vector2* pvertices = &vertices)
			{
				B2DistanceProxy ret = MakeProxyNative((Vector2*)pvertices, count, radius);
				return ret;
			}
		}

		/// <summary>
		/// Evaluate the transform sweep at a specific time.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2GetSweepTransform")]
		[return: NativeName(NativeNameType.Type, "b2Transform")]
		internal static B2Transform GetSweepTransformNative([NativeName(NativeNameType.Param, "sweep")] [NativeName(NativeNameType.Type, "const b2Sweep*")] B2Sweep* sweep, [NativeName(NativeNameType.Param, "time")] [NativeName(NativeNameType.Type, "float")] float time)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<B2Sweep*, float, B2Transform>)vt[51])(sweep, time);
			#else
			return (B2Transform)((delegate* unmanaged[Cdecl]<nint, float, B2Transform>)vt[51])((nint)sweep, time);
			#endif
		}

		/// <summary>
		/// Evaluate the transform sweep at a specific time.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2GetSweepTransform")]
		[return: NativeName(NativeNameType.Type, "b2Transform")]
		public static B2Transform GetSweepTransform([NativeName(NativeNameType.Param, "sweep")] [NativeName(NativeNameType.Type, "const b2Sweep*")] B2Sweep* sweep, [NativeName(NativeNameType.Param, "time")] [NativeName(NativeNameType.Type, "float")] float time)
		{
			B2Transform ret = GetSweepTransformNative(sweep, time);
			return ret;
		}

		/// <summary>
		/// Evaluate the transform sweep at a specific time.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2GetSweepTransform")]
		[return: NativeName(NativeNameType.Type, "b2Transform")]
		public static B2Transform GetSweepTransform([NativeName(NativeNameType.Param, "sweep")] [NativeName(NativeNameType.Type, "const b2Sweep*")] ref B2Sweep sweep, [NativeName(NativeNameType.Param, "time")] [NativeName(NativeNameType.Type, "float")] float time)
		{
			fixed (B2Sweep* psweep = &sweep)
			{
				B2Transform ret = GetSweepTransformNative((B2Sweep*)psweep, time);
				return ret;
			}
		}

		/// <summary>
		/// Compute the upper bound on time before two shapes penetrate. Time is represented as<br/>
		/// a fraction between [0,tMax]. This uses a swept separating axis and may miss some intermediate,<br/>
		/// non-tunneling collisions. If you change the time interval, you should call this function<br/>
		/// again.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2TimeOfImpact")]
		[return: NativeName(NativeNameType.Type, "b2TOIOutput")]
		internal static B2TOIOutput TimeOfImpactNative([NativeName(NativeNameType.Param, "input")] [NativeName(NativeNameType.Type, "const b2TOIInput*")] B2TOIInput* input)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<B2TOIInput*, B2TOIOutput>)vt[52])(input);
			#else
			return (B2TOIOutput)((delegate* unmanaged[Cdecl]<nint, B2TOIOutput>)vt[52])((nint)input);
			#endif
		}

		/// <summary>
		/// Compute the upper bound on time before two shapes penetrate. Time is represented as<br/>
		/// a fraction between [0,tMax]. This uses a swept separating axis and may miss some intermediate,<br/>
		/// non-tunneling collisions. If you change the time interval, you should call this function<br/>
		/// again.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2TimeOfImpact")]
		[return: NativeName(NativeNameType.Type, "b2TOIOutput")]
		public static B2TOIOutput TimeOfImpact([NativeName(NativeNameType.Param, "input")] [NativeName(NativeNameType.Type, "const b2TOIInput*")] B2TOIInput* input)
		{
			B2TOIOutput ret = TimeOfImpactNative(input);
			return ret;
		}

		/// <summary>
		/// Compute the upper bound on time before two shapes penetrate. Time is represented as<br/>
		/// a fraction between [0,tMax]. This uses a swept separating axis and may miss some intermediate,<br/>
		/// non-tunneling collisions. If you change the time interval, you should call this function<br/>
		/// again.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2TimeOfImpact")]
		[return: NativeName(NativeNameType.Type, "b2TOIOutput")]
		public static B2TOIOutput TimeOfImpact([NativeName(NativeNameType.Param, "input")] [NativeName(NativeNameType.Type, "const b2TOIInput*")] ref B2TOIInput input)
		{
			fixed (B2TOIInput* pinput = &input)
			{
				B2TOIOutput ret = TimeOfImpactNative((B2TOIInput*)pinput);
				return ret;
			}
		}

		/// <summary>
		/// Compute the contact manifold between two circles<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2CollideCircles")]
		[return: NativeName(NativeNameType.Type, "b2Manifold")]
		internal static B2Manifold CollideCirclesNative([NativeName(NativeNameType.Param, "circleA")] [NativeName(NativeNameType.Type, "const b2Circle*")] B2Circle* circleA, [NativeName(NativeNameType.Param, "xfA")] [NativeName(NativeNameType.Type, "b2Transform")] B2Transform xfA, [NativeName(NativeNameType.Param, "circleB")] [NativeName(NativeNameType.Type, "const b2Circle*")] B2Circle* circleB, [NativeName(NativeNameType.Param, "xfB")] [NativeName(NativeNameType.Type, "b2Transform")] B2Transform xfB)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<B2Circle*, B2Transform, B2Circle*, B2Transform, B2Manifold>)vt[53])(circleA, xfA, circleB, xfB);
			#else
			return (B2Manifold)((delegate* unmanaged[Cdecl]<nint, B2Transform, nint, B2Transform, B2Manifold>)vt[53])((nint)circleA, xfA, (nint)circleB, xfB);
			#endif
		}

		/// <summary>
		/// Compute the contact manifold between two circles<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2CollideCircles")]
		[return: NativeName(NativeNameType.Type, "b2Manifold")]
		public static B2Manifold CollideCircles([NativeName(NativeNameType.Param, "circleA")] [NativeName(NativeNameType.Type, "const b2Circle*")] B2Circle* circleA, [NativeName(NativeNameType.Param, "xfA")] [NativeName(NativeNameType.Type, "b2Transform")] B2Transform xfA, [NativeName(NativeNameType.Param, "circleB")] [NativeName(NativeNameType.Type, "const b2Circle*")] B2Circle* circleB, [NativeName(NativeNameType.Param, "xfB")] [NativeName(NativeNameType.Type, "b2Transform")] B2Transform xfB)
		{
			B2Manifold ret = CollideCirclesNative(circleA, xfA, circleB, xfB);
			return ret;
		}

		/// <summary>
		/// Compute the contact manifold between two circles<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2CollideCircles")]
		[return: NativeName(NativeNameType.Type, "b2Manifold")]
		public static B2Manifold CollideCircles([NativeName(NativeNameType.Param, "circleA")] [NativeName(NativeNameType.Type, "const b2Circle*")] ref B2Circle circleA, [NativeName(NativeNameType.Param, "xfA")] [NativeName(NativeNameType.Type, "b2Transform")] B2Transform xfA, [NativeName(NativeNameType.Param, "circleB")] [NativeName(NativeNameType.Type, "const b2Circle*")] B2Circle* circleB, [NativeName(NativeNameType.Param, "xfB")] [NativeName(NativeNameType.Type, "b2Transform")] B2Transform xfB)
		{
			fixed (B2Circle* pcircleA = &circleA)
			{
				B2Manifold ret = CollideCirclesNative((B2Circle*)pcircleA, xfA, circleB, xfB);
				return ret;
			}
		}

		/// <summary>
		/// Compute the contact manifold between two circles<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2CollideCircles")]
		[return: NativeName(NativeNameType.Type, "b2Manifold")]
		public static B2Manifold CollideCircles([NativeName(NativeNameType.Param, "circleA")] [NativeName(NativeNameType.Type, "const b2Circle*")] B2Circle* circleA, [NativeName(NativeNameType.Param, "xfA")] [NativeName(NativeNameType.Type, "b2Transform")] B2Transform xfA, [NativeName(NativeNameType.Param, "circleB")] [NativeName(NativeNameType.Type, "const b2Circle*")] ref B2Circle circleB, [NativeName(NativeNameType.Param, "xfB")] [NativeName(NativeNameType.Type, "b2Transform")] B2Transform xfB)
		{
			fixed (B2Circle* pcircleB = &circleB)
			{
				B2Manifold ret = CollideCirclesNative(circleA, xfA, (B2Circle*)pcircleB, xfB);
				return ret;
			}
		}

		/// <summary>
		/// Compute the contact manifold between two circles<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2CollideCircles")]
		[return: NativeName(NativeNameType.Type, "b2Manifold")]
		public static B2Manifold CollideCircles([NativeName(NativeNameType.Param, "circleA")] [NativeName(NativeNameType.Type, "const b2Circle*")] ref B2Circle circleA, [NativeName(NativeNameType.Param, "xfA")] [NativeName(NativeNameType.Type, "b2Transform")] B2Transform xfA, [NativeName(NativeNameType.Param, "circleB")] [NativeName(NativeNameType.Type, "const b2Circle*")] ref B2Circle circleB, [NativeName(NativeNameType.Param, "xfB")] [NativeName(NativeNameType.Type, "b2Transform")] B2Transform xfB)
		{
			fixed (B2Circle* pcircleA = &circleA)
			{
				fixed (B2Circle* pcircleB = &circleB)
				{
					B2Manifold ret = CollideCirclesNative((B2Circle*)pcircleA, xfA, (B2Circle*)pcircleB, xfB);
					return ret;
				}
			}
		}

		/// <summary>
		/// Compute the contact manifold between a capsule and circle<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2CollideCapsuleAndCircle")]
		[return: NativeName(NativeNameType.Type, "b2Manifold")]
		internal static B2Manifold CollideCapsuleAndCircleNative([NativeName(NativeNameType.Param, "capsuleA")] [NativeName(NativeNameType.Type, "const b2Capsule*")] B2Capsule* capsuleA, [NativeName(NativeNameType.Param, "xfA")] [NativeName(NativeNameType.Type, "b2Transform")] B2Transform xfA, [NativeName(NativeNameType.Param, "circleB")] [NativeName(NativeNameType.Type, "const b2Circle*")] B2Circle* circleB, [NativeName(NativeNameType.Param, "xfB")] [NativeName(NativeNameType.Type, "b2Transform")] B2Transform xfB)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<B2Capsule*, B2Transform, B2Circle*, B2Transform, B2Manifold>)vt[54])(capsuleA, xfA, circleB, xfB);
			#else
			return (B2Manifold)((delegate* unmanaged[Cdecl]<nint, B2Transform, nint, B2Transform, B2Manifold>)vt[54])((nint)capsuleA, xfA, (nint)circleB, xfB);
			#endif
		}

		/// <summary>
		/// Compute the contact manifold between a capsule and circle<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2CollideCapsuleAndCircle")]
		[return: NativeName(NativeNameType.Type, "b2Manifold")]
		public static B2Manifold CollideCapsuleAndCircle([NativeName(NativeNameType.Param, "capsuleA")] [NativeName(NativeNameType.Type, "const b2Capsule*")] B2Capsule* capsuleA, [NativeName(NativeNameType.Param, "xfA")] [NativeName(NativeNameType.Type, "b2Transform")] B2Transform xfA, [NativeName(NativeNameType.Param, "circleB")] [NativeName(NativeNameType.Type, "const b2Circle*")] B2Circle* circleB, [NativeName(NativeNameType.Param, "xfB")] [NativeName(NativeNameType.Type, "b2Transform")] B2Transform xfB)
		{
			B2Manifold ret = CollideCapsuleAndCircleNative(capsuleA, xfA, circleB, xfB);
			return ret;
		}

		/// <summary>
		/// Compute the contact manifold between a capsule and circle<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2CollideCapsuleAndCircle")]
		[return: NativeName(NativeNameType.Type, "b2Manifold")]
		public static B2Manifold CollideCapsuleAndCircle([NativeName(NativeNameType.Param, "capsuleA")] [NativeName(NativeNameType.Type, "const b2Capsule*")] ref B2Capsule capsuleA, [NativeName(NativeNameType.Param, "xfA")] [NativeName(NativeNameType.Type, "b2Transform")] B2Transform xfA, [NativeName(NativeNameType.Param, "circleB")] [NativeName(NativeNameType.Type, "const b2Circle*")] B2Circle* circleB, [NativeName(NativeNameType.Param, "xfB")] [NativeName(NativeNameType.Type, "b2Transform")] B2Transform xfB)
		{
			fixed (B2Capsule* pcapsuleA = &capsuleA)
			{
				B2Manifold ret = CollideCapsuleAndCircleNative((B2Capsule*)pcapsuleA, xfA, circleB, xfB);
				return ret;
			}
		}

		/// <summary>
		/// Compute the contact manifold between a capsule and circle<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2CollideCapsuleAndCircle")]
		[return: NativeName(NativeNameType.Type, "b2Manifold")]
		public static B2Manifold CollideCapsuleAndCircle([NativeName(NativeNameType.Param, "capsuleA")] [NativeName(NativeNameType.Type, "const b2Capsule*")] B2Capsule* capsuleA, [NativeName(NativeNameType.Param, "xfA")] [NativeName(NativeNameType.Type, "b2Transform")] B2Transform xfA, [NativeName(NativeNameType.Param, "circleB")] [NativeName(NativeNameType.Type, "const b2Circle*")] ref B2Circle circleB, [NativeName(NativeNameType.Param, "xfB")] [NativeName(NativeNameType.Type, "b2Transform")] B2Transform xfB)
		{
			fixed (B2Circle* pcircleB = &circleB)
			{
				B2Manifold ret = CollideCapsuleAndCircleNative(capsuleA, xfA, (B2Circle*)pcircleB, xfB);
				return ret;
			}
		}

		/// <summary>
		/// Compute the contact manifold between a capsule and circle<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2CollideCapsuleAndCircle")]
		[return: NativeName(NativeNameType.Type, "b2Manifold")]
		public static B2Manifold CollideCapsuleAndCircle([NativeName(NativeNameType.Param, "capsuleA")] [NativeName(NativeNameType.Type, "const b2Capsule*")] ref B2Capsule capsuleA, [NativeName(NativeNameType.Param, "xfA")] [NativeName(NativeNameType.Type, "b2Transform")] B2Transform xfA, [NativeName(NativeNameType.Param, "circleB")] [NativeName(NativeNameType.Type, "const b2Circle*")] ref B2Circle circleB, [NativeName(NativeNameType.Param, "xfB")] [NativeName(NativeNameType.Type, "b2Transform")] B2Transform xfB)
		{
			fixed (B2Capsule* pcapsuleA = &capsuleA)
			{
				fixed (B2Circle* pcircleB = &circleB)
				{
					B2Manifold ret = CollideCapsuleAndCircleNative((B2Capsule*)pcapsuleA, xfA, (B2Circle*)pcircleB, xfB);
					return ret;
				}
			}
		}

		/// <summary>
		/// Compute the contact manifold between an segment and a circle<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2CollideSegmentAndCircle")]
		[return: NativeName(NativeNameType.Type, "b2Manifold")]
		internal static B2Manifold CollideSegmentAndCircleNative([NativeName(NativeNameType.Param, "segmentA")] [NativeName(NativeNameType.Type, "const b2Segment*")] B2Segment* segmentA, [NativeName(NativeNameType.Param, "xfA")] [NativeName(NativeNameType.Type, "b2Transform")] B2Transform xfA, [NativeName(NativeNameType.Param, "circleB")] [NativeName(NativeNameType.Type, "const b2Circle*")] B2Circle* circleB, [NativeName(NativeNameType.Param, "xfB")] [NativeName(NativeNameType.Type, "b2Transform")] B2Transform xfB)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<B2Segment*, B2Transform, B2Circle*, B2Transform, B2Manifold>)vt[55])(segmentA, xfA, circleB, xfB);
			#else
			return (B2Manifold)((delegate* unmanaged[Cdecl]<nint, B2Transform, nint, B2Transform, B2Manifold>)vt[55])((nint)segmentA, xfA, (nint)circleB, xfB);
			#endif
		}

		/// <summary>
		/// Compute the contact manifold between an segment and a circle<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2CollideSegmentAndCircle")]
		[return: NativeName(NativeNameType.Type, "b2Manifold")]
		public static B2Manifold CollideSegmentAndCircle([NativeName(NativeNameType.Param, "segmentA")] [NativeName(NativeNameType.Type, "const b2Segment*")] B2Segment* segmentA, [NativeName(NativeNameType.Param, "xfA")] [NativeName(NativeNameType.Type, "b2Transform")] B2Transform xfA, [NativeName(NativeNameType.Param, "circleB")] [NativeName(NativeNameType.Type, "const b2Circle*")] B2Circle* circleB, [NativeName(NativeNameType.Param, "xfB")] [NativeName(NativeNameType.Type, "b2Transform")] B2Transform xfB)
		{
			B2Manifold ret = CollideSegmentAndCircleNative(segmentA, xfA, circleB, xfB);
			return ret;
		}

		/// <summary>
		/// Compute the contact manifold between an segment and a circle<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2CollideSegmentAndCircle")]
		[return: NativeName(NativeNameType.Type, "b2Manifold")]
		public static B2Manifold CollideSegmentAndCircle([NativeName(NativeNameType.Param, "segmentA")] [NativeName(NativeNameType.Type, "const b2Segment*")] ref B2Segment segmentA, [NativeName(NativeNameType.Param, "xfA")] [NativeName(NativeNameType.Type, "b2Transform")] B2Transform xfA, [NativeName(NativeNameType.Param, "circleB")] [NativeName(NativeNameType.Type, "const b2Circle*")] B2Circle* circleB, [NativeName(NativeNameType.Param, "xfB")] [NativeName(NativeNameType.Type, "b2Transform")] B2Transform xfB)
		{
			fixed (B2Segment* psegmentA = &segmentA)
			{
				B2Manifold ret = CollideSegmentAndCircleNative((B2Segment*)psegmentA, xfA, circleB, xfB);
				return ret;
			}
		}

		/// <summary>
		/// Compute the contact manifold between an segment and a circle<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2CollideSegmentAndCircle")]
		[return: NativeName(NativeNameType.Type, "b2Manifold")]
		public static B2Manifold CollideSegmentAndCircle([NativeName(NativeNameType.Param, "segmentA")] [NativeName(NativeNameType.Type, "const b2Segment*")] B2Segment* segmentA, [NativeName(NativeNameType.Param, "xfA")] [NativeName(NativeNameType.Type, "b2Transform")] B2Transform xfA, [NativeName(NativeNameType.Param, "circleB")] [NativeName(NativeNameType.Type, "const b2Circle*")] ref B2Circle circleB, [NativeName(NativeNameType.Param, "xfB")] [NativeName(NativeNameType.Type, "b2Transform")] B2Transform xfB)
		{
			fixed (B2Circle* pcircleB = &circleB)
			{
				B2Manifold ret = CollideSegmentAndCircleNative(segmentA, xfA, (B2Circle*)pcircleB, xfB);
				return ret;
			}
		}

		/// <summary>
		/// Compute the contact manifold between an segment and a circle<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2CollideSegmentAndCircle")]
		[return: NativeName(NativeNameType.Type, "b2Manifold")]
		public static B2Manifold CollideSegmentAndCircle([NativeName(NativeNameType.Param, "segmentA")] [NativeName(NativeNameType.Type, "const b2Segment*")] ref B2Segment segmentA, [NativeName(NativeNameType.Param, "xfA")] [NativeName(NativeNameType.Type, "b2Transform")] B2Transform xfA, [NativeName(NativeNameType.Param, "circleB")] [NativeName(NativeNameType.Type, "const b2Circle*")] ref B2Circle circleB, [NativeName(NativeNameType.Param, "xfB")] [NativeName(NativeNameType.Type, "b2Transform")] B2Transform xfB)
		{
			fixed (B2Segment* psegmentA = &segmentA)
			{
				fixed (B2Circle* pcircleB = &circleB)
				{
					B2Manifold ret = CollideSegmentAndCircleNative((B2Segment*)psegmentA, xfA, (B2Circle*)pcircleB, xfB);
					return ret;
				}
			}
		}

		/// <summary>
		/// Compute the contact manifold between a polygon and a circle<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2CollidePolygonAndCircle")]
		[return: NativeName(NativeNameType.Type, "b2Manifold")]
		internal static B2Manifold CollidePolygonAndCircleNative([NativeName(NativeNameType.Param, "polygonA")] [NativeName(NativeNameType.Type, "const b2Polygon*")] B2Polygon* polygonA, [NativeName(NativeNameType.Param, "xfA")] [NativeName(NativeNameType.Type, "b2Transform")] B2Transform xfA, [NativeName(NativeNameType.Param, "circleB")] [NativeName(NativeNameType.Type, "const b2Circle*")] B2Circle* circleB, [NativeName(NativeNameType.Param, "xfB")] [NativeName(NativeNameType.Type, "b2Transform")] B2Transform xfB)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<B2Polygon*, B2Transform, B2Circle*, B2Transform, B2Manifold>)vt[56])(polygonA, xfA, circleB, xfB);
			#else
			return (B2Manifold)((delegate* unmanaged[Cdecl]<nint, B2Transform, nint, B2Transform, B2Manifold>)vt[56])((nint)polygonA, xfA, (nint)circleB, xfB);
			#endif
		}

		/// <summary>
		/// Compute the contact manifold between a polygon and a circle<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2CollidePolygonAndCircle")]
		[return: NativeName(NativeNameType.Type, "b2Manifold")]
		public static B2Manifold CollidePolygonAndCircle([NativeName(NativeNameType.Param, "polygonA")] [NativeName(NativeNameType.Type, "const b2Polygon*")] B2Polygon* polygonA, [NativeName(NativeNameType.Param, "xfA")] [NativeName(NativeNameType.Type, "b2Transform")] B2Transform xfA, [NativeName(NativeNameType.Param, "circleB")] [NativeName(NativeNameType.Type, "const b2Circle*")] B2Circle* circleB, [NativeName(NativeNameType.Param, "xfB")] [NativeName(NativeNameType.Type, "b2Transform")] B2Transform xfB)
		{
			B2Manifold ret = CollidePolygonAndCircleNative(polygonA, xfA, circleB, xfB);
			return ret;
		}

		/// <summary>
		/// Compute the contact manifold between a polygon and a circle<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2CollidePolygonAndCircle")]
		[return: NativeName(NativeNameType.Type, "b2Manifold")]
		public static B2Manifold CollidePolygonAndCircle([NativeName(NativeNameType.Param, "polygonA")] [NativeName(NativeNameType.Type, "const b2Polygon*")] ref B2Polygon polygonA, [NativeName(NativeNameType.Param, "xfA")] [NativeName(NativeNameType.Type, "b2Transform")] B2Transform xfA, [NativeName(NativeNameType.Param, "circleB")] [NativeName(NativeNameType.Type, "const b2Circle*")] B2Circle* circleB, [NativeName(NativeNameType.Param, "xfB")] [NativeName(NativeNameType.Type, "b2Transform")] B2Transform xfB)
		{
			fixed (B2Polygon* ppolygonA = &polygonA)
			{
				B2Manifold ret = CollidePolygonAndCircleNative((B2Polygon*)ppolygonA, xfA, circleB, xfB);
				return ret;
			}
		}

		/// <summary>
		/// Compute the contact manifold between a polygon and a circle<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2CollidePolygonAndCircle")]
		[return: NativeName(NativeNameType.Type, "b2Manifold")]
		public static B2Manifold CollidePolygonAndCircle([NativeName(NativeNameType.Param, "polygonA")] [NativeName(NativeNameType.Type, "const b2Polygon*")] B2Polygon* polygonA, [NativeName(NativeNameType.Param, "xfA")] [NativeName(NativeNameType.Type, "b2Transform")] B2Transform xfA, [NativeName(NativeNameType.Param, "circleB")] [NativeName(NativeNameType.Type, "const b2Circle*")] ref B2Circle circleB, [NativeName(NativeNameType.Param, "xfB")] [NativeName(NativeNameType.Type, "b2Transform")] B2Transform xfB)
		{
			fixed (B2Circle* pcircleB = &circleB)
			{
				B2Manifold ret = CollidePolygonAndCircleNative(polygonA, xfA, (B2Circle*)pcircleB, xfB);
				return ret;
			}
		}

		/// <summary>
		/// Compute the contact manifold between a polygon and a circle<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2CollidePolygonAndCircle")]
		[return: NativeName(NativeNameType.Type, "b2Manifold")]
		public static B2Manifold CollidePolygonAndCircle([NativeName(NativeNameType.Param, "polygonA")] [NativeName(NativeNameType.Type, "const b2Polygon*")] ref B2Polygon polygonA, [NativeName(NativeNameType.Param, "xfA")] [NativeName(NativeNameType.Type, "b2Transform")] B2Transform xfA, [NativeName(NativeNameType.Param, "circleB")] [NativeName(NativeNameType.Type, "const b2Circle*")] ref B2Circle circleB, [NativeName(NativeNameType.Param, "xfB")] [NativeName(NativeNameType.Type, "b2Transform")] B2Transform xfB)
		{
			fixed (B2Polygon* ppolygonA = &polygonA)
			{
				fixed (B2Circle* pcircleB = &circleB)
				{
					B2Manifold ret = CollidePolygonAndCircleNative((B2Polygon*)ppolygonA, xfA, (B2Circle*)pcircleB, xfB);
					return ret;
				}
			}
		}

		/// <summary>
		/// Compute the contact manifold between a capsule and circle<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2CollideCapsules")]
		[return: NativeName(NativeNameType.Type, "b2Manifold")]
		internal static B2Manifold CollideCapsulesNative([NativeName(NativeNameType.Param, "capsuleA")] [NativeName(NativeNameType.Type, "const b2Capsule*")] B2Capsule* capsuleA, [NativeName(NativeNameType.Param, "xfA")] [NativeName(NativeNameType.Type, "b2Transform")] B2Transform xfA, [NativeName(NativeNameType.Param, "capsuleB")] [NativeName(NativeNameType.Type, "const b2Capsule*")] B2Capsule* capsuleB, [NativeName(NativeNameType.Param, "xfB")] [NativeName(NativeNameType.Type, "b2Transform")] B2Transform xfB)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<B2Capsule*, B2Transform, B2Capsule*, B2Transform, B2Manifold>)vt[57])(capsuleA, xfA, capsuleB, xfB);
			#else
			return (B2Manifold)((delegate* unmanaged[Cdecl]<nint, B2Transform, nint, B2Transform, B2Manifold>)vt[57])((nint)capsuleA, xfA, (nint)capsuleB, xfB);
			#endif
		}

		/// <summary>
		/// Compute the contact manifold between a capsule and circle<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2CollideCapsules")]
		[return: NativeName(NativeNameType.Type, "b2Manifold")]
		public static B2Manifold CollideCapsules([NativeName(NativeNameType.Param, "capsuleA")] [NativeName(NativeNameType.Type, "const b2Capsule*")] B2Capsule* capsuleA, [NativeName(NativeNameType.Param, "xfA")] [NativeName(NativeNameType.Type, "b2Transform")] B2Transform xfA, [NativeName(NativeNameType.Param, "capsuleB")] [NativeName(NativeNameType.Type, "const b2Capsule*")] B2Capsule* capsuleB, [NativeName(NativeNameType.Param, "xfB")] [NativeName(NativeNameType.Type, "b2Transform")] B2Transform xfB)
		{
			B2Manifold ret = CollideCapsulesNative(capsuleA, xfA, capsuleB, xfB);
			return ret;
		}

		/// <summary>
		/// Compute the contact manifold between a capsule and circle<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2CollideCapsules")]
		[return: NativeName(NativeNameType.Type, "b2Manifold")]
		public static B2Manifold CollideCapsules([NativeName(NativeNameType.Param, "capsuleA")] [NativeName(NativeNameType.Type, "const b2Capsule*")] ref B2Capsule capsuleA, [NativeName(NativeNameType.Param, "xfA")] [NativeName(NativeNameType.Type, "b2Transform")] B2Transform xfA, [NativeName(NativeNameType.Param, "capsuleB")] [NativeName(NativeNameType.Type, "const b2Capsule*")] B2Capsule* capsuleB, [NativeName(NativeNameType.Param, "xfB")] [NativeName(NativeNameType.Type, "b2Transform")] B2Transform xfB)
		{
			fixed (B2Capsule* pcapsuleA = &capsuleA)
			{
				B2Manifold ret = CollideCapsulesNative((B2Capsule*)pcapsuleA, xfA, capsuleB, xfB);
				return ret;
			}
		}

		/// <summary>
		/// Compute the contact manifold between a capsule and circle<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2CollideCapsules")]
		[return: NativeName(NativeNameType.Type, "b2Manifold")]
		public static B2Manifold CollideCapsules([NativeName(NativeNameType.Param, "capsuleA")] [NativeName(NativeNameType.Type, "const b2Capsule*")] B2Capsule* capsuleA, [NativeName(NativeNameType.Param, "xfA")] [NativeName(NativeNameType.Type, "b2Transform")] B2Transform xfA, [NativeName(NativeNameType.Param, "capsuleB")] [NativeName(NativeNameType.Type, "const b2Capsule*")] ref B2Capsule capsuleB, [NativeName(NativeNameType.Param, "xfB")] [NativeName(NativeNameType.Type, "b2Transform")] B2Transform xfB)
		{
			fixed (B2Capsule* pcapsuleB = &capsuleB)
			{
				B2Manifold ret = CollideCapsulesNative(capsuleA, xfA, (B2Capsule*)pcapsuleB, xfB);
				return ret;
			}
		}

		/// <summary>
		/// Compute the contact manifold between a capsule and circle<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2CollideCapsules")]
		[return: NativeName(NativeNameType.Type, "b2Manifold")]
		public static B2Manifold CollideCapsules([NativeName(NativeNameType.Param, "capsuleA")] [NativeName(NativeNameType.Type, "const b2Capsule*")] ref B2Capsule capsuleA, [NativeName(NativeNameType.Param, "xfA")] [NativeName(NativeNameType.Type, "b2Transform")] B2Transform xfA, [NativeName(NativeNameType.Param, "capsuleB")] [NativeName(NativeNameType.Type, "const b2Capsule*")] ref B2Capsule capsuleB, [NativeName(NativeNameType.Param, "xfB")] [NativeName(NativeNameType.Type, "b2Transform")] B2Transform xfB)
		{
			fixed (B2Capsule* pcapsuleA = &capsuleA)
			{
				fixed (B2Capsule* pcapsuleB = &capsuleB)
				{
					B2Manifold ret = CollideCapsulesNative((B2Capsule*)pcapsuleA, xfA, (B2Capsule*)pcapsuleB, xfB);
					return ret;
				}
			}
		}

		/// <summary>
		/// Compute the contact manifold between an segment and a capsule<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2CollideSegmentAndCapsule")]
		[return: NativeName(NativeNameType.Type, "b2Manifold")]
		internal static B2Manifold CollideSegmentAndCapsuleNative([NativeName(NativeNameType.Param, "segmentA")] [NativeName(NativeNameType.Type, "const b2Segment*")] B2Segment* segmentA, [NativeName(NativeNameType.Param, "xfA")] [NativeName(NativeNameType.Type, "b2Transform")] B2Transform xfA, [NativeName(NativeNameType.Param, "capsuleB")] [NativeName(NativeNameType.Type, "const b2Capsule*")] B2Capsule* capsuleB, [NativeName(NativeNameType.Param, "xfB")] [NativeName(NativeNameType.Type, "b2Transform")] B2Transform xfB)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<B2Segment*, B2Transform, B2Capsule*, B2Transform, B2Manifold>)vt[58])(segmentA, xfA, capsuleB, xfB);
			#else
			return (B2Manifold)((delegate* unmanaged[Cdecl]<nint, B2Transform, nint, B2Transform, B2Manifold>)vt[58])((nint)segmentA, xfA, (nint)capsuleB, xfB);
			#endif
		}

		/// <summary>
		/// Compute the contact manifold between an segment and a capsule<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2CollideSegmentAndCapsule")]
		[return: NativeName(NativeNameType.Type, "b2Manifold")]
		public static B2Manifold CollideSegmentAndCapsule([NativeName(NativeNameType.Param, "segmentA")] [NativeName(NativeNameType.Type, "const b2Segment*")] B2Segment* segmentA, [NativeName(NativeNameType.Param, "xfA")] [NativeName(NativeNameType.Type, "b2Transform")] B2Transform xfA, [NativeName(NativeNameType.Param, "capsuleB")] [NativeName(NativeNameType.Type, "const b2Capsule*")] B2Capsule* capsuleB, [NativeName(NativeNameType.Param, "xfB")] [NativeName(NativeNameType.Type, "b2Transform")] B2Transform xfB)
		{
			B2Manifold ret = CollideSegmentAndCapsuleNative(segmentA, xfA, capsuleB, xfB);
			return ret;
		}

		/// <summary>
		/// Compute the contact manifold between an segment and a capsule<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2CollideSegmentAndCapsule")]
		[return: NativeName(NativeNameType.Type, "b2Manifold")]
		public static B2Manifold CollideSegmentAndCapsule([NativeName(NativeNameType.Param, "segmentA")] [NativeName(NativeNameType.Type, "const b2Segment*")] ref B2Segment segmentA, [NativeName(NativeNameType.Param, "xfA")] [NativeName(NativeNameType.Type, "b2Transform")] B2Transform xfA, [NativeName(NativeNameType.Param, "capsuleB")] [NativeName(NativeNameType.Type, "const b2Capsule*")] B2Capsule* capsuleB, [NativeName(NativeNameType.Param, "xfB")] [NativeName(NativeNameType.Type, "b2Transform")] B2Transform xfB)
		{
			fixed (B2Segment* psegmentA = &segmentA)
			{
				B2Manifold ret = CollideSegmentAndCapsuleNative((B2Segment*)psegmentA, xfA, capsuleB, xfB);
				return ret;
			}
		}

		/// <summary>
		/// Compute the contact manifold between an segment and a capsule<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2CollideSegmentAndCapsule")]
		[return: NativeName(NativeNameType.Type, "b2Manifold")]
		public static B2Manifold CollideSegmentAndCapsule([NativeName(NativeNameType.Param, "segmentA")] [NativeName(NativeNameType.Type, "const b2Segment*")] B2Segment* segmentA, [NativeName(NativeNameType.Param, "xfA")] [NativeName(NativeNameType.Type, "b2Transform")] B2Transform xfA, [NativeName(NativeNameType.Param, "capsuleB")] [NativeName(NativeNameType.Type, "const b2Capsule*")] ref B2Capsule capsuleB, [NativeName(NativeNameType.Param, "xfB")] [NativeName(NativeNameType.Type, "b2Transform")] B2Transform xfB)
		{
			fixed (B2Capsule* pcapsuleB = &capsuleB)
			{
				B2Manifold ret = CollideSegmentAndCapsuleNative(segmentA, xfA, (B2Capsule*)pcapsuleB, xfB);
				return ret;
			}
		}

		/// <summary>
		/// Compute the contact manifold between an segment and a capsule<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2CollideSegmentAndCapsule")]
		[return: NativeName(NativeNameType.Type, "b2Manifold")]
		public static B2Manifold CollideSegmentAndCapsule([NativeName(NativeNameType.Param, "segmentA")] [NativeName(NativeNameType.Type, "const b2Segment*")] ref B2Segment segmentA, [NativeName(NativeNameType.Param, "xfA")] [NativeName(NativeNameType.Type, "b2Transform")] B2Transform xfA, [NativeName(NativeNameType.Param, "capsuleB")] [NativeName(NativeNameType.Type, "const b2Capsule*")] ref B2Capsule capsuleB, [NativeName(NativeNameType.Param, "xfB")] [NativeName(NativeNameType.Type, "b2Transform")] B2Transform xfB)
		{
			fixed (B2Segment* psegmentA = &segmentA)
			{
				fixed (B2Capsule* pcapsuleB = &capsuleB)
				{
					B2Manifold ret = CollideSegmentAndCapsuleNative((B2Segment*)psegmentA, xfA, (B2Capsule*)pcapsuleB, xfB);
					return ret;
				}
			}
		}

		/// <summary>
		/// Compute the contact manifold between a polygon and capsule<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2CollidePolygonAndCapsule")]
		[return: NativeName(NativeNameType.Type, "b2Manifold")]
		internal static B2Manifold CollidePolygonAndCapsuleNative([NativeName(NativeNameType.Param, "polygonA")] [NativeName(NativeNameType.Type, "const b2Polygon*")] B2Polygon* polygonA, [NativeName(NativeNameType.Param, "xfA")] [NativeName(NativeNameType.Type, "b2Transform")] B2Transform xfA, [NativeName(NativeNameType.Param, "capsuleB")] [NativeName(NativeNameType.Type, "const b2Capsule*")] B2Capsule* capsuleB, [NativeName(NativeNameType.Param, "xfB")] [NativeName(NativeNameType.Type, "b2Transform")] B2Transform xfB)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<B2Polygon*, B2Transform, B2Capsule*, B2Transform, B2Manifold>)vt[59])(polygonA, xfA, capsuleB, xfB);
			#else
			return (B2Manifold)((delegate* unmanaged[Cdecl]<nint, B2Transform, nint, B2Transform, B2Manifold>)vt[59])((nint)polygonA, xfA, (nint)capsuleB, xfB);
			#endif
		}

		/// <summary>
		/// Compute the contact manifold between a polygon and capsule<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2CollidePolygonAndCapsule")]
		[return: NativeName(NativeNameType.Type, "b2Manifold")]
		public static B2Manifold CollidePolygonAndCapsule([NativeName(NativeNameType.Param, "polygonA")] [NativeName(NativeNameType.Type, "const b2Polygon*")] B2Polygon* polygonA, [NativeName(NativeNameType.Param, "xfA")] [NativeName(NativeNameType.Type, "b2Transform")] B2Transform xfA, [NativeName(NativeNameType.Param, "capsuleB")] [NativeName(NativeNameType.Type, "const b2Capsule*")] B2Capsule* capsuleB, [NativeName(NativeNameType.Param, "xfB")] [NativeName(NativeNameType.Type, "b2Transform")] B2Transform xfB)
		{
			B2Manifold ret = CollidePolygonAndCapsuleNative(polygonA, xfA, capsuleB, xfB);
			return ret;
		}

		/// <summary>
		/// Compute the contact manifold between a polygon and capsule<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2CollidePolygonAndCapsule")]
		[return: NativeName(NativeNameType.Type, "b2Manifold")]
		public static B2Manifold CollidePolygonAndCapsule([NativeName(NativeNameType.Param, "polygonA")] [NativeName(NativeNameType.Type, "const b2Polygon*")] ref B2Polygon polygonA, [NativeName(NativeNameType.Param, "xfA")] [NativeName(NativeNameType.Type, "b2Transform")] B2Transform xfA, [NativeName(NativeNameType.Param, "capsuleB")] [NativeName(NativeNameType.Type, "const b2Capsule*")] B2Capsule* capsuleB, [NativeName(NativeNameType.Param, "xfB")] [NativeName(NativeNameType.Type, "b2Transform")] B2Transform xfB)
		{
			fixed (B2Polygon* ppolygonA = &polygonA)
			{
				B2Manifold ret = CollidePolygonAndCapsuleNative((B2Polygon*)ppolygonA, xfA, capsuleB, xfB);
				return ret;
			}
		}

		/// <summary>
		/// Compute the contact manifold between a polygon and capsule<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2CollidePolygonAndCapsule")]
		[return: NativeName(NativeNameType.Type, "b2Manifold")]
		public static B2Manifold CollidePolygonAndCapsule([NativeName(NativeNameType.Param, "polygonA")] [NativeName(NativeNameType.Type, "const b2Polygon*")] B2Polygon* polygonA, [NativeName(NativeNameType.Param, "xfA")] [NativeName(NativeNameType.Type, "b2Transform")] B2Transform xfA, [NativeName(NativeNameType.Param, "capsuleB")] [NativeName(NativeNameType.Type, "const b2Capsule*")] ref B2Capsule capsuleB, [NativeName(NativeNameType.Param, "xfB")] [NativeName(NativeNameType.Type, "b2Transform")] B2Transform xfB)
		{
			fixed (B2Capsule* pcapsuleB = &capsuleB)
			{
				B2Manifold ret = CollidePolygonAndCapsuleNative(polygonA, xfA, (B2Capsule*)pcapsuleB, xfB);
				return ret;
			}
		}

		/// <summary>
		/// Compute the contact manifold between a polygon and capsule<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2CollidePolygonAndCapsule")]
		[return: NativeName(NativeNameType.Type, "b2Manifold")]
		public static B2Manifold CollidePolygonAndCapsule([NativeName(NativeNameType.Param, "polygonA")] [NativeName(NativeNameType.Type, "const b2Polygon*")] ref B2Polygon polygonA, [NativeName(NativeNameType.Param, "xfA")] [NativeName(NativeNameType.Type, "b2Transform")] B2Transform xfA, [NativeName(NativeNameType.Param, "capsuleB")] [NativeName(NativeNameType.Type, "const b2Capsule*")] ref B2Capsule capsuleB, [NativeName(NativeNameType.Param, "xfB")] [NativeName(NativeNameType.Type, "b2Transform")] B2Transform xfB)
		{
			fixed (B2Polygon* ppolygonA = &polygonA)
			{
				fixed (B2Capsule* pcapsuleB = &capsuleB)
				{
					B2Manifold ret = CollidePolygonAndCapsuleNative((B2Polygon*)ppolygonA, xfA, (B2Capsule*)pcapsuleB, xfB);
					return ret;
				}
			}
		}

		/// <summary>
		/// Compute the contact manifold between two polygons<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2CollidePolygons")]
		[return: NativeName(NativeNameType.Type, "b2Manifold")]
		internal static B2Manifold CollidePolygonsNative([NativeName(NativeNameType.Param, "polygonA")] [NativeName(NativeNameType.Type, "const b2Polygon*")] B2Polygon* polygonA, [NativeName(NativeNameType.Param, "xfA")] [NativeName(NativeNameType.Type, "b2Transform")] B2Transform xfA, [NativeName(NativeNameType.Param, "polygonB")] [NativeName(NativeNameType.Type, "const b2Polygon*")] B2Polygon* polygonB, [NativeName(NativeNameType.Param, "xfB")] [NativeName(NativeNameType.Type, "b2Transform")] B2Transform xfB)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<B2Polygon*, B2Transform, B2Polygon*, B2Transform, B2Manifold>)vt[60])(polygonA, xfA, polygonB, xfB);
			#else
			return (B2Manifold)((delegate* unmanaged[Cdecl]<nint, B2Transform, nint, B2Transform, B2Manifold>)vt[60])((nint)polygonA, xfA, (nint)polygonB, xfB);
			#endif
		}

		/// <summary>
		/// Compute the contact manifold between two polygons<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2CollidePolygons")]
		[return: NativeName(NativeNameType.Type, "b2Manifold")]
		public static B2Manifold CollidePolygons([NativeName(NativeNameType.Param, "polygonA")] [NativeName(NativeNameType.Type, "const b2Polygon*")] B2Polygon* polygonA, [NativeName(NativeNameType.Param, "xfA")] [NativeName(NativeNameType.Type, "b2Transform")] B2Transform xfA, [NativeName(NativeNameType.Param, "polygonB")] [NativeName(NativeNameType.Type, "const b2Polygon*")] B2Polygon* polygonB, [NativeName(NativeNameType.Param, "xfB")] [NativeName(NativeNameType.Type, "b2Transform")] B2Transform xfB)
		{
			B2Manifold ret = CollidePolygonsNative(polygonA, xfA, polygonB, xfB);
			return ret;
		}

		/// <summary>
		/// Compute the contact manifold between two polygons<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2CollidePolygons")]
		[return: NativeName(NativeNameType.Type, "b2Manifold")]
		public static B2Manifold CollidePolygons([NativeName(NativeNameType.Param, "polygonA")] [NativeName(NativeNameType.Type, "const b2Polygon*")] ref B2Polygon polygonA, [NativeName(NativeNameType.Param, "xfA")] [NativeName(NativeNameType.Type, "b2Transform")] B2Transform xfA, [NativeName(NativeNameType.Param, "polygonB")] [NativeName(NativeNameType.Type, "const b2Polygon*")] B2Polygon* polygonB, [NativeName(NativeNameType.Param, "xfB")] [NativeName(NativeNameType.Type, "b2Transform")] B2Transform xfB)
		{
			fixed (B2Polygon* ppolygonA = &polygonA)
			{
				B2Manifold ret = CollidePolygonsNative((B2Polygon*)ppolygonA, xfA, polygonB, xfB);
				return ret;
			}
		}

		/// <summary>
		/// Compute the contact manifold between two polygons<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2CollidePolygons")]
		[return: NativeName(NativeNameType.Type, "b2Manifold")]
		public static B2Manifold CollidePolygons([NativeName(NativeNameType.Param, "polygonA")] [NativeName(NativeNameType.Type, "const b2Polygon*")] B2Polygon* polygonA, [NativeName(NativeNameType.Param, "xfA")] [NativeName(NativeNameType.Type, "b2Transform")] B2Transform xfA, [NativeName(NativeNameType.Param, "polygonB")] [NativeName(NativeNameType.Type, "const b2Polygon*")] ref B2Polygon polygonB, [NativeName(NativeNameType.Param, "xfB")] [NativeName(NativeNameType.Type, "b2Transform")] B2Transform xfB)
		{
			fixed (B2Polygon* ppolygonB = &polygonB)
			{
				B2Manifold ret = CollidePolygonsNative(polygonA, xfA, (B2Polygon*)ppolygonB, xfB);
				return ret;
			}
		}

		/// <summary>
		/// Compute the contact manifold between two polygons<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2CollidePolygons")]
		[return: NativeName(NativeNameType.Type, "b2Manifold")]
		public static B2Manifold CollidePolygons([NativeName(NativeNameType.Param, "polygonA")] [NativeName(NativeNameType.Type, "const b2Polygon*")] ref B2Polygon polygonA, [NativeName(NativeNameType.Param, "xfA")] [NativeName(NativeNameType.Type, "b2Transform")] B2Transform xfA, [NativeName(NativeNameType.Param, "polygonB")] [NativeName(NativeNameType.Type, "const b2Polygon*")] ref B2Polygon polygonB, [NativeName(NativeNameType.Param, "xfB")] [NativeName(NativeNameType.Type, "b2Transform")] B2Transform xfB)
		{
			fixed (B2Polygon* ppolygonA = &polygonA)
			{
				fixed (B2Polygon* ppolygonB = &polygonB)
				{
					B2Manifold ret = CollidePolygonsNative((B2Polygon*)ppolygonA, xfA, (B2Polygon*)ppolygonB, xfB);
					return ret;
				}
			}
		}

		/// <summary>
		/// Compute the contact manifold between an segment and a polygon<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2CollideSegmentAndPolygon")]
		[return: NativeName(NativeNameType.Type, "b2Manifold")]
		internal static B2Manifold CollideSegmentAndPolygonNative([NativeName(NativeNameType.Param, "segmentA")] [NativeName(NativeNameType.Type, "const b2Segment*")] B2Segment* segmentA, [NativeName(NativeNameType.Param, "xfA")] [NativeName(NativeNameType.Type, "b2Transform")] B2Transform xfA, [NativeName(NativeNameType.Param, "polygonB")] [NativeName(NativeNameType.Type, "const b2Polygon*")] B2Polygon* polygonB, [NativeName(NativeNameType.Param, "xfB")] [NativeName(NativeNameType.Type, "b2Transform")] B2Transform xfB)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<B2Segment*, B2Transform, B2Polygon*, B2Transform, B2Manifold>)vt[61])(segmentA, xfA, polygonB, xfB);
			#else
			return (B2Manifold)((delegate* unmanaged[Cdecl]<nint, B2Transform, nint, B2Transform, B2Manifold>)vt[61])((nint)segmentA, xfA, (nint)polygonB, xfB);
			#endif
		}

		/// <summary>
		/// Compute the contact manifold between an segment and a polygon<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2CollideSegmentAndPolygon")]
		[return: NativeName(NativeNameType.Type, "b2Manifold")]
		public static B2Manifold CollideSegmentAndPolygon([NativeName(NativeNameType.Param, "segmentA")] [NativeName(NativeNameType.Type, "const b2Segment*")] B2Segment* segmentA, [NativeName(NativeNameType.Param, "xfA")] [NativeName(NativeNameType.Type, "b2Transform")] B2Transform xfA, [NativeName(NativeNameType.Param, "polygonB")] [NativeName(NativeNameType.Type, "const b2Polygon*")] B2Polygon* polygonB, [NativeName(NativeNameType.Param, "xfB")] [NativeName(NativeNameType.Type, "b2Transform")] B2Transform xfB)
		{
			B2Manifold ret = CollideSegmentAndPolygonNative(segmentA, xfA, polygonB, xfB);
			return ret;
		}

		/// <summary>
		/// Compute the contact manifold between an segment and a polygon<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2CollideSegmentAndPolygon")]
		[return: NativeName(NativeNameType.Type, "b2Manifold")]
		public static B2Manifold CollideSegmentAndPolygon([NativeName(NativeNameType.Param, "segmentA")] [NativeName(NativeNameType.Type, "const b2Segment*")] ref B2Segment segmentA, [NativeName(NativeNameType.Param, "xfA")] [NativeName(NativeNameType.Type, "b2Transform")] B2Transform xfA, [NativeName(NativeNameType.Param, "polygonB")] [NativeName(NativeNameType.Type, "const b2Polygon*")] B2Polygon* polygonB, [NativeName(NativeNameType.Param, "xfB")] [NativeName(NativeNameType.Type, "b2Transform")] B2Transform xfB)
		{
			fixed (B2Segment* psegmentA = &segmentA)
			{
				B2Manifold ret = CollideSegmentAndPolygonNative((B2Segment*)psegmentA, xfA, polygonB, xfB);
				return ret;
			}
		}

		/// <summary>
		/// Compute the contact manifold between an segment and a polygon<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2CollideSegmentAndPolygon")]
		[return: NativeName(NativeNameType.Type, "b2Manifold")]
		public static B2Manifold CollideSegmentAndPolygon([NativeName(NativeNameType.Param, "segmentA")] [NativeName(NativeNameType.Type, "const b2Segment*")] B2Segment* segmentA, [NativeName(NativeNameType.Param, "xfA")] [NativeName(NativeNameType.Type, "b2Transform")] B2Transform xfA, [NativeName(NativeNameType.Param, "polygonB")] [NativeName(NativeNameType.Type, "const b2Polygon*")] ref B2Polygon polygonB, [NativeName(NativeNameType.Param, "xfB")] [NativeName(NativeNameType.Type, "b2Transform")] B2Transform xfB)
		{
			fixed (B2Polygon* ppolygonB = &polygonB)
			{
				B2Manifold ret = CollideSegmentAndPolygonNative(segmentA, xfA, (B2Polygon*)ppolygonB, xfB);
				return ret;
			}
		}

		/// <summary>
		/// Compute the contact manifold between an segment and a polygon<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2CollideSegmentAndPolygon")]
		[return: NativeName(NativeNameType.Type, "b2Manifold")]
		public static B2Manifold CollideSegmentAndPolygon([NativeName(NativeNameType.Param, "segmentA")] [NativeName(NativeNameType.Type, "const b2Segment*")] ref B2Segment segmentA, [NativeName(NativeNameType.Param, "xfA")] [NativeName(NativeNameType.Type, "b2Transform")] B2Transform xfA, [NativeName(NativeNameType.Param, "polygonB")] [NativeName(NativeNameType.Type, "const b2Polygon*")] ref B2Polygon polygonB, [NativeName(NativeNameType.Param, "xfB")] [NativeName(NativeNameType.Type, "b2Transform")] B2Transform xfB)
		{
			fixed (B2Segment* psegmentA = &segmentA)
			{
				fixed (B2Polygon* ppolygonB = &polygonB)
				{
					B2Manifold ret = CollideSegmentAndPolygonNative((B2Segment*)psegmentA, xfA, (B2Polygon*)ppolygonB, xfB);
					return ret;
				}
			}
		}

		/// <summary>
		/// Compute the contact manifold between a smooth segment and a circle<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2CollideSmoothSegmentAndCircle")]
		[return: NativeName(NativeNameType.Type, "b2Manifold")]
		internal static B2Manifold CollideSmoothSegmentAndCircleNative([NativeName(NativeNameType.Param, "smoothSegmentA")] [NativeName(NativeNameType.Type, "const b2SmoothSegment*")] B2SmoothSegment* smoothSegmentA, [NativeName(NativeNameType.Param, "xfA")] [NativeName(NativeNameType.Type, "b2Transform")] B2Transform xfA, [NativeName(NativeNameType.Param, "circleB")] [NativeName(NativeNameType.Type, "const b2Circle*")] B2Circle* circleB, [NativeName(NativeNameType.Param, "xfB")] [NativeName(NativeNameType.Type, "b2Transform")] B2Transform xfB)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<B2SmoothSegment*, B2Transform, B2Circle*, B2Transform, B2Manifold>)vt[62])(smoothSegmentA, xfA, circleB, xfB);
			#else
			return (B2Manifold)((delegate* unmanaged[Cdecl]<nint, B2Transform, nint, B2Transform, B2Manifold>)vt[62])((nint)smoothSegmentA, xfA, (nint)circleB, xfB);
			#endif
		}

		/// <summary>
		/// Compute the contact manifold between a smooth segment and a circle<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2CollideSmoothSegmentAndCircle")]
		[return: NativeName(NativeNameType.Type, "b2Manifold")]
		public static B2Manifold CollideSmoothSegmentAndCircle([NativeName(NativeNameType.Param, "smoothSegmentA")] [NativeName(NativeNameType.Type, "const b2SmoothSegment*")] B2SmoothSegment* smoothSegmentA, [NativeName(NativeNameType.Param, "xfA")] [NativeName(NativeNameType.Type, "b2Transform")] B2Transform xfA, [NativeName(NativeNameType.Param, "circleB")] [NativeName(NativeNameType.Type, "const b2Circle*")] B2Circle* circleB, [NativeName(NativeNameType.Param, "xfB")] [NativeName(NativeNameType.Type, "b2Transform")] B2Transform xfB)
		{
			B2Manifold ret = CollideSmoothSegmentAndCircleNative(smoothSegmentA, xfA, circleB, xfB);
			return ret;
		}

		/// <summary>
		/// Compute the contact manifold between a smooth segment and a circle<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2CollideSmoothSegmentAndCircle")]
		[return: NativeName(NativeNameType.Type, "b2Manifold")]
		public static B2Manifold CollideSmoothSegmentAndCircle([NativeName(NativeNameType.Param, "smoothSegmentA")] [NativeName(NativeNameType.Type, "const b2SmoothSegment*")] ref B2SmoothSegment smoothSegmentA, [NativeName(NativeNameType.Param, "xfA")] [NativeName(NativeNameType.Type, "b2Transform")] B2Transform xfA, [NativeName(NativeNameType.Param, "circleB")] [NativeName(NativeNameType.Type, "const b2Circle*")] B2Circle* circleB, [NativeName(NativeNameType.Param, "xfB")] [NativeName(NativeNameType.Type, "b2Transform")] B2Transform xfB)
		{
			fixed (B2SmoothSegment* psmoothSegmentA = &smoothSegmentA)
			{
				B2Manifold ret = CollideSmoothSegmentAndCircleNative((B2SmoothSegment*)psmoothSegmentA, xfA, circleB, xfB);
				return ret;
			}
		}

		/// <summary>
		/// Compute the contact manifold between a smooth segment and a circle<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2CollideSmoothSegmentAndCircle")]
		[return: NativeName(NativeNameType.Type, "b2Manifold")]
		public static B2Manifold CollideSmoothSegmentAndCircle([NativeName(NativeNameType.Param, "smoothSegmentA")] [NativeName(NativeNameType.Type, "const b2SmoothSegment*")] B2SmoothSegment* smoothSegmentA, [NativeName(NativeNameType.Param, "xfA")] [NativeName(NativeNameType.Type, "b2Transform")] B2Transform xfA, [NativeName(NativeNameType.Param, "circleB")] [NativeName(NativeNameType.Type, "const b2Circle*")] ref B2Circle circleB, [NativeName(NativeNameType.Param, "xfB")] [NativeName(NativeNameType.Type, "b2Transform")] B2Transform xfB)
		{
			fixed (B2Circle* pcircleB = &circleB)
			{
				B2Manifold ret = CollideSmoothSegmentAndCircleNative(smoothSegmentA, xfA, (B2Circle*)pcircleB, xfB);
				return ret;
			}
		}

		/// <summary>
		/// Compute the contact manifold between a smooth segment and a circle<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2CollideSmoothSegmentAndCircle")]
		[return: NativeName(NativeNameType.Type, "b2Manifold")]
		public static B2Manifold CollideSmoothSegmentAndCircle([NativeName(NativeNameType.Param, "smoothSegmentA")] [NativeName(NativeNameType.Type, "const b2SmoothSegment*")] ref B2SmoothSegment smoothSegmentA, [NativeName(NativeNameType.Param, "xfA")] [NativeName(NativeNameType.Type, "b2Transform")] B2Transform xfA, [NativeName(NativeNameType.Param, "circleB")] [NativeName(NativeNameType.Type, "const b2Circle*")] ref B2Circle circleB, [NativeName(NativeNameType.Param, "xfB")] [NativeName(NativeNameType.Type, "b2Transform")] B2Transform xfB)
		{
			fixed (B2SmoothSegment* psmoothSegmentA = &smoothSegmentA)
			{
				fixed (B2Circle* pcircleB = &circleB)
				{
					B2Manifold ret = CollideSmoothSegmentAndCircleNative((B2SmoothSegment*)psmoothSegmentA, xfA, (B2Circle*)pcircleB, xfB);
					return ret;
				}
			}
		}

		/// <summary>
		/// Compute the contact manifold between an segment and a capsule<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2CollideSmoothSegmentAndCapsule")]
		[return: NativeName(NativeNameType.Type, "b2Manifold")]
		internal static B2Manifold CollideSmoothSegmentAndCapsuleNative([NativeName(NativeNameType.Param, "smoothSegmentA")] [NativeName(NativeNameType.Type, "const b2SmoothSegment*")] B2SmoothSegment* smoothSegmentA, [NativeName(NativeNameType.Param, "xfA")] [NativeName(NativeNameType.Type, "b2Transform")] B2Transform xfA, [NativeName(NativeNameType.Param, "capsuleB")] [NativeName(NativeNameType.Type, "const b2Capsule*")] B2Capsule* capsuleB, [NativeName(NativeNameType.Param, "xfB")] [NativeName(NativeNameType.Type, "b2Transform")] B2Transform xfB, [NativeName(NativeNameType.Param, "cache")] [NativeName(NativeNameType.Type, "b2DistanceCache*")] B2DistanceCache* cache)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<B2SmoothSegment*, B2Transform, B2Capsule*, B2Transform, B2DistanceCache*, B2Manifold>)vt[63])(smoothSegmentA, xfA, capsuleB, xfB, cache);
			#else
			return (B2Manifold)((delegate* unmanaged[Cdecl]<nint, B2Transform, nint, B2Transform, nint, B2Manifold>)vt[63])((nint)smoothSegmentA, xfA, (nint)capsuleB, xfB, (nint)cache);
			#endif
		}

		/// <summary>
		/// Compute the contact manifold between an segment and a capsule<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2CollideSmoothSegmentAndCapsule")]
		[return: NativeName(NativeNameType.Type, "b2Manifold")]
		public static B2Manifold CollideSmoothSegmentAndCapsule([NativeName(NativeNameType.Param, "smoothSegmentA")] [NativeName(NativeNameType.Type, "const b2SmoothSegment*")] B2SmoothSegment* smoothSegmentA, [NativeName(NativeNameType.Param, "xfA")] [NativeName(NativeNameType.Type, "b2Transform")] B2Transform xfA, [NativeName(NativeNameType.Param, "capsuleB")] [NativeName(NativeNameType.Type, "const b2Capsule*")] B2Capsule* capsuleB, [NativeName(NativeNameType.Param, "xfB")] [NativeName(NativeNameType.Type, "b2Transform")] B2Transform xfB, [NativeName(NativeNameType.Param, "cache")] [NativeName(NativeNameType.Type, "b2DistanceCache*")] B2DistanceCache* cache)
		{
			B2Manifold ret = CollideSmoothSegmentAndCapsuleNative(smoothSegmentA, xfA, capsuleB, xfB, cache);
			return ret;
		}

		/// <summary>
		/// Compute the contact manifold between an segment and a capsule<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2CollideSmoothSegmentAndCapsule")]
		[return: NativeName(NativeNameType.Type, "b2Manifold")]
		public static B2Manifold CollideSmoothSegmentAndCapsule([NativeName(NativeNameType.Param, "smoothSegmentA")] [NativeName(NativeNameType.Type, "const b2SmoothSegment*")] ref B2SmoothSegment smoothSegmentA, [NativeName(NativeNameType.Param, "xfA")] [NativeName(NativeNameType.Type, "b2Transform")] B2Transform xfA, [NativeName(NativeNameType.Param, "capsuleB")] [NativeName(NativeNameType.Type, "const b2Capsule*")] B2Capsule* capsuleB, [NativeName(NativeNameType.Param, "xfB")] [NativeName(NativeNameType.Type, "b2Transform")] B2Transform xfB, [NativeName(NativeNameType.Param, "cache")] [NativeName(NativeNameType.Type, "b2DistanceCache*")] B2DistanceCache* cache)
		{
			fixed (B2SmoothSegment* psmoothSegmentA = &smoothSegmentA)
			{
				B2Manifold ret = CollideSmoothSegmentAndCapsuleNative((B2SmoothSegment*)psmoothSegmentA, xfA, capsuleB, xfB, cache);
				return ret;
			}
		}

		/// <summary>
		/// Compute the contact manifold between an segment and a capsule<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2CollideSmoothSegmentAndCapsule")]
		[return: NativeName(NativeNameType.Type, "b2Manifold")]
		public static B2Manifold CollideSmoothSegmentAndCapsule([NativeName(NativeNameType.Param, "smoothSegmentA")] [NativeName(NativeNameType.Type, "const b2SmoothSegment*")] B2SmoothSegment* smoothSegmentA, [NativeName(NativeNameType.Param, "xfA")] [NativeName(NativeNameType.Type, "b2Transform")] B2Transform xfA, [NativeName(NativeNameType.Param, "capsuleB")] [NativeName(NativeNameType.Type, "const b2Capsule*")] ref B2Capsule capsuleB, [NativeName(NativeNameType.Param, "xfB")] [NativeName(NativeNameType.Type, "b2Transform")] B2Transform xfB, [NativeName(NativeNameType.Param, "cache")] [NativeName(NativeNameType.Type, "b2DistanceCache*")] B2DistanceCache* cache)
		{
			fixed (B2Capsule* pcapsuleB = &capsuleB)
			{
				B2Manifold ret = CollideSmoothSegmentAndCapsuleNative(smoothSegmentA, xfA, (B2Capsule*)pcapsuleB, xfB, cache);
				return ret;
			}
		}

		/// <summary>
		/// Compute the contact manifold between an segment and a capsule<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2CollideSmoothSegmentAndCapsule")]
		[return: NativeName(NativeNameType.Type, "b2Manifold")]
		public static B2Manifold CollideSmoothSegmentAndCapsule([NativeName(NativeNameType.Param, "smoothSegmentA")] [NativeName(NativeNameType.Type, "const b2SmoothSegment*")] ref B2SmoothSegment smoothSegmentA, [NativeName(NativeNameType.Param, "xfA")] [NativeName(NativeNameType.Type, "b2Transform")] B2Transform xfA, [NativeName(NativeNameType.Param, "capsuleB")] [NativeName(NativeNameType.Type, "const b2Capsule*")] ref B2Capsule capsuleB, [NativeName(NativeNameType.Param, "xfB")] [NativeName(NativeNameType.Type, "b2Transform")] B2Transform xfB, [NativeName(NativeNameType.Param, "cache")] [NativeName(NativeNameType.Type, "b2DistanceCache*")] B2DistanceCache* cache)
		{
			fixed (B2SmoothSegment* psmoothSegmentA = &smoothSegmentA)
			{
				fixed (B2Capsule* pcapsuleB = &capsuleB)
				{
					B2Manifold ret = CollideSmoothSegmentAndCapsuleNative((B2SmoothSegment*)psmoothSegmentA, xfA, (B2Capsule*)pcapsuleB, xfB, cache);
					return ret;
				}
			}
		}

		/// <summary>
		/// Compute the contact manifold between an segment and a capsule<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2CollideSmoothSegmentAndCapsule")]
		[return: NativeName(NativeNameType.Type, "b2Manifold")]
		public static B2Manifold CollideSmoothSegmentAndCapsule([NativeName(NativeNameType.Param, "smoothSegmentA")] [NativeName(NativeNameType.Type, "const b2SmoothSegment*")] B2SmoothSegment* smoothSegmentA, [NativeName(NativeNameType.Param, "xfA")] [NativeName(NativeNameType.Type, "b2Transform")] B2Transform xfA, [NativeName(NativeNameType.Param, "capsuleB")] [NativeName(NativeNameType.Type, "const b2Capsule*")] B2Capsule* capsuleB, [NativeName(NativeNameType.Param, "xfB")] [NativeName(NativeNameType.Type, "b2Transform")] B2Transform xfB, [NativeName(NativeNameType.Param, "cache")] [NativeName(NativeNameType.Type, "b2DistanceCache*")] ref B2DistanceCache cache)
		{
			fixed (B2DistanceCache* pcache = &cache)
			{
				B2Manifold ret = CollideSmoothSegmentAndCapsuleNative(smoothSegmentA, xfA, capsuleB, xfB, (B2DistanceCache*)pcache);
				return ret;
			}
		}

		/// <summary>
		/// Compute the contact manifold between an segment and a capsule<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2CollideSmoothSegmentAndCapsule")]
		[return: NativeName(NativeNameType.Type, "b2Manifold")]
		public static B2Manifold CollideSmoothSegmentAndCapsule([NativeName(NativeNameType.Param, "smoothSegmentA")] [NativeName(NativeNameType.Type, "const b2SmoothSegment*")] ref B2SmoothSegment smoothSegmentA, [NativeName(NativeNameType.Param, "xfA")] [NativeName(NativeNameType.Type, "b2Transform")] B2Transform xfA, [NativeName(NativeNameType.Param, "capsuleB")] [NativeName(NativeNameType.Type, "const b2Capsule*")] B2Capsule* capsuleB, [NativeName(NativeNameType.Param, "xfB")] [NativeName(NativeNameType.Type, "b2Transform")] B2Transform xfB, [NativeName(NativeNameType.Param, "cache")] [NativeName(NativeNameType.Type, "b2DistanceCache*")] ref B2DistanceCache cache)
		{
			fixed (B2SmoothSegment* psmoothSegmentA = &smoothSegmentA)
			{
				fixed (B2DistanceCache* pcache = &cache)
				{
					B2Manifold ret = CollideSmoothSegmentAndCapsuleNative((B2SmoothSegment*)psmoothSegmentA, xfA, capsuleB, xfB, (B2DistanceCache*)pcache);
					return ret;
				}
			}
		}

		/// <summary>
		/// Compute the contact manifold between an segment and a capsule<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2CollideSmoothSegmentAndCapsule")]
		[return: NativeName(NativeNameType.Type, "b2Manifold")]
		public static B2Manifold CollideSmoothSegmentAndCapsule([NativeName(NativeNameType.Param, "smoothSegmentA")] [NativeName(NativeNameType.Type, "const b2SmoothSegment*")] B2SmoothSegment* smoothSegmentA, [NativeName(NativeNameType.Param, "xfA")] [NativeName(NativeNameType.Type, "b2Transform")] B2Transform xfA, [NativeName(NativeNameType.Param, "capsuleB")] [NativeName(NativeNameType.Type, "const b2Capsule*")] ref B2Capsule capsuleB, [NativeName(NativeNameType.Param, "xfB")] [NativeName(NativeNameType.Type, "b2Transform")] B2Transform xfB, [NativeName(NativeNameType.Param, "cache")] [NativeName(NativeNameType.Type, "b2DistanceCache*")] ref B2DistanceCache cache)
		{
			fixed (B2Capsule* pcapsuleB = &capsuleB)
			{
				fixed (B2DistanceCache* pcache = &cache)
				{
					B2Manifold ret = CollideSmoothSegmentAndCapsuleNative(smoothSegmentA, xfA, (B2Capsule*)pcapsuleB, xfB, (B2DistanceCache*)pcache);
					return ret;
				}
			}
		}

		/// <summary>
		/// Compute the contact manifold between an segment and a capsule<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2CollideSmoothSegmentAndCapsule")]
		[return: NativeName(NativeNameType.Type, "b2Manifold")]
		public static B2Manifold CollideSmoothSegmentAndCapsule([NativeName(NativeNameType.Param, "smoothSegmentA")] [NativeName(NativeNameType.Type, "const b2SmoothSegment*")] ref B2SmoothSegment smoothSegmentA, [NativeName(NativeNameType.Param, "xfA")] [NativeName(NativeNameType.Type, "b2Transform")] B2Transform xfA, [NativeName(NativeNameType.Param, "capsuleB")] [NativeName(NativeNameType.Type, "const b2Capsule*")] ref B2Capsule capsuleB, [NativeName(NativeNameType.Param, "xfB")] [NativeName(NativeNameType.Type, "b2Transform")] B2Transform xfB, [NativeName(NativeNameType.Param, "cache")] [NativeName(NativeNameType.Type, "b2DistanceCache*")] ref B2DistanceCache cache)
		{
			fixed (B2SmoothSegment* psmoothSegmentA = &smoothSegmentA)
			{
				fixed (B2Capsule* pcapsuleB = &capsuleB)
				{
					fixed (B2DistanceCache* pcache = &cache)
					{
						B2Manifold ret = CollideSmoothSegmentAndCapsuleNative((B2SmoothSegment*)psmoothSegmentA, xfA, (B2Capsule*)pcapsuleB, xfB, (B2DistanceCache*)pcache);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Compute the contact manifold between a smooth segment and a rounded polygon<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2CollideSmoothSegmentAndPolygon")]
		[return: NativeName(NativeNameType.Type, "b2Manifold")]
		internal static B2Manifold CollideSmoothSegmentAndPolygonNative([NativeName(NativeNameType.Param, "smoothSegmentA")] [NativeName(NativeNameType.Type, "const b2SmoothSegment*")] B2SmoothSegment* smoothSegmentA, [NativeName(NativeNameType.Param, "xfA")] [NativeName(NativeNameType.Type, "b2Transform")] B2Transform xfA, [NativeName(NativeNameType.Param, "polygonB")] [NativeName(NativeNameType.Type, "const b2Polygon*")] B2Polygon* polygonB, [NativeName(NativeNameType.Param, "xfB")] [NativeName(NativeNameType.Type, "b2Transform")] B2Transform xfB, [NativeName(NativeNameType.Param, "cache")] [NativeName(NativeNameType.Type, "b2DistanceCache*")] B2DistanceCache* cache)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<B2SmoothSegment*, B2Transform, B2Polygon*, B2Transform, B2DistanceCache*, B2Manifold>)vt[64])(smoothSegmentA, xfA, polygonB, xfB, cache);
			#else
			return (B2Manifold)((delegate* unmanaged[Cdecl]<nint, B2Transform, nint, B2Transform, nint, B2Manifold>)vt[64])((nint)smoothSegmentA, xfA, (nint)polygonB, xfB, (nint)cache);
			#endif
		}

		/// <summary>
		/// Compute the contact manifold between a smooth segment and a rounded polygon<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2CollideSmoothSegmentAndPolygon")]
		[return: NativeName(NativeNameType.Type, "b2Manifold")]
		public static B2Manifold CollideSmoothSegmentAndPolygon([NativeName(NativeNameType.Param, "smoothSegmentA")] [NativeName(NativeNameType.Type, "const b2SmoothSegment*")] B2SmoothSegment* smoothSegmentA, [NativeName(NativeNameType.Param, "xfA")] [NativeName(NativeNameType.Type, "b2Transform")] B2Transform xfA, [NativeName(NativeNameType.Param, "polygonB")] [NativeName(NativeNameType.Type, "const b2Polygon*")] B2Polygon* polygonB, [NativeName(NativeNameType.Param, "xfB")] [NativeName(NativeNameType.Type, "b2Transform")] B2Transform xfB, [NativeName(NativeNameType.Param, "cache")] [NativeName(NativeNameType.Type, "b2DistanceCache*")] B2DistanceCache* cache)
		{
			B2Manifold ret = CollideSmoothSegmentAndPolygonNative(smoothSegmentA, xfA, polygonB, xfB, cache);
			return ret;
		}

		/// <summary>
		/// Compute the contact manifold between a smooth segment and a rounded polygon<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2CollideSmoothSegmentAndPolygon")]
		[return: NativeName(NativeNameType.Type, "b2Manifold")]
		public static B2Manifold CollideSmoothSegmentAndPolygon([NativeName(NativeNameType.Param, "smoothSegmentA")] [NativeName(NativeNameType.Type, "const b2SmoothSegment*")] ref B2SmoothSegment smoothSegmentA, [NativeName(NativeNameType.Param, "xfA")] [NativeName(NativeNameType.Type, "b2Transform")] B2Transform xfA, [NativeName(NativeNameType.Param, "polygonB")] [NativeName(NativeNameType.Type, "const b2Polygon*")] B2Polygon* polygonB, [NativeName(NativeNameType.Param, "xfB")] [NativeName(NativeNameType.Type, "b2Transform")] B2Transform xfB, [NativeName(NativeNameType.Param, "cache")] [NativeName(NativeNameType.Type, "b2DistanceCache*")] B2DistanceCache* cache)
		{
			fixed (B2SmoothSegment* psmoothSegmentA = &smoothSegmentA)
			{
				B2Manifold ret = CollideSmoothSegmentAndPolygonNative((B2SmoothSegment*)psmoothSegmentA, xfA, polygonB, xfB, cache);
				return ret;
			}
		}

		/// <summary>
		/// Compute the contact manifold between a smooth segment and a rounded polygon<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2CollideSmoothSegmentAndPolygon")]
		[return: NativeName(NativeNameType.Type, "b2Manifold")]
		public static B2Manifold CollideSmoothSegmentAndPolygon([NativeName(NativeNameType.Param, "smoothSegmentA")] [NativeName(NativeNameType.Type, "const b2SmoothSegment*")] B2SmoothSegment* smoothSegmentA, [NativeName(NativeNameType.Param, "xfA")] [NativeName(NativeNameType.Type, "b2Transform")] B2Transform xfA, [NativeName(NativeNameType.Param, "polygonB")] [NativeName(NativeNameType.Type, "const b2Polygon*")] ref B2Polygon polygonB, [NativeName(NativeNameType.Param, "xfB")] [NativeName(NativeNameType.Type, "b2Transform")] B2Transform xfB, [NativeName(NativeNameType.Param, "cache")] [NativeName(NativeNameType.Type, "b2DistanceCache*")] B2DistanceCache* cache)
		{
			fixed (B2Polygon* ppolygonB = &polygonB)
			{
				B2Manifold ret = CollideSmoothSegmentAndPolygonNative(smoothSegmentA, xfA, (B2Polygon*)ppolygonB, xfB, cache);
				return ret;
			}
		}

		/// <summary>
		/// Compute the contact manifold between a smooth segment and a rounded polygon<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2CollideSmoothSegmentAndPolygon")]
		[return: NativeName(NativeNameType.Type, "b2Manifold")]
		public static B2Manifold CollideSmoothSegmentAndPolygon([NativeName(NativeNameType.Param, "smoothSegmentA")] [NativeName(NativeNameType.Type, "const b2SmoothSegment*")] ref B2SmoothSegment smoothSegmentA, [NativeName(NativeNameType.Param, "xfA")] [NativeName(NativeNameType.Type, "b2Transform")] B2Transform xfA, [NativeName(NativeNameType.Param, "polygonB")] [NativeName(NativeNameType.Type, "const b2Polygon*")] ref B2Polygon polygonB, [NativeName(NativeNameType.Param, "xfB")] [NativeName(NativeNameType.Type, "b2Transform")] B2Transform xfB, [NativeName(NativeNameType.Param, "cache")] [NativeName(NativeNameType.Type, "b2DistanceCache*")] B2DistanceCache* cache)
		{
			fixed (B2SmoothSegment* psmoothSegmentA = &smoothSegmentA)
			{
				fixed (B2Polygon* ppolygonB = &polygonB)
				{
					B2Manifold ret = CollideSmoothSegmentAndPolygonNative((B2SmoothSegment*)psmoothSegmentA, xfA, (B2Polygon*)ppolygonB, xfB, cache);
					return ret;
				}
			}
		}

		/// <summary>
		/// Compute the contact manifold between a smooth segment and a rounded polygon<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2CollideSmoothSegmentAndPolygon")]
		[return: NativeName(NativeNameType.Type, "b2Manifold")]
		public static B2Manifold CollideSmoothSegmentAndPolygon([NativeName(NativeNameType.Param, "smoothSegmentA")] [NativeName(NativeNameType.Type, "const b2SmoothSegment*")] B2SmoothSegment* smoothSegmentA, [NativeName(NativeNameType.Param, "xfA")] [NativeName(NativeNameType.Type, "b2Transform")] B2Transform xfA, [NativeName(NativeNameType.Param, "polygonB")] [NativeName(NativeNameType.Type, "const b2Polygon*")] B2Polygon* polygonB, [NativeName(NativeNameType.Param, "xfB")] [NativeName(NativeNameType.Type, "b2Transform")] B2Transform xfB, [NativeName(NativeNameType.Param, "cache")] [NativeName(NativeNameType.Type, "b2DistanceCache*")] ref B2DistanceCache cache)
		{
			fixed (B2DistanceCache* pcache = &cache)
			{
				B2Manifold ret = CollideSmoothSegmentAndPolygonNative(smoothSegmentA, xfA, polygonB, xfB, (B2DistanceCache*)pcache);
				return ret;
			}
		}

		/// <summary>
		/// Compute the contact manifold between a smooth segment and a rounded polygon<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2CollideSmoothSegmentAndPolygon")]
		[return: NativeName(NativeNameType.Type, "b2Manifold")]
		public static B2Manifold CollideSmoothSegmentAndPolygon([NativeName(NativeNameType.Param, "smoothSegmentA")] [NativeName(NativeNameType.Type, "const b2SmoothSegment*")] ref B2SmoothSegment smoothSegmentA, [NativeName(NativeNameType.Param, "xfA")] [NativeName(NativeNameType.Type, "b2Transform")] B2Transform xfA, [NativeName(NativeNameType.Param, "polygonB")] [NativeName(NativeNameType.Type, "const b2Polygon*")] B2Polygon* polygonB, [NativeName(NativeNameType.Param, "xfB")] [NativeName(NativeNameType.Type, "b2Transform")] B2Transform xfB, [NativeName(NativeNameType.Param, "cache")] [NativeName(NativeNameType.Type, "b2DistanceCache*")] ref B2DistanceCache cache)
		{
			fixed (B2SmoothSegment* psmoothSegmentA = &smoothSegmentA)
			{
				fixed (B2DistanceCache* pcache = &cache)
				{
					B2Manifold ret = CollideSmoothSegmentAndPolygonNative((B2SmoothSegment*)psmoothSegmentA, xfA, polygonB, xfB, (B2DistanceCache*)pcache);
					return ret;
				}
			}
		}

		/// <summary>
		/// Compute the contact manifold between a smooth segment and a rounded polygon<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2CollideSmoothSegmentAndPolygon")]
		[return: NativeName(NativeNameType.Type, "b2Manifold")]
		public static B2Manifold CollideSmoothSegmentAndPolygon([NativeName(NativeNameType.Param, "smoothSegmentA")] [NativeName(NativeNameType.Type, "const b2SmoothSegment*")] B2SmoothSegment* smoothSegmentA, [NativeName(NativeNameType.Param, "xfA")] [NativeName(NativeNameType.Type, "b2Transform")] B2Transform xfA, [NativeName(NativeNameType.Param, "polygonB")] [NativeName(NativeNameType.Type, "const b2Polygon*")] ref B2Polygon polygonB, [NativeName(NativeNameType.Param, "xfB")] [NativeName(NativeNameType.Type, "b2Transform")] B2Transform xfB, [NativeName(NativeNameType.Param, "cache")] [NativeName(NativeNameType.Type, "b2DistanceCache*")] ref B2DistanceCache cache)
		{
			fixed (B2Polygon* ppolygonB = &polygonB)
			{
				fixed (B2DistanceCache* pcache = &cache)
				{
					B2Manifold ret = CollideSmoothSegmentAndPolygonNative(smoothSegmentA, xfA, (B2Polygon*)ppolygonB, xfB, (B2DistanceCache*)pcache);
					return ret;
				}
			}
		}

		/// <summary>
		/// Compute the contact manifold between a smooth segment and a rounded polygon<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2CollideSmoothSegmentAndPolygon")]
		[return: NativeName(NativeNameType.Type, "b2Manifold")]
		public static B2Manifold CollideSmoothSegmentAndPolygon([NativeName(NativeNameType.Param, "smoothSegmentA")] [NativeName(NativeNameType.Type, "const b2SmoothSegment*")] ref B2SmoothSegment smoothSegmentA, [NativeName(NativeNameType.Param, "xfA")] [NativeName(NativeNameType.Type, "b2Transform")] B2Transform xfA, [NativeName(NativeNameType.Param, "polygonB")] [NativeName(NativeNameType.Type, "const b2Polygon*")] ref B2Polygon polygonB, [NativeName(NativeNameType.Param, "xfB")] [NativeName(NativeNameType.Type, "b2Transform")] B2Transform xfB, [NativeName(NativeNameType.Param, "cache")] [NativeName(NativeNameType.Type, "b2DistanceCache*")] ref B2DistanceCache cache)
		{
			fixed (B2SmoothSegment* psmoothSegmentA = &smoothSegmentA)
			{
				fixed (B2Polygon* ppolygonB = &polygonB)
				{
					fixed (B2DistanceCache* pcache = &cache)
					{
						B2Manifold ret = CollideSmoothSegmentAndPolygonNative((B2SmoothSegment*)psmoothSegmentA, xfA, (B2Polygon*)ppolygonB, xfB, (B2DistanceCache*)pcache);
						return ret;
					}
				}
			}
		}

		/// <summary>
		/// Constructing the tree initializes the node pool.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2DynamicTree_Create")]
		[return: NativeName(NativeNameType.Type, "b2DynamicTree")]
		internal static B2DynamicTree DynamicTreeCreateNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<B2DynamicTree>)vt[65])();
			#else
			return (B2DynamicTree)((delegate* unmanaged[Cdecl]<B2DynamicTree>)vt[65])();
			#endif
		}

		/// <summary>
		/// Constructing the tree initializes the node pool.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2DynamicTree_Create")]
		[return: NativeName(NativeNameType.Type, "b2DynamicTree")]
		public static B2DynamicTree DynamicTreeCreate()
		{
			B2DynamicTree ret = DynamicTreeCreateNative();
			return ret;
		}

		/// <summary>
		/// Destroy the tree, freeing the node pool.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2DynamicTree_Destroy")]
		[return: NativeName(NativeNameType.Type, "void")]
		internal static void DynamicTreeDestroyNative([NativeName(NativeNameType.Param, "tree")] [NativeName(NativeNameType.Type, "b2DynamicTree*")] B2DynamicTree* tree)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<B2DynamicTree*, void>)vt[66])(tree);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)vt[66])((nint)tree);
			#endif
		}

		/// <summary>
		/// Destroy the tree, freeing the node pool.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2DynamicTree_Destroy")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void DynamicTreeDestroy([NativeName(NativeNameType.Param, "tree")] [NativeName(NativeNameType.Type, "b2DynamicTree*")] B2DynamicTree* tree)
		{
			DynamicTreeDestroyNative(tree);
		}

		/// <summary>
		/// Destroy the tree, freeing the node pool.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2DynamicTree_Destroy")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void DynamicTreeDestroy([NativeName(NativeNameType.Param, "tree")] [NativeName(NativeNameType.Type, "b2DynamicTree*")] ref B2DynamicTree tree)
		{
			fixed (B2DynamicTree* ptree = &tree)
			{
				DynamicTreeDestroyNative((B2DynamicTree*)ptree);
			}
		}

		/// <summary>
		/// Create a proxy. Provide an AABB and a userData value.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2DynamicTree_CreateProxy")]
		[return: NativeName(NativeNameType.Type, "int32_t")]
		internal static int DynamicTreeCreateProxyNative([NativeName(NativeNameType.Param, "tree")] [NativeName(NativeNameType.Type, "b2DynamicTree*")] B2DynamicTree* tree, [NativeName(NativeNameType.Param, "aabb")] [NativeName(NativeNameType.Type, "b2AABB")] B2AABB aabb, [NativeName(NativeNameType.Param, "categoryBits")] [NativeName(NativeNameType.Type, "uint32_t")] uint categoryBits, [NativeName(NativeNameType.Param, "userData")] [NativeName(NativeNameType.Type, "int32_t")] int userData)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<B2DynamicTree*, B2AABB, uint, int, int>)vt[67])(tree, aabb, categoryBits, userData);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, B2AABB, uint, int, int>)vt[67])((nint)tree, aabb, categoryBits, userData);
			#endif
		}

		/// <summary>
		/// Create a proxy. Provide an AABB and a userData value.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2DynamicTree_CreateProxy")]
		[return: NativeName(NativeNameType.Type, "int32_t")]
		public static int DynamicTreeCreateProxy([NativeName(NativeNameType.Param, "tree")] [NativeName(NativeNameType.Type, "b2DynamicTree*")] B2DynamicTree* tree, [NativeName(NativeNameType.Param, "aabb")] [NativeName(NativeNameType.Type, "b2AABB")] B2AABB aabb, [NativeName(NativeNameType.Param, "categoryBits")] [NativeName(NativeNameType.Type, "uint32_t")] uint categoryBits, [NativeName(NativeNameType.Param, "userData")] [NativeName(NativeNameType.Type, "int32_t")] int userData)
		{
			int ret = DynamicTreeCreateProxyNative(tree, aabb, categoryBits, userData);
			return ret;
		}

		/// <summary>
		/// Create a proxy. Provide an AABB and a userData value.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2DynamicTree_CreateProxy")]
		[return: NativeName(NativeNameType.Type, "int32_t")]
		public static int DynamicTreeCreateProxy([NativeName(NativeNameType.Param, "tree")] [NativeName(NativeNameType.Type, "b2DynamicTree*")] ref B2DynamicTree tree, [NativeName(NativeNameType.Param, "aabb")] [NativeName(NativeNameType.Type, "b2AABB")] B2AABB aabb, [NativeName(NativeNameType.Param, "categoryBits")] [NativeName(NativeNameType.Type, "uint32_t")] uint categoryBits, [NativeName(NativeNameType.Param, "userData")] [NativeName(NativeNameType.Type, "int32_t")] int userData)
		{
			fixed (B2DynamicTree* ptree = &tree)
			{
				int ret = DynamicTreeCreateProxyNative((B2DynamicTree*)ptree, aabb, categoryBits, userData);
				return ret;
			}
		}

		/// <summary>
		/// Destroy a proxy. This asserts if the id is invalid.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2DynamicTree_DestroyProxy")]
		[return: NativeName(NativeNameType.Type, "void")]
		internal static void DynamicTreeDestroyProxyNative([NativeName(NativeNameType.Param, "tree")] [NativeName(NativeNameType.Type, "b2DynamicTree*")] B2DynamicTree* tree, [NativeName(NativeNameType.Param, "proxyId")] [NativeName(NativeNameType.Type, "int32_t")] int proxyId)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<B2DynamicTree*, int, void>)vt[68])(tree, proxyId);
			#else
			((delegate* unmanaged[Cdecl]<nint, int, void>)vt[68])((nint)tree, proxyId);
			#endif
		}

		/// <summary>
		/// Destroy a proxy. This asserts if the id is invalid.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2DynamicTree_DestroyProxy")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void DynamicTreeDestroyProxy([NativeName(NativeNameType.Param, "tree")] [NativeName(NativeNameType.Type, "b2DynamicTree*")] B2DynamicTree* tree, [NativeName(NativeNameType.Param, "proxyId")] [NativeName(NativeNameType.Type, "int32_t")] int proxyId)
		{
			DynamicTreeDestroyProxyNative(tree, proxyId);
		}

		/// <summary>
		/// Destroy a proxy. This asserts if the id is invalid.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2DynamicTree_DestroyProxy")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void DynamicTreeDestroyProxy([NativeName(NativeNameType.Param, "tree")] [NativeName(NativeNameType.Type, "b2DynamicTree*")] ref B2DynamicTree tree, [NativeName(NativeNameType.Param, "proxyId")] [NativeName(NativeNameType.Type, "int32_t")] int proxyId)
		{
			fixed (B2DynamicTree* ptree = &tree)
			{
				DynamicTreeDestroyProxyNative((B2DynamicTree*)ptree, proxyId);
			}
		}

		/// <summary>
		/// Move a proxy to a new AABB by removing and reinserting into the tree.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2DynamicTree_MoveProxy")]
		[return: NativeName(NativeNameType.Type, "void")]
		internal static void DynamicTreeMoveProxyNative([NativeName(NativeNameType.Param, "tree")] [NativeName(NativeNameType.Type, "b2DynamicTree*")] B2DynamicTree* tree, [NativeName(NativeNameType.Param, "proxyId")] [NativeName(NativeNameType.Type, "int32_t")] int proxyId, [NativeName(NativeNameType.Param, "aabb")] [NativeName(NativeNameType.Type, "b2AABB")] B2AABB aabb)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<B2DynamicTree*, int, B2AABB, void>)vt[69])(tree, proxyId, aabb);
			#else
			((delegate* unmanaged[Cdecl]<nint, int, B2AABB, void>)vt[69])((nint)tree, proxyId, aabb);
			#endif
		}

		/// <summary>
		/// Move a proxy to a new AABB by removing and reinserting into the tree.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2DynamicTree_MoveProxy")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void DynamicTreeMoveProxy([NativeName(NativeNameType.Param, "tree")] [NativeName(NativeNameType.Type, "b2DynamicTree*")] B2DynamicTree* tree, [NativeName(NativeNameType.Param, "proxyId")] [NativeName(NativeNameType.Type, "int32_t")] int proxyId, [NativeName(NativeNameType.Param, "aabb")] [NativeName(NativeNameType.Type, "b2AABB")] B2AABB aabb)
		{
			DynamicTreeMoveProxyNative(tree, proxyId, aabb);
		}

		/// <summary>
		/// Move a proxy to a new AABB by removing and reinserting into the tree.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2DynamicTree_MoveProxy")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void DynamicTreeMoveProxy([NativeName(NativeNameType.Param, "tree")] [NativeName(NativeNameType.Type, "b2DynamicTree*")] ref B2DynamicTree tree, [NativeName(NativeNameType.Param, "proxyId")] [NativeName(NativeNameType.Type, "int32_t")] int proxyId, [NativeName(NativeNameType.Param, "aabb")] [NativeName(NativeNameType.Type, "b2AABB")] B2AABB aabb)
		{
			fixed (B2DynamicTree* ptree = &tree)
			{
				DynamicTreeMoveProxyNative((B2DynamicTree*)ptree, proxyId, aabb);
			}
		}

		/// <summary>
		/// Enlarge a proxy and enlarge ancestors as necessary.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2DynamicTree_EnlargeProxy")]
		[return: NativeName(NativeNameType.Type, "void")]
		internal static void DynamicTreeEnlargeProxyNative([NativeName(NativeNameType.Param, "tree")] [NativeName(NativeNameType.Type, "b2DynamicTree*")] B2DynamicTree* tree, [NativeName(NativeNameType.Param, "proxyId")] [NativeName(NativeNameType.Type, "int32_t")] int proxyId, [NativeName(NativeNameType.Param, "aabb")] [NativeName(NativeNameType.Type, "b2AABB")] B2AABB aabb)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<B2DynamicTree*, int, B2AABB, void>)vt[70])(tree, proxyId, aabb);
			#else
			((delegate* unmanaged[Cdecl]<nint, int, B2AABB, void>)vt[70])((nint)tree, proxyId, aabb);
			#endif
		}

		/// <summary>
		/// Enlarge a proxy and enlarge ancestors as necessary.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2DynamicTree_EnlargeProxy")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void DynamicTreeEnlargeProxy([NativeName(NativeNameType.Param, "tree")] [NativeName(NativeNameType.Type, "b2DynamicTree*")] B2DynamicTree* tree, [NativeName(NativeNameType.Param, "proxyId")] [NativeName(NativeNameType.Type, "int32_t")] int proxyId, [NativeName(NativeNameType.Param, "aabb")] [NativeName(NativeNameType.Type, "b2AABB")] B2AABB aabb)
		{
			DynamicTreeEnlargeProxyNative(tree, proxyId, aabb);
		}

		/// <summary>
		/// Enlarge a proxy and enlarge ancestors as necessary.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2DynamicTree_EnlargeProxy")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void DynamicTreeEnlargeProxy([NativeName(NativeNameType.Param, "tree")] [NativeName(NativeNameType.Type, "b2DynamicTree*")] ref B2DynamicTree tree, [NativeName(NativeNameType.Param, "proxyId")] [NativeName(NativeNameType.Type, "int32_t")] int proxyId, [NativeName(NativeNameType.Param, "aabb")] [NativeName(NativeNameType.Type, "b2AABB")] B2AABB aabb)
		{
			fixed (B2DynamicTree* ptree = &tree)
			{
				DynamicTreeEnlargeProxyNative((B2DynamicTree*)ptree, proxyId, aabb);
			}
		}

		/// <summary>
		/// Query an AABB for overlapping proxies. The callback class<br/>
		/// is called for each proxy that overlaps the supplied AABB.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2DynamicTree_Query")]
		[return: NativeName(NativeNameType.Type, "void")]
		internal static void DynamicTreeQueryNative([NativeName(NativeNameType.Param, "tree")] [NativeName(NativeNameType.Type, "const b2DynamicTree*")] B2DynamicTree* tree, [NativeName(NativeNameType.Param, "aabb")] [NativeName(NativeNameType.Type, "b2AABB")] B2AABB aabb, [NativeName(NativeNameType.Param, "maskBits")] [NativeName(NativeNameType.Type, "uint32_t")] uint maskBits, [NativeName(NativeNameType.Param, "callback")] [NativeName(NativeNameType.Type, "b2TreeQueryCallbackFcn*")] delegate*<int, int, void*, bool>* callback, [NativeName(NativeNameType.Param, "context")] [NativeName(NativeNameType.Type, "void*")] void* context)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<B2DynamicTree*, B2AABB, uint, delegate*<int, int, void*, bool>*, void*, void>)vt[71])(tree, aabb, maskBits, callback, context);
			#else
			((delegate* unmanaged[Cdecl]<nint, B2AABB, uint, nint, nint, void>)vt[71])((nint)tree, aabb, maskBits, (nint)callback, (nint)context);
			#endif
		}

		/// <summary>
		/// Query an AABB for overlapping proxies. The callback class<br/>
		/// is called for each proxy that overlaps the supplied AABB.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2DynamicTree_Query")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void DynamicTreeQuery([NativeName(NativeNameType.Param, "tree")] [NativeName(NativeNameType.Type, "const b2DynamicTree*")] B2DynamicTree* tree, [NativeName(NativeNameType.Param, "aabb")] [NativeName(NativeNameType.Type, "b2AABB")] B2AABB aabb, [NativeName(NativeNameType.Param, "maskBits")] [NativeName(NativeNameType.Type, "uint32_t")] uint maskBits, [NativeName(NativeNameType.Param, "callback")] [NativeName(NativeNameType.Type, "b2TreeQueryCallbackFcn*")] delegate*<int, int, void*, bool>* callback, [NativeName(NativeNameType.Param, "context")] [NativeName(NativeNameType.Type, "void*")] void* context)
		{
			DynamicTreeQueryNative(tree, aabb, maskBits, callback, context);
		}

		/// <summary>
		/// Query an AABB for overlapping proxies. The callback class<br/>
		/// is called for each proxy that overlaps the supplied AABB.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2DynamicTree_Query")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void DynamicTreeQuery([NativeName(NativeNameType.Param, "tree")] [NativeName(NativeNameType.Type, "const b2DynamicTree*")] ref B2DynamicTree tree, [NativeName(NativeNameType.Param, "aabb")] [NativeName(NativeNameType.Type, "b2AABB")] B2AABB aabb, [NativeName(NativeNameType.Param, "maskBits")] [NativeName(NativeNameType.Type, "uint32_t")] uint maskBits, [NativeName(NativeNameType.Param, "callback")] [NativeName(NativeNameType.Type, "b2TreeQueryCallbackFcn*")] delegate*<int, int, void*, bool>* callback, [NativeName(NativeNameType.Param, "context")] [NativeName(NativeNameType.Type, "void*")] void* context)
		{
			fixed (B2DynamicTree* ptree = &tree)
			{
				DynamicTreeQueryNative((B2DynamicTree*)ptree, aabb, maskBits, callback, context);
			}
		}

		/// <summary>
		/// Ray-cast against the proxies in the tree. This relies on the callback<br/>
		/// to perform a exact ray-cast in the case were the proxy contains a shape.<br/>
		/// The callback also performs the any collision filtering. This has performance<br/>
		/// roughly equal to k * log(n), where k is the number of collisions and n is the<br/>
		/// number of proxies in the tree.<br/>
		/// Bit-wise filtering using mask bits can greatly improve performance in some scenarios.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2DynamicTree_RayCast")]
		[return: NativeName(NativeNameType.Type, "void")]
		internal static void DynamicTreeRayCastNative([NativeName(NativeNameType.Param, "tree")] [NativeName(NativeNameType.Type, "const b2DynamicTree*")] B2DynamicTree* tree, [NativeName(NativeNameType.Param, "input")] [NativeName(NativeNameType.Type, "const b2RayCastInput*")] B2RayCastInput* input, [NativeName(NativeNameType.Param, "maskBits")] [NativeName(NativeNameType.Type, "uint32_t")] uint maskBits, [NativeName(NativeNameType.Param, "callback")] [NativeName(NativeNameType.Type, "b2TreeRayCastCallbackFcn*")] delegate*<B2RayCastInput*, int, int, void*, float>* callback, [NativeName(NativeNameType.Param, "context")] [NativeName(NativeNameType.Type, "void*")] void* context)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<B2DynamicTree*, B2RayCastInput*, uint, delegate*<B2RayCastInput*, int, int, void*, float>*, void*, void>)vt[72])(tree, input, maskBits, callback, context);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, uint, nint, nint, void>)vt[72])((nint)tree, (nint)input, maskBits, (nint)callback, (nint)context);
			#endif
		}

		/// <summary>
		/// Ray-cast against the proxies in the tree. This relies on the callback<br/>
		/// to perform a exact ray-cast in the case were the proxy contains a shape.<br/>
		/// The callback also performs the any collision filtering. This has performance<br/>
		/// roughly equal to k * log(n), where k is the number of collisions and n is the<br/>
		/// number of proxies in the tree.<br/>
		/// Bit-wise filtering using mask bits can greatly improve performance in some scenarios.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2DynamicTree_RayCast")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void DynamicTreeRayCast([NativeName(NativeNameType.Param, "tree")] [NativeName(NativeNameType.Type, "const b2DynamicTree*")] B2DynamicTree* tree, [NativeName(NativeNameType.Param, "input")] [NativeName(NativeNameType.Type, "const b2RayCastInput*")] B2RayCastInput* input, [NativeName(NativeNameType.Param, "maskBits")] [NativeName(NativeNameType.Type, "uint32_t")] uint maskBits, [NativeName(NativeNameType.Param, "callback")] [NativeName(NativeNameType.Type, "b2TreeRayCastCallbackFcn*")] delegate*<B2RayCastInput*, int, int, void*, float>* callback, [NativeName(NativeNameType.Param, "context")] [NativeName(NativeNameType.Type, "void*")] void* context)
		{
			DynamicTreeRayCastNative(tree, input, maskBits, callback, context);
		}

		/// <summary>
		/// Ray-cast against the proxies in the tree. This relies on the callback<br/>
		/// to perform a exact ray-cast in the case were the proxy contains a shape.<br/>
		/// The callback also performs the any collision filtering. This has performance<br/>
		/// roughly equal to k * log(n), where k is the number of collisions and n is the<br/>
		/// number of proxies in the tree.<br/>
		/// Bit-wise filtering using mask bits can greatly improve performance in some scenarios.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2DynamicTree_RayCast")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void DynamicTreeRayCast([NativeName(NativeNameType.Param, "tree")] [NativeName(NativeNameType.Type, "const b2DynamicTree*")] ref B2DynamicTree tree, [NativeName(NativeNameType.Param, "input")] [NativeName(NativeNameType.Type, "const b2RayCastInput*")] B2RayCastInput* input, [NativeName(NativeNameType.Param, "maskBits")] [NativeName(NativeNameType.Type, "uint32_t")] uint maskBits, [NativeName(NativeNameType.Param, "callback")] [NativeName(NativeNameType.Type, "b2TreeRayCastCallbackFcn*")] delegate*<B2RayCastInput*, int, int, void*, float>* callback, [NativeName(NativeNameType.Param, "context")] [NativeName(NativeNameType.Type, "void*")] void* context)
		{
			fixed (B2DynamicTree* ptree = &tree)
			{
				DynamicTreeRayCastNative((B2DynamicTree*)ptree, input, maskBits, callback, context);
			}
		}

		/// <summary>
		/// Ray-cast against the proxies in the tree. This relies on the callback<br/>
		/// to perform a exact ray-cast in the case were the proxy contains a shape.<br/>
		/// The callback also performs the any collision filtering. This has performance<br/>
		/// roughly equal to k * log(n), where k is the number of collisions and n is the<br/>
		/// number of proxies in the tree.<br/>
		/// Bit-wise filtering using mask bits can greatly improve performance in some scenarios.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2DynamicTree_RayCast")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void DynamicTreeRayCast([NativeName(NativeNameType.Param, "tree")] [NativeName(NativeNameType.Type, "const b2DynamicTree*")] B2DynamicTree* tree, [NativeName(NativeNameType.Param, "input")] [NativeName(NativeNameType.Type, "const b2RayCastInput*")] ref B2RayCastInput input, [NativeName(NativeNameType.Param, "maskBits")] [NativeName(NativeNameType.Type, "uint32_t")] uint maskBits, [NativeName(NativeNameType.Param, "callback")] [NativeName(NativeNameType.Type, "b2TreeRayCastCallbackFcn*")] delegate*<B2RayCastInput*, int, int, void*, float>* callback, [NativeName(NativeNameType.Param, "context")] [NativeName(NativeNameType.Type, "void*")] void* context)
		{
			fixed (B2RayCastInput* pinput = &input)
			{
				DynamicTreeRayCastNative(tree, (B2RayCastInput*)pinput, maskBits, callback, context);
			}
		}

		/// <summary>
		/// Ray-cast against the proxies in the tree. This relies on the callback<br/>
		/// to perform a exact ray-cast in the case were the proxy contains a shape.<br/>
		/// The callback also performs the any collision filtering. This has performance<br/>
		/// roughly equal to k * log(n), where k is the number of collisions and n is the<br/>
		/// number of proxies in the tree.<br/>
		/// Bit-wise filtering using mask bits can greatly improve performance in some scenarios.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2DynamicTree_RayCast")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void DynamicTreeRayCast([NativeName(NativeNameType.Param, "tree")] [NativeName(NativeNameType.Type, "const b2DynamicTree*")] ref B2DynamicTree tree, [NativeName(NativeNameType.Param, "input")] [NativeName(NativeNameType.Type, "const b2RayCastInput*")] ref B2RayCastInput input, [NativeName(NativeNameType.Param, "maskBits")] [NativeName(NativeNameType.Type, "uint32_t")] uint maskBits, [NativeName(NativeNameType.Param, "callback")] [NativeName(NativeNameType.Type, "b2TreeRayCastCallbackFcn*")] delegate*<B2RayCastInput*, int, int, void*, float>* callback, [NativeName(NativeNameType.Param, "context")] [NativeName(NativeNameType.Type, "void*")] void* context)
		{
			fixed (B2DynamicTree* ptree = &tree)
			{
				fixed (B2RayCastInput* pinput = &input)
				{
					DynamicTreeRayCastNative((B2DynamicTree*)ptree, (B2RayCastInput*)pinput, maskBits, callback, context);
				}
			}
		}

		/// <summary>
		/// Ray-cast against the proxies in the tree. This relies on the callback<br/>
		/// to perform a exact ray-cast in the case were the proxy contains a shape.<br/>
		/// The callback also performs the any collision filtering. This has performance<br/>
		/// roughly equal to k * log(n), where k is the number of collisions and n is the<br/>
		/// number of proxies in the tree.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2DynamicTree_ShapeCast")]
		[return: NativeName(NativeNameType.Type, "void")]
		internal static void DynamicTreeShapeCastNative([NativeName(NativeNameType.Param, "tree")] [NativeName(NativeNameType.Type, "const b2DynamicTree*")] B2DynamicTree* tree, [NativeName(NativeNameType.Param, "input")] [NativeName(NativeNameType.Type, "const b2ShapeCastInput*")] B2ShapeCastInput* input, [NativeName(NativeNameType.Param, "maskBits")] [NativeName(NativeNameType.Type, "uint32_t")] uint maskBits, [NativeName(NativeNameType.Param, "callback")] [NativeName(NativeNameType.Type, "b2TreeShapeCastCallbackFcn*")] delegate*<B2ShapeCastInput*, int, int, void*, float>* callback, [NativeName(NativeNameType.Param, "context")] [NativeName(NativeNameType.Type, "void*")] void* context)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<B2DynamicTree*, B2ShapeCastInput*, uint, delegate*<B2ShapeCastInput*, int, int, void*, float>*, void*, void>)vt[73])(tree, input, maskBits, callback, context);
			#else
			((delegate* unmanaged[Cdecl]<nint, nint, uint, nint, nint, void>)vt[73])((nint)tree, (nint)input, maskBits, (nint)callback, (nint)context);
			#endif
		}

		/// <summary>
		/// Ray-cast against the proxies in the tree. This relies on the callback<br/>
		/// to perform a exact ray-cast in the case were the proxy contains a shape.<br/>
		/// The callback also performs the any collision filtering. This has performance<br/>
		/// roughly equal to k * log(n), where k is the number of collisions and n is the<br/>
		/// number of proxies in the tree.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2DynamicTree_ShapeCast")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void DynamicTreeShapeCast([NativeName(NativeNameType.Param, "tree")] [NativeName(NativeNameType.Type, "const b2DynamicTree*")] B2DynamicTree* tree, [NativeName(NativeNameType.Param, "input")] [NativeName(NativeNameType.Type, "const b2ShapeCastInput*")] B2ShapeCastInput* input, [NativeName(NativeNameType.Param, "maskBits")] [NativeName(NativeNameType.Type, "uint32_t")] uint maskBits, [NativeName(NativeNameType.Param, "callback")] [NativeName(NativeNameType.Type, "b2TreeShapeCastCallbackFcn*")] delegate*<B2ShapeCastInput*, int, int, void*, float>* callback, [NativeName(NativeNameType.Param, "context")] [NativeName(NativeNameType.Type, "void*")] void* context)
		{
			DynamicTreeShapeCastNative(tree, input, maskBits, callback, context);
		}

		/// <summary>
		/// Ray-cast against the proxies in the tree. This relies on the callback<br/>
		/// to perform a exact ray-cast in the case were the proxy contains a shape.<br/>
		/// The callback also performs the any collision filtering. This has performance<br/>
		/// roughly equal to k * log(n), where k is the number of collisions and n is the<br/>
		/// number of proxies in the tree.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2DynamicTree_ShapeCast")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void DynamicTreeShapeCast([NativeName(NativeNameType.Param, "tree")] [NativeName(NativeNameType.Type, "const b2DynamicTree*")] ref B2DynamicTree tree, [NativeName(NativeNameType.Param, "input")] [NativeName(NativeNameType.Type, "const b2ShapeCastInput*")] B2ShapeCastInput* input, [NativeName(NativeNameType.Param, "maskBits")] [NativeName(NativeNameType.Type, "uint32_t")] uint maskBits, [NativeName(NativeNameType.Param, "callback")] [NativeName(NativeNameType.Type, "b2TreeShapeCastCallbackFcn*")] delegate*<B2ShapeCastInput*, int, int, void*, float>* callback, [NativeName(NativeNameType.Param, "context")] [NativeName(NativeNameType.Type, "void*")] void* context)
		{
			fixed (B2DynamicTree* ptree = &tree)
			{
				DynamicTreeShapeCastNative((B2DynamicTree*)ptree, input, maskBits, callback, context);
			}
		}

		/// <summary>
		/// Ray-cast against the proxies in the tree. This relies on the callback<br/>
		/// to perform a exact ray-cast in the case were the proxy contains a shape.<br/>
		/// The callback also performs the any collision filtering. This has performance<br/>
		/// roughly equal to k * log(n), where k is the number of collisions and n is the<br/>
		/// number of proxies in the tree.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2DynamicTree_ShapeCast")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void DynamicTreeShapeCast([NativeName(NativeNameType.Param, "tree")] [NativeName(NativeNameType.Type, "const b2DynamicTree*")] B2DynamicTree* tree, [NativeName(NativeNameType.Param, "input")] [NativeName(NativeNameType.Type, "const b2ShapeCastInput*")] ref B2ShapeCastInput input, [NativeName(NativeNameType.Param, "maskBits")] [NativeName(NativeNameType.Type, "uint32_t")] uint maskBits, [NativeName(NativeNameType.Param, "callback")] [NativeName(NativeNameType.Type, "b2TreeShapeCastCallbackFcn*")] delegate*<B2ShapeCastInput*, int, int, void*, float>* callback, [NativeName(NativeNameType.Param, "context")] [NativeName(NativeNameType.Type, "void*")] void* context)
		{
			fixed (B2ShapeCastInput* pinput = &input)
			{
				DynamicTreeShapeCastNative(tree, (B2ShapeCastInput*)pinput, maskBits, callback, context);
			}
		}

		/// <summary>
		/// Ray-cast against the proxies in the tree. This relies on the callback<br/>
		/// to perform a exact ray-cast in the case were the proxy contains a shape.<br/>
		/// The callback also performs the any collision filtering. This has performance<br/>
		/// roughly equal to k * log(n), where k is the number of collisions and n is the<br/>
		/// number of proxies in the tree.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2DynamicTree_ShapeCast")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void DynamicTreeShapeCast([NativeName(NativeNameType.Param, "tree")] [NativeName(NativeNameType.Type, "const b2DynamicTree*")] ref B2DynamicTree tree, [NativeName(NativeNameType.Param, "input")] [NativeName(NativeNameType.Type, "const b2ShapeCastInput*")] ref B2ShapeCastInput input, [NativeName(NativeNameType.Param, "maskBits")] [NativeName(NativeNameType.Type, "uint32_t")] uint maskBits, [NativeName(NativeNameType.Param, "callback")] [NativeName(NativeNameType.Type, "b2TreeShapeCastCallbackFcn*")] delegate*<B2ShapeCastInput*, int, int, void*, float>* callback, [NativeName(NativeNameType.Param, "context")] [NativeName(NativeNameType.Type, "void*")] void* context)
		{
			fixed (B2DynamicTree* ptree = &tree)
			{
				fixed (B2ShapeCastInput* pinput = &input)
				{
					DynamicTreeShapeCastNative((B2DynamicTree*)ptree, (B2ShapeCastInput*)pinput, maskBits, callback, context);
				}
			}
		}

		/// <summary>
		/// Validate this tree. For testing.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2DynamicTree_Validate")]
		[return: NativeName(NativeNameType.Type, "void")]
		internal static void DynamicTreeValidateNative([NativeName(NativeNameType.Param, "tree")] [NativeName(NativeNameType.Type, "const b2DynamicTree*")] B2DynamicTree* tree)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<B2DynamicTree*, void>)vt[74])(tree);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)vt[74])((nint)tree);
			#endif
		}

		/// <summary>
		/// Validate this tree. For testing.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2DynamicTree_Validate")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void DynamicTreeValidate([NativeName(NativeNameType.Param, "tree")] [NativeName(NativeNameType.Type, "const b2DynamicTree*")] B2DynamicTree* tree)
		{
			DynamicTreeValidateNative(tree);
		}

		/// <summary>
		/// Validate this tree. For testing.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2DynamicTree_Validate")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void DynamicTreeValidate([NativeName(NativeNameType.Param, "tree")] [NativeName(NativeNameType.Type, "const b2DynamicTree*")] ref B2DynamicTree tree)
		{
			fixed (B2DynamicTree* ptree = &tree)
			{
				DynamicTreeValidateNative((B2DynamicTree*)ptree);
			}
		}

		/// <summary>
		/// Compute the height of the binary tree in O(N) time. Should not be<br/>
		/// called often.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2DynamicTree_GetHeight")]
		[return: NativeName(NativeNameType.Type, "int")]
		internal static int DynamicTreeGetHeightNative([NativeName(NativeNameType.Param, "tree")] [NativeName(NativeNameType.Type, "const b2DynamicTree*")] B2DynamicTree* tree)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<B2DynamicTree*, int>)vt[75])(tree);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, int>)vt[75])((nint)tree);
			#endif
		}

		/// <summary>
		/// Compute the height of the binary tree in O(N) time. Should not be<br/>
		/// called often.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2DynamicTree_GetHeight")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int DynamicTreeGetHeight([NativeName(NativeNameType.Param, "tree")] [NativeName(NativeNameType.Type, "const b2DynamicTree*")] B2DynamicTree* tree)
		{
			int ret = DynamicTreeGetHeightNative(tree);
			return ret;
		}

		/// <summary>
		/// Compute the height of the binary tree in O(N) time. Should not be<br/>
		/// called often.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2DynamicTree_GetHeight")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int DynamicTreeGetHeight([NativeName(NativeNameType.Param, "tree")] [NativeName(NativeNameType.Type, "const b2DynamicTree*")] ref B2DynamicTree tree)
		{
			fixed (B2DynamicTree* ptree = &tree)
			{
				int ret = DynamicTreeGetHeightNative((B2DynamicTree*)ptree);
				return ret;
			}
		}

		/// <summary>
		/// Get the maximum balance of the tree. The balance is the difference in height of the two children of a node.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2DynamicTree_GetMaxBalance")]
		[return: NativeName(NativeNameType.Type, "int")]
		internal static int DynamicTreeGetMaxBalanceNative([NativeName(NativeNameType.Param, "tree")] [NativeName(NativeNameType.Type, "const b2DynamicTree*")] B2DynamicTree* tree)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<B2DynamicTree*, int>)vt[76])(tree);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, int>)vt[76])((nint)tree);
			#endif
		}

		/// <summary>
		/// Get the maximum balance of the tree. The balance is the difference in height of the two children of a node.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2DynamicTree_GetMaxBalance")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int DynamicTreeGetMaxBalance([NativeName(NativeNameType.Param, "tree")] [NativeName(NativeNameType.Type, "const b2DynamicTree*")] B2DynamicTree* tree)
		{
			int ret = DynamicTreeGetMaxBalanceNative(tree);
			return ret;
		}

		/// <summary>
		/// Get the maximum balance of the tree. The balance is the difference in height of the two children of a node.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2DynamicTree_GetMaxBalance")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int DynamicTreeGetMaxBalance([NativeName(NativeNameType.Param, "tree")] [NativeName(NativeNameType.Type, "const b2DynamicTree*")] ref B2DynamicTree tree)
		{
			fixed (B2DynamicTree* ptree = &tree)
			{
				int ret = DynamicTreeGetMaxBalanceNative((B2DynamicTree*)ptree);
				return ret;
			}
		}

		/// <summary>
		/// Get the ratio of the sum of the node areas to the root area.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2DynamicTree_GetAreaRatio")]
		[return: NativeName(NativeNameType.Type, "float")]
		internal static float DynamicTreeGetAreaRatioNative([NativeName(NativeNameType.Param, "tree")] [NativeName(NativeNameType.Type, "const b2DynamicTree*")] B2DynamicTree* tree)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<B2DynamicTree*, float>)vt[77])(tree);
			#else
			return (float)((delegate* unmanaged[Cdecl]<nint, float>)vt[77])((nint)tree);
			#endif
		}

		/// <summary>
		/// Get the ratio of the sum of the node areas to the root area.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2DynamicTree_GetAreaRatio")]
		[return: NativeName(NativeNameType.Type, "float")]
		public static float DynamicTreeGetAreaRatio([NativeName(NativeNameType.Param, "tree")] [NativeName(NativeNameType.Type, "const b2DynamicTree*")] B2DynamicTree* tree)
		{
			float ret = DynamicTreeGetAreaRatioNative(tree);
			return ret;
		}

		/// <summary>
		/// Get the ratio of the sum of the node areas to the root area.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2DynamicTree_GetAreaRatio")]
		[return: NativeName(NativeNameType.Type, "float")]
		public static float DynamicTreeGetAreaRatio([NativeName(NativeNameType.Param, "tree")] [NativeName(NativeNameType.Type, "const b2DynamicTree*")] ref B2DynamicTree tree)
		{
			fixed (B2DynamicTree* ptree = &tree)
			{
				float ret = DynamicTreeGetAreaRatioNative((B2DynamicTree*)ptree);
				return ret;
			}
		}

		/// <summary>
		/// Build an optimal tree. Very expensive. For testing.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2DynamicTree_RebuildBottomUp")]
		[return: NativeName(NativeNameType.Type, "void")]
		internal static void DynamicTreeRebuildBottomUpNative([NativeName(NativeNameType.Param, "tree")] [NativeName(NativeNameType.Type, "b2DynamicTree*")] B2DynamicTree* tree)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<B2DynamicTree*, void>)vt[78])(tree);
			#else
			((delegate* unmanaged[Cdecl]<nint, void>)vt[78])((nint)tree);
			#endif
		}

		/// <summary>
		/// Build an optimal tree. Very expensive. For testing.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2DynamicTree_RebuildBottomUp")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void DynamicTreeRebuildBottomUp([NativeName(NativeNameType.Param, "tree")] [NativeName(NativeNameType.Type, "b2DynamicTree*")] B2DynamicTree* tree)
		{
			DynamicTreeRebuildBottomUpNative(tree);
		}

		/// <summary>
		/// Build an optimal tree. Very expensive. For testing.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2DynamicTree_RebuildBottomUp")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void DynamicTreeRebuildBottomUp([NativeName(NativeNameType.Param, "tree")] [NativeName(NativeNameType.Type, "b2DynamicTree*")] ref B2DynamicTree tree)
		{
			fixed (B2DynamicTree* ptree = &tree)
			{
				DynamicTreeRebuildBottomUpNative((B2DynamicTree*)ptree);
			}
		}

		/// <summary>
		/// Get the number of proxies created<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2DynamicTree_GetProxyCount")]
		[return: NativeName(NativeNameType.Type, "int")]
		internal static int DynamicTreeGetProxyCountNative([NativeName(NativeNameType.Param, "tree")] [NativeName(NativeNameType.Type, "const b2DynamicTree*")] B2DynamicTree* tree)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<B2DynamicTree*, int>)vt[79])(tree);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, int>)vt[79])((nint)tree);
			#endif
		}

		/// <summary>
		/// Get the number of proxies created<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2DynamicTree_GetProxyCount")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int DynamicTreeGetProxyCount([NativeName(NativeNameType.Param, "tree")] [NativeName(NativeNameType.Type, "const b2DynamicTree*")] B2DynamicTree* tree)
		{
			int ret = DynamicTreeGetProxyCountNative(tree);
			return ret;
		}

		/// <summary>
		/// Get the number of proxies created<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2DynamicTree_GetProxyCount")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int DynamicTreeGetProxyCount([NativeName(NativeNameType.Param, "tree")] [NativeName(NativeNameType.Type, "const b2DynamicTree*")] ref B2DynamicTree tree)
		{
			fixed (B2DynamicTree* ptree = &tree)
			{
				int ret = DynamicTreeGetProxyCountNative((B2DynamicTree*)ptree);
				return ret;
			}
		}

		/// <summary>
		/// Rebuild the tree while retaining subtrees that haven't changed. Returns the number of boxes sorted.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2DynamicTree_Rebuild")]
		[return: NativeName(NativeNameType.Type, "int")]
		internal static int DynamicTreeRebuildNative([NativeName(NativeNameType.Param, "tree")] [NativeName(NativeNameType.Type, "b2DynamicTree*")] B2DynamicTree* tree, [NativeName(NativeNameType.Param, "fullBuild")] [NativeName(NativeNameType.Type, "bool")] byte fullBuild)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<B2DynamicTree*, byte, int>)vt[80])(tree, fullBuild);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, byte, int>)vt[80])((nint)tree, fullBuild);
			#endif
		}

		/// <summary>
		/// Rebuild the tree while retaining subtrees that haven't changed. Returns the number of boxes sorted.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2DynamicTree_Rebuild")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int DynamicTreeRebuild([NativeName(NativeNameType.Param, "tree")] [NativeName(NativeNameType.Type, "b2DynamicTree*")] B2DynamicTree* tree, [NativeName(NativeNameType.Param, "fullBuild")] [NativeName(NativeNameType.Type, "bool")] bool fullBuild)
		{
			int ret = DynamicTreeRebuildNative(tree, fullBuild ? (byte)1 : (byte)0);
			return ret;
		}

		/// <summary>
		/// Rebuild the tree while retaining subtrees that haven't changed. Returns the number of boxes sorted.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2DynamicTree_Rebuild")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int DynamicTreeRebuild([NativeName(NativeNameType.Param, "tree")] [NativeName(NativeNameType.Type, "b2DynamicTree*")] ref B2DynamicTree tree, [NativeName(NativeNameType.Param, "fullBuild")] [NativeName(NativeNameType.Type, "bool")] bool fullBuild)
		{
			fixed (B2DynamicTree* ptree = &tree)
			{
				int ret = DynamicTreeRebuildNative((B2DynamicTree*)ptree, fullBuild ? (byte)1 : (byte)0);
				return ret;
			}
		}

		/// <summary>
		/// Shift the world origin. Useful for large worlds.<br/>
		/// The shift formula is: position -= newOrigin<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2DynamicTree_ShiftOrigin")]
		[return: NativeName(NativeNameType.Type, "void")]
		internal static void DynamicTreeShiftOriginNative([NativeName(NativeNameType.Param, "tree")] [NativeName(NativeNameType.Type, "b2DynamicTree*")] B2DynamicTree* tree, [NativeName(NativeNameType.Param, "newOrigin")] [NativeName(NativeNameType.Type, "b2Vec2")] Vector2 newOrigin)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<B2DynamicTree*, Vector2, void>)vt[81])(tree, newOrigin);
			#else
			((delegate* unmanaged[Cdecl]<nint, Vector2, void>)vt[81])((nint)tree, newOrigin);
			#endif
		}

		/// <summary>
		/// Shift the world origin. Useful for large worlds.<br/>
		/// The shift formula is: position -= newOrigin<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2DynamicTree_ShiftOrigin")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void DynamicTreeShiftOrigin([NativeName(NativeNameType.Param, "tree")] [NativeName(NativeNameType.Type, "b2DynamicTree*")] B2DynamicTree* tree, [NativeName(NativeNameType.Param, "newOrigin")] [NativeName(NativeNameType.Type, "b2Vec2")] Vector2 newOrigin)
		{
			DynamicTreeShiftOriginNative(tree, newOrigin);
		}

		/// <summary>
		/// Shift the world origin. Useful for large worlds.<br/>
		/// The shift formula is: position -= newOrigin<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2DynamicTree_ShiftOrigin")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void DynamicTreeShiftOrigin([NativeName(NativeNameType.Param, "tree")] [NativeName(NativeNameType.Type, "b2DynamicTree*")] ref B2DynamicTree tree, [NativeName(NativeNameType.Param, "newOrigin")] [NativeName(NativeNameType.Type, "b2Vec2")] Vector2 newOrigin)
		{
			fixed (B2DynamicTree* ptree = &tree)
			{
				DynamicTreeShiftOriginNative((B2DynamicTree*)ptree, newOrigin);
			}
		}

		/// <summary>
		/// Get the number of bytes used by this tree<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2DynamicTree_GetByteCount")]
		[return: NativeName(NativeNameType.Type, "int")]
		internal static int DynamicTreeGetByteCountNative([NativeName(NativeNameType.Param, "tree")] [NativeName(NativeNameType.Type, "const b2DynamicTree*")] B2DynamicTree* tree)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<B2DynamicTree*, int>)vt[82])(tree);
			#else
			return (int)((delegate* unmanaged[Cdecl]<nint, int>)vt[82])((nint)tree);
			#endif
		}

		/// <summary>
		/// Get the number of bytes used by this tree<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2DynamicTree_GetByteCount")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int DynamicTreeGetByteCount([NativeName(NativeNameType.Param, "tree")] [NativeName(NativeNameType.Type, "const b2DynamicTree*")] B2DynamicTree* tree)
		{
			int ret = DynamicTreeGetByteCountNative(tree);
			return ret;
		}

		/// <summary>
		/// Get the number of bytes used by this tree<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2DynamicTree_GetByteCount")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int DynamicTreeGetByteCount([NativeName(NativeNameType.Param, "tree")] [NativeName(NativeNameType.Type, "const b2DynamicTree*")] ref B2DynamicTree tree)
		{
			fixed (B2DynamicTree* ptree = &tree)
			{
				int ret = DynamicTreeGetByteCountNative((B2DynamicTree*)ptree);
				return ret;
			}
		}

		/// <summary>
		/// Use this to initialize your world definition<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2DefaultWorldDef")]
		[return: NativeName(NativeNameType.Type, "b2WorldDef")]
		internal static B2WorldDef DefaultWorldDefNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<B2WorldDef>)vt[83])();
			#else
			return (B2WorldDef)((delegate* unmanaged[Cdecl]<B2WorldDef>)vt[83])();
			#endif
		}

		/// <summary>
		/// Use this to initialize your world definition<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2DefaultWorldDef")]
		[return: NativeName(NativeNameType.Type, "b2WorldDef")]
		public static B2WorldDef DefaultWorldDef()
		{
			B2WorldDef ret = DefaultWorldDefNative();
			return ret;
		}

		/// <summary>
		/// Use this to initialize your body definition<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2DefaultBodyDef")]
		[return: NativeName(NativeNameType.Type, "b2BodyDef")]
		internal static B2BodyDef DefaultBodyDefNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<B2BodyDef>)vt[84])();
			#else
			return (B2BodyDef)((delegate* unmanaged[Cdecl]<B2BodyDef>)vt[84])();
			#endif
		}

		/// <summary>
		/// Use this to initialize your body definition<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2DefaultBodyDef")]
		[return: NativeName(NativeNameType.Type, "b2BodyDef")]
		public static B2BodyDef DefaultBodyDef()
		{
			B2BodyDef ret = DefaultBodyDefNative();
			return ret;
		}

		/// <summary>
		/// Use this to initialize your filter<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2DefaultFilter")]
		[return: NativeName(NativeNameType.Type, "b2Filter")]
		internal static B2Filter DefaultFilterNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<B2Filter>)vt[85])();
			#else
			return (B2Filter)((delegate* unmanaged[Cdecl]<B2Filter>)vt[85])();
			#endif
		}

		/// <summary>
		/// Use this to initialize your filter<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2DefaultFilter")]
		[return: NativeName(NativeNameType.Type, "b2Filter")]
		public static B2Filter DefaultFilter()
		{
			B2Filter ret = DefaultFilterNative();
			return ret;
		}

		/// <summary>
		/// Use this to initialize your query filter<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2DefaultQueryFilter")]
		[return: NativeName(NativeNameType.Type, "b2QueryFilter")]
		internal static B2QueryFilter DefaultQueryFilterNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<B2QueryFilter>)vt[86])();
			#else
			return (B2QueryFilter)((delegate* unmanaged[Cdecl]<B2QueryFilter>)vt[86])();
			#endif
		}

		/// <summary>
		/// Use this to initialize your query filter<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2DefaultQueryFilter")]
		[return: NativeName(NativeNameType.Type, "b2QueryFilter")]
		public static B2QueryFilter DefaultQueryFilter()
		{
			B2QueryFilter ret = DefaultQueryFilterNative();
			return ret;
		}

		/// <summary>
		/// Use this to initialize your shape definition<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2DefaultShapeDef")]
		[return: NativeName(NativeNameType.Type, "b2ShapeDef")]
		internal static B2ShapeDef DefaultShapeDefNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<B2ShapeDef>)vt[87])();
			#else
			return (B2ShapeDef)((delegate* unmanaged[Cdecl]<B2ShapeDef>)vt[87])();
			#endif
		}

		/// <summary>
		/// Use this to initialize your shape definition<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2DefaultShapeDef")]
		[return: NativeName(NativeNameType.Type, "b2ShapeDef")]
		public static B2ShapeDef DefaultShapeDef()
		{
			B2ShapeDef ret = DefaultShapeDefNative();
			return ret;
		}

		/// <summary>
		/// Use this to initialize your chain definition<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2DefaultChainDef")]
		[return: NativeName(NativeNameType.Type, "b2ChainDef")]
		internal static B2ChainDef DefaultChainDefNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<B2ChainDef>)vt[88])();
			#else
			return (B2ChainDef)((delegate* unmanaged[Cdecl]<B2ChainDef>)vt[88])();
			#endif
		}

		/// <summary>
		/// Use this to initialize your chain definition<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2DefaultChainDef")]
		[return: NativeName(NativeNameType.Type, "b2ChainDef")]
		public static B2ChainDef DefaultChainDef()
		{
			B2ChainDef ret = DefaultChainDefNative();
			return ret;
		}

		/// <summary>
		/// Use this to initialize your joint definition<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2DefaultDistanceJointDef")]
		[return: NativeName(NativeNameType.Type, "b2DistanceJointDef")]
		internal static B2DistanceJointDef DefaultDistanceJointDefNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<B2DistanceJointDef>)vt[89])();
			#else
			return (B2DistanceJointDef)((delegate* unmanaged[Cdecl]<B2DistanceJointDef>)vt[89])();
			#endif
		}

		/// <summary>
		/// Use this to initialize your joint definition<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2DefaultDistanceJointDef")]
		[return: NativeName(NativeNameType.Type, "b2DistanceJointDef")]
		public static B2DistanceJointDef DefaultDistanceJointDef()
		{
			B2DistanceJointDef ret = DefaultDistanceJointDefNative();
			return ret;
		}

		/// <summary>
		/// Use this to initialize your joint definition<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2DefaultMotorJointDef")]
		[return: NativeName(NativeNameType.Type, "b2MotorJointDef")]
		internal static B2MotorJointDef DefaultMotorJointDefNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<B2MotorJointDef>)vt[90])();
			#else
			return (B2MotorJointDef)((delegate* unmanaged[Cdecl]<B2MotorJointDef>)vt[90])();
			#endif
		}

		/// <summary>
		/// Use this to initialize your joint definition<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2DefaultMotorJointDef")]
		[return: NativeName(NativeNameType.Type, "b2MotorJointDef")]
		public static B2MotorJointDef DefaultMotorJointDef()
		{
			B2MotorJointDef ret = DefaultMotorJointDefNative();
			return ret;
		}

		/// <summary>
		/// Use this to initialize your joint definition<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2DefaultMouseJointDef")]
		[return: NativeName(NativeNameType.Type, "b2MouseJointDef")]
		internal static B2MouseJointDef DefaultMouseJointDefNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<B2MouseJointDef>)vt[91])();
			#else
			return (B2MouseJointDef)((delegate* unmanaged[Cdecl]<B2MouseJointDef>)vt[91])();
			#endif
		}

		/// <summary>
		/// Use this to initialize your joint definition<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2DefaultMouseJointDef")]
		[return: NativeName(NativeNameType.Type, "b2MouseJointDef")]
		public static B2MouseJointDef DefaultMouseJointDef()
		{
			B2MouseJointDef ret = DefaultMouseJointDefNative();
			return ret;
		}

		/// <summary>
		/// Use this to initialize your joint definition<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2DefaultPrismaticJointDef")]
		[return: NativeName(NativeNameType.Type, "b2PrismaticJointDef")]
		internal static B2PrismaticJointDef DefaultPrismaticJointDefNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<B2PrismaticJointDef>)vt[92])();
			#else
			return (B2PrismaticJointDef)((delegate* unmanaged[Cdecl]<B2PrismaticJointDef>)vt[92])();
			#endif
		}

		/// <summary>
		/// Use this to initialize your joint definition<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2DefaultPrismaticJointDef")]
		[return: NativeName(NativeNameType.Type, "b2PrismaticJointDef")]
		public static B2PrismaticJointDef DefaultPrismaticJointDef()
		{
			B2PrismaticJointDef ret = DefaultPrismaticJointDefNative();
			return ret;
		}

		/// <summary>
		/// Use this to initialize your joint definition.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2DefaultRevoluteJointDef")]
		[return: NativeName(NativeNameType.Type, "b2RevoluteJointDef")]
		internal static B2RevoluteJointDef DefaultRevoluteJointDefNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<B2RevoluteJointDef>)vt[93])();
			#else
			return (B2RevoluteJointDef)((delegate* unmanaged[Cdecl]<B2RevoluteJointDef>)vt[93])();
			#endif
		}

		/// <summary>
		/// Use this to initialize your joint definition.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2DefaultRevoluteJointDef")]
		[return: NativeName(NativeNameType.Type, "b2RevoluteJointDef")]
		public static B2RevoluteJointDef DefaultRevoluteJointDef()
		{
			B2RevoluteJointDef ret = DefaultRevoluteJointDefNative();
			return ret;
		}

		/// <summary>
		/// Use this to initialize your joint definition<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2DefaultWeldJointDef")]
		[return: NativeName(NativeNameType.Type, "b2WeldJointDef")]
		internal static B2WeldJointDef DefaultWeldJointDefNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<B2WeldJointDef>)vt[94])();
			#else
			return (B2WeldJointDef)((delegate* unmanaged[Cdecl]<B2WeldJointDef>)vt[94])();
			#endif
		}

		/// <summary>
		/// Use this to initialize your joint definition<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2DefaultWeldJointDef")]
		[return: NativeName(NativeNameType.Type, "b2WeldJointDef")]
		public static B2WeldJointDef DefaultWeldJointDef()
		{
			B2WeldJointDef ret = DefaultWeldJointDefNative();
			return ret;
		}

		/// <summary>
		/// Use this to initialize your joint definition<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2DefaultWheelJointDef")]
		[return: NativeName(NativeNameType.Type, "b2WheelJointDef")]
		internal static B2WheelJointDef DefaultWheelJointDefNative()
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<B2WheelJointDef>)vt[95])();
			#else
			return (B2WheelJointDef)((delegate* unmanaged[Cdecl]<B2WheelJointDef>)vt[95])();
			#endif
		}

		/// <summary>
		/// Use this to initialize your joint definition<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2DefaultWheelJointDef")]
		[return: NativeName(NativeNameType.Type, "b2WheelJointDef")]
		public static B2WheelJointDef DefaultWheelJointDef()
		{
			B2WheelJointDef ret = DefaultWheelJointDefNative();
			return ret;
		}

		/// <summary>
		/// Create a world for rigid body simulation. A world contains bodies, shapes, and constraints. You make create<br/>
		/// up to 128 worlds. Each world is completely independent and may be simulated in parallel.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2CreateWorld")]
		[return: NativeName(NativeNameType.Type, "b2WorldId")]
		internal static B2WorldId CreateWorldNative([NativeName(NativeNameType.Param, "def")] [NativeName(NativeNameType.Type, "const b2WorldDef*")] B2WorldDef* def)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<B2WorldDef*, B2WorldId>)vt[96])(def);
			#else
			return (B2WorldId)((delegate* unmanaged[Cdecl]<nint, B2WorldId>)vt[96])((nint)def);
			#endif
		}

		/// <summary>
		/// Create a world for rigid body simulation. A world contains bodies, shapes, and constraints. You make create<br/>
		/// up to 128 worlds. Each world is completely independent and may be simulated in parallel.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2CreateWorld")]
		[return: NativeName(NativeNameType.Type, "b2WorldId")]
		public static B2WorldId CreateWorld([NativeName(NativeNameType.Param, "def")] [NativeName(NativeNameType.Type, "const b2WorldDef*")] B2WorldDef* def)
		{
			B2WorldId ret = CreateWorldNative(def);
			return ret;
		}

		/// <summary>
		/// Create a world for rigid body simulation. A world contains bodies, shapes, and constraints. You make create<br/>
		/// up to 128 worlds. Each world is completely independent and may be simulated in parallel.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2CreateWorld")]
		[return: NativeName(NativeNameType.Type, "b2WorldId")]
		public static B2WorldId CreateWorld([NativeName(NativeNameType.Param, "def")] [NativeName(NativeNameType.Type, "const b2WorldDef*")] ref B2WorldDef def)
		{
			fixed (B2WorldDef* pdef = &def)
			{
				B2WorldId ret = CreateWorldNative((B2WorldDef*)pdef);
				return ret;
			}
		}

		/// <summary>
		/// Destroy a world<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2DestroyWorld")]
		[return: NativeName(NativeNameType.Type, "void")]
		internal static void DestroyWorldNative([NativeName(NativeNameType.Param, "worldId")] [NativeName(NativeNameType.Type, "b2WorldId")] B2WorldId worldId)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<B2WorldId, void>)vt[97])(worldId);
			#else
			((delegate* unmanaged[Cdecl]<B2WorldId, void>)vt[97])(worldId);
			#endif
		}

		/// <summary>
		/// Destroy a world<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2DestroyWorld")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void DestroyWorld([NativeName(NativeNameType.Param, "worldId")] [NativeName(NativeNameType.Type, "b2WorldId")] B2WorldId worldId)
		{
			DestroyWorldNative(worldId);
		}

		/// <summary>
		/// World id validation. Provides validation for up to 64K allocations.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2World_IsValid")]
		[return: NativeName(NativeNameType.Type, "bool")]
		internal static byte WorldIsValidNative([NativeName(NativeNameType.Param, "id")] [NativeName(NativeNameType.Type, "b2WorldId")] B2WorldId id)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<B2WorldId, byte>)vt[98])(id);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<B2WorldId, byte>)vt[98])(id);
			#endif
		}

		/// <summary>
		/// World id validation. Provides validation for up to 64K allocations.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2World_IsValid")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool WorldIsValid([NativeName(NativeNameType.Param, "id")] [NativeName(NativeNameType.Type, "b2WorldId")] B2WorldId id)
		{
			byte ret = WorldIsValidNative(id);
			return ret != 0;
		}

		/// <summary>
		/// Simulate a world for one time step. This performs collision detection, integration, and constraint solution.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2World_Step")]
		[return: NativeName(NativeNameType.Type, "void")]
		internal static void WorldStepNative([NativeName(NativeNameType.Param, "worldId")] [NativeName(NativeNameType.Type, "b2WorldId")] B2WorldId worldId, [NativeName(NativeNameType.Param, "timeStep")] [NativeName(NativeNameType.Type, "float")] float timeStep, [NativeName(NativeNameType.Param, "subStepCount")] [NativeName(NativeNameType.Type, "int")] int subStepCount)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<B2WorldId, float, int, void>)vt[99])(worldId, timeStep, subStepCount);
			#else
			((delegate* unmanaged[Cdecl]<B2WorldId, float, int, void>)vt[99])(worldId, timeStep, subStepCount);
			#endif
		}

		/// <summary>
		/// Simulate a world for one time step. This performs collision detection, integration, and constraint solution.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2World_Step")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void WorldStep([NativeName(NativeNameType.Param, "worldId")] [NativeName(NativeNameType.Type, "b2WorldId")] B2WorldId worldId, [NativeName(NativeNameType.Param, "timeStep")] [NativeName(NativeNameType.Type, "float")] float timeStep, [NativeName(NativeNameType.Param, "subStepCount")] [NativeName(NativeNameType.Type, "int")] int subStepCount)
		{
			WorldStepNative(worldId, timeStep, subStepCount);
		}

		/// <summary>
		/// Call this to draw shapes and other debug draw data<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2World_Draw")]
		[return: NativeName(NativeNameType.Type, "void")]
		internal static void WorldDrawNative([NativeName(NativeNameType.Param, "worldId")] [NativeName(NativeNameType.Type, "b2WorldId")] B2WorldId worldId, [NativeName(NativeNameType.Param, "draw")] [NativeName(NativeNameType.Type, "b2DebugDraw*")] B2DebugDraw* draw)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<B2WorldId, B2DebugDraw*, void>)vt[100])(worldId, draw);
			#else
			((delegate* unmanaged[Cdecl]<B2WorldId, nint, void>)vt[100])(worldId, (nint)draw);
			#endif
		}

		/// <summary>
		/// Call this to draw shapes and other debug draw data<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2World_Draw")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void WorldDraw([NativeName(NativeNameType.Param, "worldId")] [NativeName(NativeNameType.Type, "b2WorldId")] B2WorldId worldId, [NativeName(NativeNameType.Param, "draw")] [NativeName(NativeNameType.Type, "b2DebugDraw*")] B2DebugDraw* draw)
		{
			WorldDrawNative(worldId, draw);
		}

		/// <summary>
		/// Call this to draw shapes and other debug draw data<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2World_Draw")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void WorldDraw([NativeName(NativeNameType.Param, "worldId")] [NativeName(NativeNameType.Type, "b2WorldId")] B2WorldId worldId, [NativeName(NativeNameType.Param, "draw")] [NativeName(NativeNameType.Type, "b2DebugDraw*")] ref B2DebugDraw draw)
		{
			fixed (B2DebugDraw* pdraw = &draw)
			{
				WorldDrawNative(worldId, (B2DebugDraw*)pdraw);
			}
		}

		/// <summary>
		/// Get the body events for the current time step. The event data is transient. Do not store a reference to this data.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2World_GetBodyEvents")]
		[return: NativeName(NativeNameType.Type, "b2BodyEvents")]
		internal static B2BodyEvents WorldGetBodyEventsNative([NativeName(NativeNameType.Param, "worldId")] [NativeName(NativeNameType.Type, "b2WorldId")] B2WorldId worldId)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<B2WorldId, B2BodyEvents>)vt[101])(worldId);
			#else
			return (B2BodyEvents)((delegate* unmanaged[Cdecl]<B2WorldId, B2BodyEvents>)vt[101])(worldId);
			#endif
		}

		/// <summary>
		/// Get the body events for the current time step. The event data is transient. Do not store a reference to this data.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2World_GetBodyEvents")]
		[return: NativeName(NativeNameType.Type, "b2BodyEvents")]
		public static B2BodyEvents WorldGetBodyEvents([NativeName(NativeNameType.Param, "worldId")] [NativeName(NativeNameType.Type, "b2WorldId")] B2WorldId worldId)
		{
			B2BodyEvents ret = WorldGetBodyEventsNative(worldId);
			return ret;
		}

		/// <summary>
		/// Get sensor events for the current time step. The event data is transient. Do not store a reference to this data.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2World_GetSensorEvents")]
		[return: NativeName(NativeNameType.Type, "b2SensorEvents")]
		internal static B2SensorEvents WorldGetSensorEventsNative([NativeName(NativeNameType.Param, "worldId")] [NativeName(NativeNameType.Type, "b2WorldId")] B2WorldId worldId)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<B2WorldId, B2SensorEvents>)vt[102])(worldId);
			#else
			return (B2SensorEvents)((delegate* unmanaged[Cdecl]<B2WorldId, B2SensorEvents>)vt[102])(worldId);
			#endif
		}

		/// <summary>
		/// Get sensor events for the current time step. The event data is transient. Do not store a reference to this data.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2World_GetSensorEvents")]
		[return: NativeName(NativeNameType.Type, "b2SensorEvents")]
		public static B2SensorEvents WorldGetSensorEvents([NativeName(NativeNameType.Param, "worldId")] [NativeName(NativeNameType.Type, "b2WorldId")] B2WorldId worldId)
		{
			B2SensorEvents ret = WorldGetSensorEventsNative(worldId);
			return ret;
		}

		/// <summary>
		/// Get contact events for this current time step. The event data is transient. Do not store a reference to this data.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2World_GetContactEvents")]
		[return: NativeName(NativeNameType.Type, "b2ContactEvents")]
		internal static B2ContactEvents WorldGetContactEventsNative([NativeName(NativeNameType.Param, "worldId")] [NativeName(NativeNameType.Type, "b2WorldId")] B2WorldId worldId)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<B2WorldId, B2ContactEvents>)vt[103])(worldId);
			#else
			return (B2ContactEvents)((delegate* unmanaged[Cdecl]<B2WorldId, B2ContactEvents>)vt[103])(worldId);
			#endif
		}

		/// <summary>
		/// Get contact events for this current time step. The event data is transient. Do not store a reference to this data.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2World_GetContactEvents")]
		[return: NativeName(NativeNameType.Type, "b2ContactEvents")]
		public static B2ContactEvents WorldGetContactEvents([NativeName(NativeNameType.Param, "worldId")] [NativeName(NativeNameType.Type, "b2WorldId")] B2WorldId worldId)
		{
			B2ContactEvents ret = WorldGetContactEventsNative(worldId);
			return ret;
		}

		/// <summary>
		/// Overlap test for all shapes that *potentially* overlap the provided AABB<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2World_OverlapAABB")]
		[return: NativeName(NativeNameType.Type, "void")]
		internal static void WorldOverlapAABBNative([NativeName(NativeNameType.Param, "worldId")] [NativeName(NativeNameType.Type, "b2WorldId")] B2WorldId worldId, [NativeName(NativeNameType.Param, "aabb")] [NativeName(NativeNameType.Type, "b2AABB")] B2AABB aabb, [NativeName(NativeNameType.Param, "filter")] [NativeName(NativeNameType.Type, "b2QueryFilter")] B2QueryFilter filter, [NativeName(NativeNameType.Param, "fcn")] [NativeName(NativeNameType.Type, "b2OverlapResultFcn*")] delegate*<B2ShapeId, void*, bool>* fcn, [NativeName(NativeNameType.Param, "context")] [NativeName(NativeNameType.Type, "void*")] void* context)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<B2WorldId, B2AABB, B2QueryFilter, delegate*<B2ShapeId, void*, bool>*, void*, void>)vt[104])(worldId, aabb, filter, fcn, context);
			#else
			((delegate* unmanaged[Cdecl]<B2WorldId, B2AABB, B2QueryFilter, nint, nint, void>)vt[104])(worldId, aabb, filter, (nint)fcn, (nint)context);
			#endif
		}

		/// <summary>
		/// Overlap test for all shapes that *potentially* overlap the provided AABB<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2World_OverlapAABB")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void WorldOverlapAABB([NativeName(NativeNameType.Param, "worldId")] [NativeName(NativeNameType.Type, "b2WorldId")] B2WorldId worldId, [NativeName(NativeNameType.Param, "aabb")] [NativeName(NativeNameType.Type, "b2AABB")] B2AABB aabb, [NativeName(NativeNameType.Param, "filter")] [NativeName(NativeNameType.Type, "b2QueryFilter")] B2QueryFilter filter, [NativeName(NativeNameType.Param, "fcn")] [NativeName(NativeNameType.Type, "b2OverlapResultFcn*")] delegate*<B2ShapeId, void*, bool>* fcn, [NativeName(NativeNameType.Param, "context")] [NativeName(NativeNameType.Type, "void*")] void* context)
		{
			WorldOverlapAABBNative(worldId, aabb, filter, fcn, context);
		}

		/// <summary>
		/// Overlap test for for all shapes that overlap the provided circle<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2World_OverlapCircle")]
		[return: NativeName(NativeNameType.Type, "void")]
		internal static void WorldOverlapCircleNative([NativeName(NativeNameType.Param, "worldId")] [NativeName(NativeNameType.Type, "b2WorldId")] B2WorldId worldId, [NativeName(NativeNameType.Param, "circle")] [NativeName(NativeNameType.Type, "const b2Circle*")] B2Circle* circle, [NativeName(NativeNameType.Param, "transform")] [NativeName(NativeNameType.Type, "b2Transform")] B2Transform transform, [NativeName(NativeNameType.Param, "filter")] [NativeName(NativeNameType.Type, "b2QueryFilter")] B2QueryFilter filter, [NativeName(NativeNameType.Param, "fcn")] [NativeName(NativeNameType.Type, "b2OverlapResultFcn*")] delegate*<B2ShapeId, void*, bool>* fcn, [NativeName(NativeNameType.Param, "context")] [NativeName(NativeNameType.Type, "void*")] void* context)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<B2WorldId, B2Circle*, B2Transform, B2QueryFilter, delegate*<B2ShapeId, void*, bool>*, void*, void>)vt[105])(worldId, circle, transform, filter, fcn, context);
			#else
			((delegate* unmanaged[Cdecl]<B2WorldId, nint, B2Transform, B2QueryFilter, nint, nint, void>)vt[105])(worldId, (nint)circle, transform, filter, (nint)fcn, (nint)context);
			#endif
		}

		/// <summary>
		/// Overlap test for for all shapes that overlap the provided circle<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2World_OverlapCircle")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void WorldOverlapCircle([NativeName(NativeNameType.Param, "worldId")] [NativeName(NativeNameType.Type, "b2WorldId")] B2WorldId worldId, [NativeName(NativeNameType.Param, "circle")] [NativeName(NativeNameType.Type, "const b2Circle*")] B2Circle* circle, [NativeName(NativeNameType.Param, "transform")] [NativeName(NativeNameType.Type, "b2Transform")] B2Transform transform, [NativeName(NativeNameType.Param, "filter")] [NativeName(NativeNameType.Type, "b2QueryFilter")] B2QueryFilter filter, [NativeName(NativeNameType.Param, "fcn")] [NativeName(NativeNameType.Type, "b2OverlapResultFcn*")] delegate*<B2ShapeId, void*, bool>* fcn, [NativeName(NativeNameType.Param, "context")] [NativeName(NativeNameType.Type, "void*")] void* context)
		{
			WorldOverlapCircleNative(worldId, circle, transform, filter, fcn, context);
		}

		/// <summary>
		/// Overlap test for for all shapes that overlap the provided circle<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2World_OverlapCircle")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void WorldOverlapCircle([NativeName(NativeNameType.Param, "worldId")] [NativeName(NativeNameType.Type, "b2WorldId")] B2WorldId worldId, [NativeName(NativeNameType.Param, "circle")] [NativeName(NativeNameType.Type, "const b2Circle*")] ref B2Circle circle, [NativeName(NativeNameType.Param, "transform")] [NativeName(NativeNameType.Type, "b2Transform")] B2Transform transform, [NativeName(NativeNameType.Param, "filter")] [NativeName(NativeNameType.Type, "b2QueryFilter")] B2QueryFilter filter, [NativeName(NativeNameType.Param, "fcn")] [NativeName(NativeNameType.Type, "b2OverlapResultFcn*")] delegate*<B2ShapeId, void*, bool>* fcn, [NativeName(NativeNameType.Param, "context")] [NativeName(NativeNameType.Type, "void*")] void* context)
		{
			fixed (B2Circle* pcircle = &circle)
			{
				WorldOverlapCircleNative(worldId, (B2Circle*)pcircle, transform, filter, fcn, context);
			}
		}

		/// <summary>
		/// Overlap test for all shapes that overlap the provided capsule<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2World_OverlapCapsule")]
		[return: NativeName(NativeNameType.Type, "void")]
		internal static void WorldOverlapCapsuleNative([NativeName(NativeNameType.Param, "worldId")] [NativeName(NativeNameType.Type, "b2WorldId")] B2WorldId worldId, [NativeName(NativeNameType.Param, "capsule")] [NativeName(NativeNameType.Type, "const b2Capsule*")] B2Capsule* capsule, [NativeName(NativeNameType.Param, "transform")] [NativeName(NativeNameType.Type, "b2Transform")] B2Transform transform, [NativeName(NativeNameType.Param, "filter")] [NativeName(NativeNameType.Type, "b2QueryFilter")] B2QueryFilter filter, [NativeName(NativeNameType.Param, "fcn")] [NativeName(NativeNameType.Type, "b2OverlapResultFcn*")] delegate*<B2ShapeId, void*, bool>* fcn, [NativeName(NativeNameType.Param, "context")] [NativeName(NativeNameType.Type, "void*")] void* context)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<B2WorldId, B2Capsule*, B2Transform, B2QueryFilter, delegate*<B2ShapeId, void*, bool>*, void*, void>)vt[106])(worldId, capsule, transform, filter, fcn, context);
			#else
			((delegate* unmanaged[Cdecl]<B2WorldId, nint, B2Transform, B2QueryFilter, nint, nint, void>)vt[106])(worldId, (nint)capsule, transform, filter, (nint)fcn, (nint)context);
			#endif
		}

		/// <summary>
		/// Overlap test for all shapes that overlap the provided capsule<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2World_OverlapCapsule")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void WorldOverlapCapsule([NativeName(NativeNameType.Param, "worldId")] [NativeName(NativeNameType.Type, "b2WorldId")] B2WorldId worldId, [NativeName(NativeNameType.Param, "capsule")] [NativeName(NativeNameType.Type, "const b2Capsule*")] B2Capsule* capsule, [NativeName(NativeNameType.Param, "transform")] [NativeName(NativeNameType.Type, "b2Transform")] B2Transform transform, [NativeName(NativeNameType.Param, "filter")] [NativeName(NativeNameType.Type, "b2QueryFilter")] B2QueryFilter filter, [NativeName(NativeNameType.Param, "fcn")] [NativeName(NativeNameType.Type, "b2OverlapResultFcn*")] delegate*<B2ShapeId, void*, bool>* fcn, [NativeName(NativeNameType.Param, "context")] [NativeName(NativeNameType.Type, "void*")] void* context)
		{
			WorldOverlapCapsuleNative(worldId, capsule, transform, filter, fcn, context);
		}

		/// <summary>
		/// Overlap test for all shapes that overlap the provided capsule<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2World_OverlapCapsule")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void WorldOverlapCapsule([NativeName(NativeNameType.Param, "worldId")] [NativeName(NativeNameType.Type, "b2WorldId")] B2WorldId worldId, [NativeName(NativeNameType.Param, "capsule")] [NativeName(NativeNameType.Type, "const b2Capsule*")] ref B2Capsule capsule, [NativeName(NativeNameType.Param, "transform")] [NativeName(NativeNameType.Type, "b2Transform")] B2Transform transform, [NativeName(NativeNameType.Param, "filter")] [NativeName(NativeNameType.Type, "b2QueryFilter")] B2QueryFilter filter, [NativeName(NativeNameType.Param, "fcn")] [NativeName(NativeNameType.Type, "b2OverlapResultFcn*")] delegate*<B2ShapeId, void*, bool>* fcn, [NativeName(NativeNameType.Param, "context")] [NativeName(NativeNameType.Type, "void*")] void* context)
		{
			fixed (B2Capsule* pcapsule = &capsule)
			{
				WorldOverlapCapsuleNative(worldId, (B2Capsule*)pcapsule, transform, filter, fcn, context);
			}
		}

		/// <summary>
		/// Overlap test for all shapes that overlap the provided polygon<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2World_OverlapPolygon")]
		[return: NativeName(NativeNameType.Type, "void")]
		internal static void WorldOverlapPolygonNative([NativeName(NativeNameType.Param, "worldId")] [NativeName(NativeNameType.Type, "b2WorldId")] B2WorldId worldId, [NativeName(NativeNameType.Param, "polygon")] [NativeName(NativeNameType.Type, "const b2Polygon*")] B2Polygon* polygon, [NativeName(NativeNameType.Param, "transform")] [NativeName(NativeNameType.Type, "b2Transform")] B2Transform transform, [NativeName(NativeNameType.Param, "filter")] [NativeName(NativeNameType.Type, "b2QueryFilter")] B2QueryFilter filter, [NativeName(NativeNameType.Param, "fcn")] [NativeName(NativeNameType.Type, "b2OverlapResultFcn*")] delegate*<B2ShapeId, void*, bool>* fcn, [NativeName(NativeNameType.Param, "context")] [NativeName(NativeNameType.Type, "void*")] void* context)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<B2WorldId, B2Polygon*, B2Transform, B2QueryFilter, delegate*<B2ShapeId, void*, bool>*, void*, void>)vt[107])(worldId, polygon, transform, filter, fcn, context);
			#else
			((delegate* unmanaged[Cdecl]<B2WorldId, nint, B2Transform, B2QueryFilter, nint, nint, void>)vt[107])(worldId, (nint)polygon, transform, filter, (nint)fcn, (nint)context);
			#endif
		}

		/// <summary>
		/// Overlap test for all shapes that overlap the provided polygon<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2World_OverlapPolygon")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void WorldOverlapPolygon([NativeName(NativeNameType.Param, "worldId")] [NativeName(NativeNameType.Type, "b2WorldId")] B2WorldId worldId, [NativeName(NativeNameType.Param, "polygon")] [NativeName(NativeNameType.Type, "const b2Polygon*")] B2Polygon* polygon, [NativeName(NativeNameType.Param, "transform")] [NativeName(NativeNameType.Type, "b2Transform")] B2Transform transform, [NativeName(NativeNameType.Param, "filter")] [NativeName(NativeNameType.Type, "b2QueryFilter")] B2QueryFilter filter, [NativeName(NativeNameType.Param, "fcn")] [NativeName(NativeNameType.Type, "b2OverlapResultFcn*")] delegate*<B2ShapeId, void*, bool>* fcn, [NativeName(NativeNameType.Param, "context")] [NativeName(NativeNameType.Type, "void*")] void* context)
		{
			WorldOverlapPolygonNative(worldId, polygon, transform, filter, fcn, context);
		}

		/// <summary>
		/// Overlap test for all shapes that overlap the provided polygon<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2World_OverlapPolygon")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void WorldOverlapPolygon([NativeName(NativeNameType.Param, "worldId")] [NativeName(NativeNameType.Type, "b2WorldId")] B2WorldId worldId, [NativeName(NativeNameType.Param, "polygon")] [NativeName(NativeNameType.Type, "const b2Polygon*")] ref B2Polygon polygon, [NativeName(NativeNameType.Param, "transform")] [NativeName(NativeNameType.Type, "b2Transform")] B2Transform transform, [NativeName(NativeNameType.Param, "filter")] [NativeName(NativeNameType.Type, "b2QueryFilter")] B2QueryFilter filter, [NativeName(NativeNameType.Param, "fcn")] [NativeName(NativeNameType.Type, "b2OverlapResultFcn*")] delegate*<B2ShapeId, void*, bool>* fcn, [NativeName(NativeNameType.Param, "context")] [NativeName(NativeNameType.Type, "void*")] void* context)
		{
			fixed (B2Polygon* ppolygon = &polygon)
			{
				WorldOverlapPolygonNative(worldId, (B2Polygon*)ppolygon, transform, filter, fcn, context);
			}
		}

		/// <summary>
		/// Cast a ray into the world to collect shapes in the path of the ray.<br/>
		/// Your callback function controls whether you get the closest point, any point, or n-points.<br/>
		/// The ray-cast ignores shapes that contain the starting point.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2World_CastRay")]
		[return: NativeName(NativeNameType.Type, "void")]
		internal static void WorldCastRayNative([NativeName(NativeNameType.Param, "worldId")] [NativeName(NativeNameType.Type, "b2WorldId")] B2WorldId worldId, [NativeName(NativeNameType.Param, "origin")] [NativeName(NativeNameType.Type, "b2Vec2")] Vector2 origin, [NativeName(NativeNameType.Param, "translation")] [NativeName(NativeNameType.Type, "b2Vec2")] Vector2 translation, [NativeName(NativeNameType.Param, "filter")] [NativeName(NativeNameType.Type, "b2QueryFilter")] B2QueryFilter filter, [NativeName(NativeNameType.Param, "fcn")] [NativeName(NativeNameType.Type, "b2CastResultFcn*")] delegate*<B2ShapeId, Vector2, Vector2, float, void*, float>* fcn, [NativeName(NativeNameType.Param, "context")] [NativeName(NativeNameType.Type, "void*")] void* context)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<B2WorldId, Vector2, Vector2, B2QueryFilter, delegate*<B2ShapeId, Vector2, Vector2, float, void*, float>*, void*, void>)vt[108])(worldId, origin, translation, filter, fcn, context);
			#else
			((delegate* unmanaged[Cdecl]<B2WorldId, Vector2, Vector2, B2QueryFilter, nint, nint, void>)vt[108])(worldId, origin, translation, filter, (nint)fcn, (nint)context);
			#endif
		}

		/// <summary>
		/// Cast a ray into the world to collect shapes in the path of the ray.<br/>
		/// Your callback function controls whether you get the closest point, any point, or n-points.<br/>
		/// The ray-cast ignores shapes that contain the starting point.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2World_CastRay")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void WorldCastRay([NativeName(NativeNameType.Param, "worldId")] [NativeName(NativeNameType.Type, "b2WorldId")] B2WorldId worldId, [NativeName(NativeNameType.Param, "origin")] [NativeName(NativeNameType.Type, "b2Vec2")] Vector2 origin, [NativeName(NativeNameType.Param, "translation")] [NativeName(NativeNameType.Type, "b2Vec2")] Vector2 translation, [NativeName(NativeNameType.Param, "filter")] [NativeName(NativeNameType.Type, "b2QueryFilter")] B2QueryFilter filter, [NativeName(NativeNameType.Param, "fcn")] [NativeName(NativeNameType.Type, "b2CastResultFcn*")] delegate*<B2ShapeId, Vector2, Vector2, float, void*, float>* fcn, [NativeName(NativeNameType.Param, "context")] [NativeName(NativeNameType.Type, "void*")] void* context)
		{
			WorldCastRayNative(worldId, origin, translation, filter, fcn, context);
		}

		/// <summary>
		/// Cast a ray into the world to collect the closest hit. This is a convenience function.<br/>
		/// This is less general than b2World_CastRay() and does not allow for custom filtering.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2World_CastRayClosest")]
		[return: NativeName(NativeNameType.Type, "b2RayResult")]
		internal static B2RayResult WorldCastRayClosestNative([NativeName(NativeNameType.Param, "worldId")] [NativeName(NativeNameType.Type, "b2WorldId")] B2WorldId worldId, [NativeName(NativeNameType.Param, "origin")] [NativeName(NativeNameType.Type, "b2Vec2")] Vector2 origin, [NativeName(NativeNameType.Param, "translation")] [NativeName(NativeNameType.Type, "b2Vec2")] Vector2 translation, [NativeName(NativeNameType.Param, "filter")] [NativeName(NativeNameType.Type, "b2QueryFilter")] B2QueryFilter filter)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<B2WorldId, Vector2, Vector2, B2QueryFilter, B2RayResult>)vt[109])(worldId, origin, translation, filter);
			#else
			return (B2RayResult)((delegate* unmanaged[Cdecl]<B2WorldId, Vector2, Vector2, B2QueryFilter, B2RayResult>)vt[109])(worldId, origin, translation, filter);
			#endif
		}

		/// <summary>
		/// Cast a ray into the world to collect the closest hit. This is a convenience function.<br/>
		/// This is less general than b2World_CastRay() and does not allow for custom filtering.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2World_CastRayClosest")]
		[return: NativeName(NativeNameType.Type, "b2RayResult")]
		public static B2RayResult WorldCastRayClosest([NativeName(NativeNameType.Param, "worldId")] [NativeName(NativeNameType.Type, "b2WorldId")] B2WorldId worldId, [NativeName(NativeNameType.Param, "origin")] [NativeName(NativeNameType.Type, "b2Vec2")] Vector2 origin, [NativeName(NativeNameType.Param, "translation")] [NativeName(NativeNameType.Type, "b2Vec2")] Vector2 translation, [NativeName(NativeNameType.Param, "filter")] [NativeName(NativeNameType.Type, "b2QueryFilter")] B2QueryFilter filter)
		{
			B2RayResult ret = WorldCastRayClosestNative(worldId, origin, translation, filter);
			return ret;
		}

		/// <summary>
		/// Cast a circle through the world. Similar to a cast ray except that a circle is cast instead of a point.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2World_CastCircle")]
		[return: NativeName(NativeNameType.Type, "void")]
		internal static void WorldCastCircleNative([NativeName(NativeNameType.Param, "worldId")] [NativeName(NativeNameType.Type, "b2WorldId")] B2WorldId worldId, [NativeName(NativeNameType.Param, "circle")] [NativeName(NativeNameType.Type, "const b2Circle*")] B2Circle* circle, [NativeName(NativeNameType.Param, "originTransform")] [NativeName(NativeNameType.Type, "b2Transform")] B2Transform originTransform, [NativeName(NativeNameType.Param, "translation")] [NativeName(NativeNameType.Type, "b2Vec2")] Vector2 translation, [NativeName(NativeNameType.Param, "filter")] [NativeName(NativeNameType.Type, "b2QueryFilter")] B2QueryFilter filter, [NativeName(NativeNameType.Param, "fcn")] [NativeName(NativeNameType.Type, "b2CastResultFcn*")] delegate*<B2ShapeId, Vector2, Vector2, float, void*, float>* fcn, [NativeName(NativeNameType.Param, "context")] [NativeName(NativeNameType.Type, "void*")] void* context)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<B2WorldId, B2Circle*, B2Transform, Vector2, B2QueryFilter, delegate*<B2ShapeId, Vector2, Vector2, float, void*, float>*, void*, void>)vt[110])(worldId, circle, originTransform, translation, filter, fcn, context);
			#else
			((delegate* unmanaged[Cdecl]<B2WorldId, nint, B2Transform, Vector2, B2QueryFilter, nint, nint, void>)vt[110])(worldId, (nint)circle, originTransform, translation, filter, (nint)fcn, (nint)context);
			#endif
		}

		/// <summary>
		/// Cast a circle through the world. Similar to a cast ray except that a circle is cast instead of a point.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2World_CastCircle")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void WorldCastCircle([NativeName(NativeNameType.Param, "worldId")] [NativeName(NativeNameType.Type, "b2WorldId")] B2WorldId worldId, [NativeName(NativeNameType.Param, "circle")] [NativeName(NativeNameType.Type, "const b2Circle*")] B2Circle* circle, [NativeName(NativeNameType.Param, "originTransform")] [NativeName(NativeNameType.Type, "b2Transform")] B2Transform originTransform, [NativeName(NativeNameType.Param, "translation")] [NativeName(NativeNameType.Type, "b2Vec2")] Vector2 translation, [NativeName(NativeNameType.Param, "filter")] [NativeName(NativeNameType.Type, "b2QueryFilter")] B2QueryFilter filter, [NativeName(NativeNameType.Param, "fcn")] [NativeName(NativeNameType.Type, "b2CastResultFcn*")] delegate*<B2ShapeId, Vector2, Vector2, float, void*, float>* fcn, [NativeName(NativeNameType.Param, "context")] [NativeName(NativeNameType.Type, "void*")] void* context)
		{
			WorldCastCircleNative(worldId, circle, originTransform, translation, filter, fcn, context);
		}

		/// <summary>
		/// Cast a circle through the world. Similar to a cast ray except that a circle is cast instead of a point.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2World_CastCircle")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void WorldCastCircle([NativeName(NativeNameType.Param, "worldId")] [NativeName(NativeNameType.Type, "b2WorldId")] B2WorldId worldId, [NativeName(NativeNameType.Param, "circle")] [NativeName(NativeNameType.Type, "const b2Circle*")] ref B2Circle circle, [NativeName(NativeNameType.Param, "originTransform")] [NativeName(NativeNameType.Type, "b2Transform")] B2Transform originTransform, [NativeName(NativeNameType.Param, "translation")] [NativeName(NativeNameType.Type, "b2Vec2")] Vector2 translation, [NativeName(NativeNameType.Param, "filter")] [NativeName(NativeNameType.Type, "b2QueryFilter")] B2QueryFilter filter, [NativeName(NativeNameType.Param, "fcn")] [NativeName(NativeNameType.Type, "b2CastResultFcn*")] delegate*<B2ShapeId, Vector2, Vector2, float, void*, float>* fcn, [NativeName(NativeNameType.Param, "context")] [NativeName(NativeNameType.Type, "void*")] void* context)
		{
			fixed (B2Circle* pcircle = &circle)
			{
				WorldCastCircleNative(worldId, (B2Circle*)pcircle, originTransform, translation, filter, fcn, context);
			}
		}

		/// <summary>
		/// Cast a capsule through the world. Similar to a cast ray except that a capsule is cast instead of a point.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2World_CastCapsule")]
		[return: NativeName(NativeNameType.Type, "void")]
		internal static void WorldCastCapsuleNative([NativeName(NativeNameType.Param, "worldId")] [NativeName(NativeNameType.Type, "b2WorldId")] B2WorldId worldId, [NativeName(NativeNameType.Param, "capsule")] [NativeName(NativeNameType.Type, "const b2Capsule*")] B2Capsule* capsule, [NativeName(NativeNameType.Param, "originTransform")] [NativeName(NativeNameType.Type, "b2Transform")] B2Transform originTransform, [NativeName(NativeNameType.Param, "translation")] [NativeName(NativeNameType.Type, "b2Vec2")] Vector2 translation, [NativeName(NativeNameType.Param, "filter")] [NativeName(NativeNameType.Type, "b2QueryFilter")] B2QueryFilter filter, [NativeName(NativeNameType.Param, "fcn")] [NativeName(NativeNameType.Type, "b2CastResultFcn*")] delegate*<B2ShapeId, Vector2, Vector2, float, void*, float>* fcn, [NativeName(NativeNameType.Param, "context")] [NativeName(NativeNameType.Type, "void*")] void* context)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<B2WorldId, B2Capsule*, B2Transform, Vector2, B2QueryFilter, delegate*<B2ShapeId, Vector2, Vector2, float, void*, float>*, void*, void>)vt[111])(worldId, capsule, originTransform, translation, filter, fcn, context);
			#else
			((delegate* unmanaged[Cdecl]<B2WorldId, nint, B2Transform, Vector2, B2QueryFilter, nint, nint, void>)vt[111])(worldId, (nint)capsule, originTransform, translation, filter, (nint)fcn, (nint)context);
			#endif
		}

		/// <summary>
		/// Cast a capsule through the world. Similar to a cast ray except that a capsule is cast instead of a point.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2World_CastCapsule")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void WorldCastCapsule([NativeName(NativeNameType.Param, "worldId")] [NativeName(NativeNameType.Type, "b2WorldId")] B2WorldId worldId, [NativeName(NativeNameType.Param, "capsule")] [NativeName(NativeNameType.Type, "const b2Capsule*")] B2Capsule* capsule, [NativeName(NativeNameType.Param, "originTransform")] [NativeName(NativeNameType.Type, "b2Transform")] B2Transform originTransform, [NativeName(NativeNameType.Param, "translation")] [NativeName(NativeNameType.Type, "b2Vec2")] Vector2 translation, [NativeName(NativeNameType.Param, "filter")] [NativeName(NativeNameType.Type, "b2QueryFilter")] B2QueryFilter filter, [NativeName(NativeNameType.Param, "fcn")] [NativeName(NativeNameType.Type, "b2CastResultFcn*")] delegate*<B2ShapeId, Vector2, Vector2, float, void*, float>* fcn, [NativeName(NativeNameType.Param, "context")] [NativeName(NativeNameType.Type, "void*")] void* context)
		{
			WorldCastCapsuleNative(worldId, capsule, originTransform, translation, filter, fcn, context);
		}

		/// <summary>
		/// Cast a capsule through the world. Similar to a cast ray except that a capsule is cast instead of a point.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2World_CastCapsule")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void WorldCastCapsule([NativeName(NativeNameType.Param, "worldId")] [NativeName(NativeNameType.Type, "b2WorldId")] B2WorldId worldId, [NativeName(NativeNameType.Param, "capsule")] [NativeName(NativeNameType.Type, "const b2Capsule*")] ref B2Capsule capsule, [NativeName(NativeNameType.Param, "originTransform")] [NativeName(NativeNameType.Type, "b2Transform")] B2Transform originTransform, [NativeName(NativeNameType.Param, "translation")] [NativeName(NativeNameType.Type, "b2Vec2")] Vector2 translation, [NativeName(NativeNameType.Param, "filter")] [NativeName(NativeNameType.Type, "b2QueryFilter")] B2QueryFilter filter, [NativeName(NativeNameType.Param, "fcn")] [NativeName(NativeNameType.Type, "b2CastResultFcn*")] delegate*<B2ShapeId, Vector2, Vector2, float, void*, float>* fcn, [NativeName(NativeNameType.Param, "context")] [NativeName(NativeNameType.Type, "void*")] void* context)
		{
			fixed (B2Capsule* pcapsule = &capsule)
			{
				WorldCastCapsuleNative(worldId, (B2Capsule*)pcapsule, originTransform, translation, filter, fcn, context);
			}
		}

		/// <summary>
		/// Cast a polygon through the world. Similar to a cast ray except that a polygon is cast instead of a point.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2World_CastPolygon")]
		[return: NativeName(NativeNameType.Type, "void")]
		internal static void WorldCastPolygonNative([NativeName(NativeNameType.Param, "worldId")] [NativeName(NativeNameType.Type, "b2WorldId")] B2WorldId worldId, [NativeName(NativeNameType.Param, "polygon")] [NativeName(NativeNameType.Type, "const b2Polygon*")] B2Polygon* polygon, [NativeName(NativeNameType.Param, "originTransform")] [NativeName(NativeNameType.Type, "b2Transform")] B2Transform originTransform, [NativeName(NativeNameType.Param, "translation")] [NativeName(NativeNameType.Type, "b2Vec2")] Vector2 translation, [NativeName(NativeNameType.Param, "filter")] [NativeName(NativeNameType.Type, "b2QueryFilter")] B2QueryFilter filter, [NativeName(NativeNameType.Param, "fcn")] [NativeName(NativeNameType.Type, "b2CastResultFcn*")] delegate*<B2ShapeId, Vector2, Vector2, float, void*, float>* fcn, [NativeName(NativeNameType.Param, "context")] [NativeName(NativeNameType.Type, "void*")] void* context)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<B2WorldId, B2Polygon*, B2Transform, Vector2, B2QueryFilter, delegate*<B2ShapeId, Vector2, Vector2, float, void*, float>*, void*, void>)vt[112])(worldId, polygon, originTransform, translation, filter, fcn, context);
			#else
			((delegate* unmanaged[Cdecl]<B2WorldId, nint, B2Transform, Vector2, B2QueryFilter, nint, nint, void>)vt[112])(worldId, (nint)polygon, originTransform, translation, filter, (nint)fcn, (nint)context);
			#endif
		}

		/// <summary>
		/// Cast a polygon through the world. Similar to a cast ray except that a polygon is cast instead of a point.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2World_CastPolygon")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void WorldCastPolygon([NativeName(NativeNameType.Param, "worldId")] [NativeName(NativeNameType.Type, "b2WorldId")] B2WorldId worldId, [NativeName(NativeNameType.Param, "polygon")] [NativeName(NativeNameType.Type, "const b2Polygon*")] B2Polygon* polygon, [NativeName(NativeNameType.Param, "originTransform")] [NativeName(NativeNameType.Type, "b2Transform")] B2Transform originTransform, [NativeName(NativeNameType.Param, "translation")] [NativeName(NativeNameType.Type, "b2Vec2")] Vector2 translation, [NativeName(NativeNameType.Param, "filter")] [NativeName(NativeNameType.Type, "b2QueryFilter")] B2QueryFilter filter, [NativeName(NativeNameType.Param, "fcn")] [NativeName(NativeNameType.Type, "b2CastResultFcn*")] delegate*<B2ShapeId, Vector2, Vector2, float, void*, float>* fcn, [NativeName(NativeNameType.Param, "context")] [NativeName(NativeNameType.Type, "void*")] void* context)
		{
			WorldCastPolygonNative(worldId, polygon, originTransform, translation, filter, fcn, context);
		}

		/// <summary>
		/// Cast a polygon through the world. Similar to a cast ray except that a polygon is cast instead of a point.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2World_CastPolygon")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void WorldCastPolygon([NativeName(NativeNameType.Param, "worldId")] [NativeName(NativeNameType.Type, "b2WorldId")] B2WorldId worldId, [NativeName(NativeNameType.Param, "polygon")] [NativeName(NativeNameType.Type, "const b2Polygon*")] ref B2Polygon polygon, [NativeName(NativeNameType.Param, "originTransform")] [NativeName(NativeNameType.Type, "b2Transform")] B2Transform originTransform, [NativeName(NativeNameType.Param, "translation")] [NativeName(NativeNameType.Type, "b2Vec2")] Vector2 translation, [NativeName(NativeNameType.Param, "filter")] [NativeName(NativeNameType.Type, "b2QueryFilter")] B2QueryFilter filter, [NativeName(NativeNameType.Param, "fcn")] [NativeName(NativeNameType.Type, "b2CastResultFcn*")] delegate*<B2ShapeId, Vector2, Vector2, float, void*, float>* fcn, [NativeName(NativeNameType.Param, "context")] [NativeName(NativeNameType.Type, "void*")] void* context)
		{
			fixed (B2Polygon* ppolygon = &polygon)
			{
				WorldCastPolygonNative(worldId, (B2Polygon*)ppolygon, originTransform, translation, filter, fcn, context);
			}
		}

		/// <summary>
		/// Enable/disable sleep. If your application does not need sleeping, you can gain some performance<br/>
		/// by disabling sleep completely at the world level.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2World_EnableSleeping")]
		[return: NativeName(NativeNameType.Type, "void")]
		internal static void WorldEnableSleepingNative([NativeName(NativeNameType.Param, "worldId")] [NativeName(NativeNameType.Type, "b2WorldId")] B2WorldId worldId, [NativeName(NativeNameType.Param, "flag")] [NativeName(NativeNameType.Type, "bool")] byte flag)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<B2WorldId, byte, void>)vt[113])(worldId, flag);
			#else
			((delegate* unmanaged[Cdecl]<B2WorldId, byte, void>)vt[113])(worldId, flag);
			#endif
		}

		/// <summary>
		/// Enable/disable sleep. If your application does not need sleeping, you can gain some performance<br/>
		/// by disabling sleep completely at the world level.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2World_EnableSleeping")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void WorldEnableSleeping([NativeName(NativeNameType.Param, "worldId")] [NativeName(NativeNameType.Type, "b2WorldId")] B2WorldId worldId, [NativeName(NativeNameType.Param, "flag")] [NativeName(NativeNameType.Type, "bool")] bool flag)
		{
			WorldEnableSleepingNative(worldId, flag ? (byte)1 : (byte)0);
		}

		/// <summary>
		/// Enable/disable continuous collision between dynamic and static bodies. Generally you should keep continuous<br/>
		/// collision enabled to prevent fast moving objects from going through static objects. The performance gain from<br/>
		/// disabling continuous collision is minor.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2World_EnableContinuous")]
		[return: NativeName(NativeNameType.Type, "void")]
		internal static void WorldEnableContinuousNative([NativeName(NativeNameType.Param, "worldId")] [NativeName(NativeNameType.Type, "b2WorldId")] B2WorldId worldId, [NativeName(NativeNameType.Param, "flag")] [NativeName(NativeNameType.Type, "bool")] byte flag)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<B2WorldId, byte, void>)vt[114])(worldId, flag);
			#else
			((delegate* unmanaged[Cdecl]<B2WorldId, byte, void>)vt[114])(worldId, flag);
			#endif
		}

		/// <summary>
		/// Enable/disable continuous collision between dynamic and static bodies. Generally you should keep continuous<br/>
		/// collision enabled to prevent fast moving objects from going through static objects. The performance gain from<br/>
		/// disabling continuous collision is minor.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2World_EnableContinuous")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void WorldEnableContinuous([NativeName(NativeNameType.Param, "worldId")] [NativeName(NativeNameType.Type, "b2WorldId")] B2WorldId worldId, [NativeName(NativeNameType.Param, "flag")] [NativeName(NativeNameType.Type, "bool")] bool flag)
		{
			WorldEnableContinuousNative(worldId, flag ? (byte)1 : (byte)0);
		}

		/// <summary>
		/// Adjust the restitution threshold. It is recommended not to make this value very small<br/>
		/// because it will prevent bodies from sleeping. Typically in meters per second.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2World_SetRestitutionThreshold")]
		[return: NativeName(NativeNameType.Type, "void")]
		internal static void WorldSetRestitutionThresholdNative([NativeName(NativeNameType.Param, "worldId")] [NativeName(NativeNameType.Type, "b2WorldId")] B2WorldId worldId, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "float")] float value)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<B2WorldId, float, void>)vt[115])(worldId, value);
			#else
			((delegate* unmanaged[Cdecl]<B2WorldId, float, void>)vt[115])(worldId, value);
			#endif
		}

		/// <summary>
		/// Adjust the restitution threshold. It is recommended not to make this value very small<br/>
		/// because it will prevent bodies from sleeping. Typically in meters per second.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2World_SetRestitutionThreshold")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void WorldSetRestitutionThreshold([NativeName(NativeNameType.Param, "worldId")] [NativeName(NativeNameType.Type, "b2WorldId")] B2WorldId worldId, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "float")] float value)
		{
			WorldSetRestitutionThresholdNative(worldId, value);
		}

		/// <summary>
		/// Adjust the hit event threshold. This controls the collision velocity needed to generate a b2ContactHitEvent.<br/>
		/// Typically in meters per second.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2World_SetHitEventThreshold")]
		[return: NativeName(NativeNameType.Type, "void")]
		internal static void WorldSetHitEventThresholdNative([NativeName(NativeNameType.Param, "worldId")] [NativeName(NativeNameType.Type, "b2WorldId")] B2WorldId worldId, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "float")] float value)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<B2WorldId, float, void>)vt[116])(worldId, value);
			#else
			((delegate* unmanaged[Cdecl]<B2WorldId, float, void>)vt[116])(worldId, value);
			#endif
		}

		/// <summary>
		/// Adjust the hit event threshold. This controls the collision velocity needed to generate a b2ContactHitEvent.<br/>
		/// Typically in meters per second.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2World_SetHitEventThreshold")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void WorldSetHitEventThreshold([NativeName(NativeNameType.Param, "worldId")] [NativeName(NativeNameType.Type, "b2WorldId")] B2WorldId worldId, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "float")] float value)
		{
			WorldSetHitEventThresholdNative(worldId, value);
		}

		/// <summary>
		/// Register the custom filter callback. This is optional.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2World_SetCustomFilterCallback")]
		[return: NativeName(NativeNameType.Type, "void")]
		internal static void WorldSetCustomFilterCallbackNative([NativeName(NativeNameType.Param, "worldId")] [NativeName(NativeNameType.Type, "b2WorldId")] B2WorldId worldId, [NativeName(NativeNameType.Param, "fcn")] [NativeName(NativeNameType.Type, "b2CustomFilterFcn*")] delegate*<B2ShapeId, B2ShapeId, void*, bool>* fcn, [NativeName(NativeNameType.Param, "context")] [NativeName(NativeNameType.Type, "void*")] void* context)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<B2WorldId, delegate*<B2ShapeId, B2ShapeId, void*, bool>*, void*, void>)vt[117])(worldId, fcn, context);
			#else
			((delegate* unmanaged[Cdecl]<B2WorldId, nint, nint, void>)vt[117])(worldId, (nint)fcn, (nint)context);
			#endif
		}

		/// <summary>
		/// Register the custom filter callback. This is optional.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2World_SetCustomFilterCallback")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void WorldSetCustomFilterCallback([NativeName(NativeNameType.Param, "worldId")] [NativeName(NativeNameType.Type, "b2WorldId")] B2WorldId worldId, [NativeName(NativeNameType.Param, "fcn")] [NativeName(NativeNameType.Type, "b2CustomFilterFcn*")] delegate*<B2ShapeId, B2ShapeId, void*, bool>* fcn, [NativeName(NativeNameType.Param, "context")] [NativeName(NativeNameType.Type, "void*")] void* context)
		{
			WorldSetCustomFilterCallbackNative(worldId, fcn, context);
		}

		/// <summary>
		/// Register the pre-solve callback. This is optional.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2World_SetPreSolveCallback")]
		[return: NativeName(NativeNameType.Type, "void")]
		internal static void WorldSetPreSolveCallbackNative([NativeName(NativeNameType.Param, "worldId")] [NativeName(NativeNameType.Type, "b2WorldId")] B2WorldId worldId, [NativeName(NativeNameType.Param, "fcn")] [NativeName(NativeNameType.Type, "b2PreSolveFcn*")] delegate*<B2ShapeId, B2ShapeId, B2Manifold*, void*, bool>* fcn, [NativeName(NativeNameType.Param, "context")] [NativeName(NativeNameType.Type, "void*")] void* context)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<B2WorldId, delegate*<B2ShapeId, B2ShapeId, B2Manifold*, void*, bool>*, void*, void>)vt[118])(worldId, fcn, context);
			#else
			((delegate* unmanaged[Cdecl]<B2WorldId, nint, nint, void>)vt[118])(worldId, (nint)fcn, (nint)context);
			#endif
		}

		/// <summary>
		/// Register the pre-solve callback. This is optional.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2World_SetPreSolveCallback")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void WorldSetPreSolveCallback([NativeName(NativeNameType.Param, "worldId")] [NativeName(NativeNameType.Type, "b2WorldId")] B2WorldId worldId, [NativeName(NativeNameType.Param, "fcn")] [NativeName(NativeNameType.Type, "b2PreSolveFcn*")] delegate*<B2ShapeId, B2ShapeId, B2Manifold*, void*, bool>* fcn, [NativeName(NativeNameType.Param, "context")] [NativeName(NativeNameType.Type, "void*")] void* context)
		{
			WorldSetPreSolveCallbackNative(worldId, fcn, context);
		}

		/// <summary>
		/// Set the gravity vector for the entire world. Box2D has no concept of an up direction and this<br/>
		/// is left as a decision for the application. Typically in m/s^2.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2World_SetGravity")]
		[return: NativeName(NativeNameType.Type, "void")]
		internal static void WorldSetGravityNative([NativeName(NativeNameType.Param, "worldId")] [NativeName(NativeNameType.Type, "b2WorldId")] B2WorldId worldId, [NativeName(NativeNameType.Param, "gravity")] [NativeName(NativeNameType.Type, "b2Vec2")] Vector2 gravity)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<B2WorldId, Vector2, void>)vt[119])(worldId, gravity);
			#else
			((delegate* unmanaged[Cdecl]<B2WorldId, Vector2, void>)vt[119])(worldId, gravity);
			#endif
		}
	}
}
