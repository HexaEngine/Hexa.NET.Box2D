// ------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
// ------------------------------------------------------------------------------

using System;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using HexaGen.Runtime;
using System.Numerics;

namespace Hexa.NET.Box2D
{
	public unsafe partial class Box2D
	{

		/// <summary>
		/// Adjust the restitution threshold. It is recommended not to make this value very small<br/>
		/// because it will prevent bodies from sleeping. Typically in meters per second.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2World_SetRestitutionThreshold")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void WorldSetRestitutionThreshold([NativeName(NativeNameType.Param, "worldId")] [NativeName(NativeNameType.Type, "b2WorldId")] B2WorldId worldId, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "float")] float value)
		{
			WorldSetRestitutionThresholdNative(worldId, value);
		}

		/// <summary>
		/// Adjust the hit event threshold. This controls the collision velocity needed to generate a b2ContactHitEvent.<br/>
		/// Typically in meters per second.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2World_SetHitEventThreshold")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void WorldSetHitEventThresholdNative([NativeName(NativeNameType.Param, "worldId")] [NativeName(NativeNameType.Type, "b2WorldId")] B2WorldId worldId, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "float")] float value)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<B2WorldId, float, void>)funcTable[116])(worldId, value);
			#else
			((delegate* unmanaged[Cdecl]<B2WorldId, float, void>)funcTable[116])(worldId, value);
			#endif
		}

		/// <summary>
		/// Adjust the hit event threshold. This controls the collision velocity needed to generate a b2ContactHitEvent.<br/>
		/// Typically in meters per second.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2World_SetHitEventThreshold")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void WorldSetHitEventThreshold([NativeName(NativeNameType.Param, "worldId")] [NativeName(NativeNameType.Type, "b2WorldId")] B2WorldId worldId, [NativeName(NativeNameType.Param, "value")] [NativeName(NativeNameType.Type, "float")] float value)
		{
			WorldSetHitEventThresholdNative(worldId, value);
		}

		/// <summary>
		/// Register the custom filter callback. This is optional.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2World_SetCustomFilterCallback")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void WorldSetCustomFilterCallbackNative([NativeName(NativeNameType.Param, "worldId")] [NativeName(NativeNameType.Type, "b2WorldId")] B2WorldId worldId, [NativeName(NativeNameType.Param, "fcn")] [NativeName(NativeNameType.Type, "b2CustomFilterFcn *")] delegate*<B2ShapeId, B2ShapeId, void*, bool>* fcn, [NativeName(NativeNameType.Param, "context")] [NativeName(NativeNameType.Type, "void *")] void* context)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<B2WorldId, delegate*<B2ShapeId, B2ShapeId, void*, bool>*, void*, void>)funcTable[117])(worldId, fcn, context);
			#else
			((delegate* unmanaged[Cdecl]<B2WorldId, nint, nint, void>)funcTable[117])(worldId, (nint)fcn, (nint)context);
			#endif
		}

		/// <summary>
		/// Register the custom filter callback. This is optional.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2World_SetCustomFilterCallback")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void WorldSetCustomFilterCallback([NativeName(NativeNameType.Param, "worldId")] [NativeName(NativeNameType.Type, "b2WorldId")] B2WorldId worldId, [NativeName(NativeNameType.Param, "fcn")] [NativeName(NativeNameType.Type, "b2CustomFilterFcn *")] delegate*<B2ShapeId, B2ShapeId, void*, bool>* fcn, [NativeName(NativeNameType.Param, "context")] [NativeName(NativeNameType.Type, "void *")] void* context)
		{
			WorldSetCustomFilterCallbackNative(worldId, fcn, context);
		}

		/// <summary>
		/// Register the pre-solve callback. This is optional.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2World_SetPreSolveCallback")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void WorldSetPreSolveCallbackNative([NativeName(NativeNameType.Param, "worldId")] [NativeName(NativeNameType.Type, "b2WorldId")] B2WorldId worldId, [NativeName(NativeNameType.Param, "fcn")] [NativeName(NativeNameType.Type, "b2PreSolveFcn *")] delegate*<B2ShapeId, B2ShapeId, B2Manifold*, void*, bool>* fcn, [NativeName(NativeNameType.Param, "context")] [NativeName(NativeNameType.Type, "void *")] void* context)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<B2WorldId, delegate*<B2ShapeId, B2ShapeId, B2Manifold*, void*, bool>*, void*, void>)funcTable[118])(worldId, fcn, context);
			#else
			((delegate* unmanaged[Cdecl]<B2WorldId, nint, nint, void>)funcTable[118])(worldId, (nint)fcn, (nint)context);
			#endif
		}

		/// <summary>
		/// Register the pre-solve callback. This is optional.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2World_SetPreSolveCallback")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void WorldSetPreSolveCallback([NativeName(NativeNameType.Param, "worldId")] [NativeName(NativeNameType.Type, "b2WorldId")] B2WorldId worldId, [NativeName(NativeNameType.Param, "fcn")] [NativeName(NativeNameType.Type, "b2PreSolveFcn *")] delegate*<B2ShapeId, B2ShapeId, B2Manifold*, void*, bool>* fcn, [NativeName(NativeNameType.Param, "context")] [NativeName(NativeNameType.Type, "void *")] void* context)
		{
			WorldSetPreSolveCallbackNative(worldId, fcn, context);
		}

		/// <summary>
		/// Set the gravity vector for the entire world. Box2D has no concept of an up direction and this<br/>
		/// is left as a decision for the application. Typically in m/s^2.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2World_SetGravity")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void WorldSetGravityNative([NativeName(NativeNameType.Param, "worldId")] [NativeName(NativeNameType.Type, "b2WorldId")] B2WorldId worldId, [NativeName(NativeNameType.Param, "gravity")] [NativeName(NativeNameType.Type, "b2Vec2")] Vector2 gravity)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<B2WorldId, Vector2, void>)funcTable[119])(worldId, gravity);
			#else
			((delegate* unmanaged[Cdecl]<B2WorldId, Vector2, void>)funcTable[119])(worldId, gravity);
			#endif
		}

		/// <summary>
		/// Set the gravity vector for the entire world. Box2D has no concept of an up direction and this<br/>
		/// is left as a decision for the application. Typically in m/s^2.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2World_SetGravity")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void WorldSetGravity([NativeName(NativeNameType.Param, "worldId")] [NativeName(NativeNameType.Type, "b2WorldId")] B2WorldId worldId, [NativeName(NativeNameType.Param, "gravity")] [NativeName(NativeNameType.Type, "b2Vec2")] Vector2 gravity)
		{
			WorldSetGravityNative(worldId, gravity);
		}

		/// <summary>
		/// Get the gravity vector<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2World_GetGravity")]
		[return: NativeName(NativeNameType.Type, "b2Vec2")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static Vector2 WorldGetGravityNative([NativeName(NativeNameType.Param, "worldId")] [NativeName(NativeNameType.Type, "b2WorldId")] B2WorldId worldId)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<B2WorldId, Vector2>)funcTable[120])(worldId);
			#else
			return (Vector2)((delegate* unmanaged[Cdecl]<B2WorldId, Vector2>)funcTable[120])(worldId);
			#endif
		}

		/// <summary>
		/// Get the gravity vector<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2World_GetGravity")]
		[return: NativeName(NativeNameType.Type, "b2Vec2")]
		public static Vector2 WorldGetGravity([NativeName(NativeNameType.Param, "worldId")] [NativeName(NativeNameType.Type, "b2WorldId")] B2WorldId worldId)
		{
			Vector2 ret = WorldGetGravityNative(worldId);
			return ret;
		}

		/// <summary>
		/// Apply a radial explosion<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2World_Explode")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void WorldExplodeNative([NativeName(NativeNameType.Param, "worldId")] [NativeName(NativeNameType.Type, "b2WorldId")] B2WorldId worldId, [NativeName(NativeNameType.Param, "position")] [NativeName(NativeNameType.Type, "b2Vec2")] Vector2 position, [NativeName(NativeNameType.Param, "radius")] [NativeName(NativeNameType.Type, "float")] float radius, [NativeName(NativeNameType.Param, "impulse")] [NativeName(NativeNameType.Type, "float")] float impulse)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<B2WorldId, Vector2, float, float, void>)funcTable[121])(worldId, position, radius, impulse);
			#else
			((delegate* unmanaged[Cdecl]<B2WorldId, Vector2, float, float, void>)funcTable[121])(worldId, position, radius, impulse);
			#endif
		}

		/// <summary>
		/// Apply a radial explosion<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2World_Explode")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void WorldExplode([NativeName(NativeNameType.Param, "worldId")] [NativeName(NativeNameType.Type, "b2WorldId")] B2WorldId worldId, [NativeName(NativeNameType.Param, "position")] [NativeName(NativeNameType.Type, "b2Vec2")] Vector2 position, [NativeName(NativeNameType.Param, "radius")] [NativeName(NativeNameType.Type, "float")] float radius, [NativeName(NativeNameType.Param, "impulse")] [NativeName(NativeNameType.Type, "float")] float impulse)
		{
			WorldExplodeNative(worldId, position, radius, impulse);
		}

		/// <summary>
		/// Adjust contact tuning parameters<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2World_SetContactTuning")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void WorldSetContactTuningNative([NativeName(NativeNameType.Param, "worldId")] [NativeName(NativeNameType.Type, "b2WorldId")] B2WorldId worldId, [NativeName(NativeNameType.Param, "hertz")] [NativeName(NativeNameType.Type, "float")] float hertz, [NativeName(NativeNameType.Param, "dampingRatio")] [NativeName(NativeNameType.Type, "float")] float dampingRatio, [NativeName(NativeNameType.Param, "pushVelocity")] [NativeName(NativeNameType.Type, "float")] float pushVelocity)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<B2WorldId, float, float, float, void>)funcTable[122])(worldId, hertz, dampingRatio, pushVelocity);
			#else
			((delegate* unmanaged[Cdecl]<B2WorldId, float, float, float, void>)funcTable[122])(worldId, hertz, dampingRatio, pushVelocity);
			#endif
		}

		/// <summary>
		/// Adjust contact tuning parameters<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2World_SetContactTuning")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void WorldSetContactTuning([NativeName(NativeNameType.Param, "worldId")] [NativeName(NativeNameType.Type, "b2WorldId")] B2WorldId worldId, [NativeName(NativeNameType.Param, "hertz")] [NativeName(NativeNameType.Type, "float")] float hertz, [NativeName(NativeNameType.Param, "dampingRatio")] [NativeName(NativeNameType.Type, "float")] float dampingRatio, [NativeName(NativeNameType.Param, "pushVelocity")] [NativeName(NativeNameType.Type, "float")] float pushVelocity)
		{
			WorldSetContactTuningNative(worldId, hertz, dampingRatio, pushVelocity);
		}

		/// <summary>
		/// Enable/disable constraint warm starting. Advanced feature for testing. Disabling<br/>
		/// sleeping greatly reduces stability and provides no performance gain.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2World_EnableWarmStarting")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void WorldEnableWarmStartingNative([NativeName(NativeNameType.Param, "worldId")] [NativeName(NativeNameType.Type, "b2WorldId")] B2WorldId worldId, [NativeName(NativeNameType.Param, "flag")] [NativeName(NativeNameType.Type, "bool")] byte flag)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<B2WorldId, byte, void>)funcTable[123])(worldId, flag);
			#else
			((delegate* unmanaged[Cdecl]<B2WorldId, byte, void>)funcTable[123])(worldId, flag);
			#endif
		}

		/// <summary>
		/// Enable/disable constraint warm starting. Advanced feature for testing. Disabling<br/>
		/// sleeping greatly reduces stability and provides no performance gain.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2World_EnableWarmStarting")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void WorldEnableWarmStarting([NativeName(NativeNameType.Param, "worldId")] [NativeName(NativeNameType.Type, "b2WorldId")] B2WorldId worldId, [NativeName(NativeNameType.Param, "flag")] [NativeName(NativeNameType.Type, "bool")] bool flag)
		{
			WorldEnableWarmStartingNative(worldId, flag ? (byte)1 : (byte)0);
		}

		/// <summary>
		/// Get the current world performance profile<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2World_GetProfile")]
		[return: NativeName(NativeNameType.Type, "b2Profile")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static B2Profile WorldGetProfileNative([NativeName(NativeNameType.Param, "worldId")] [NativeName(NativeNameType.Type, "b2WorldId")] B2WorldId worldId)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<B2WorldId, B2Profile>)funcTable[124])(worldId);
			#else
			return (B2Profile)((delegate* unmanaged[Cdecl]<B2WorldId, B2Profile>)funcTable[124])(worldId);
			#endif
		}

		/// <summary>
		/// Get the current world performance profile<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2World_GetProfile")]
		[return: NativeName(NativeNameType.Type, "b2Profile")]
		public static B2Profile WorldGetProfile([NativeName(NativeNameType.Param, "worldId")] [NativeName(NativeNameType.Type, "b2WorldId")] B2WorldId worldId)
		{
			B2Profile ret = WorldGetProfileNative(worldId);
			return ret;
		}

		/// <summary>
		/// Get world counters and sizes<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2World_GetCounters")]
		[return: NativeName(NativeNameType.Type, "b2Counters")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static B2Counters WorldGetCountersNative([NativeName(NativeNameType.Param, "worldId")] [NativeName(NativeNameType.Type, "b2WorldId")] B2WorldId worldId)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<B2WorldId, B2Counters>)funcTable[125])(worldId);
			#else
			return (B2Counters)((delegate* unmanaged[Cdecl]<B2WorldId, B2Counters>)funcTable[125])(worldId);
			#endif
		}

		/// <summary>
		/// Get world counters and sizes<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2World_GetCounters")]
		[return: NativeName(NativeNameType.Type, "b2Counters")]
		public static B2Counters WorldGetCounters([NativeName(NativeNameType.Param, "worldId")] [NativeName(NativeNameType.Type, "b2WorldId")] B2WorldId worldId)
		{
			B2Counters ret = WorldGetCountersNative(worldId);
			return ret;
		}

		/// <summary>
		/// Dump memory stats to box2d_memory.txt<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2World_DumpMemoryStats")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void WorldDumpMemoryStatsNative([NativeName(NativeNameType.Param, "worldId")] [NativeName(NativeNameType.Type, "b2WorldId")] B2WorldId worldId)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<B2WorldId, void>)funcTable[126])(worldId);
			#else
			((delegate* unmanaged[Cdecl]<B2WorldId, void>)funcTable[126])(worldId);
			#endif
		}

		/// <summary>
		/// Dump memory stats to box2d_memory.txt<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2World_DumpMemoryStats")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void WorldDumpMemoryStats([NativeName(NativeNameType.Param, "worldId")] [NativeName(NativeNameType.Type, "b2WorldId")] B2WorldId worldId)
		{
			WorldDumpMemoryStatsNative(worldId);
		}

		/// <summary>
		/// Create a rigid body given a definition. No reference to the definition is retained. So you can create the definition<br/>
		/// on the stack and pass it as a pointer.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2CreateBody")]
		[return: NativeName(NativeNameType.Type, "b2BodyId")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static B2BodyId CreateBodyNative([NativeName(NativeNameType.Param, "worldId")] [NativeName(NativeNameType.Type, "b2WorldId")] B2WorldId worldId, [NativeName(NativeNameType.Param, "def")] [NativeName(NativeNameType.Type, "b2BodyDef const *")] B2BodyDef* def)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<B2WorldId, B2BodyDef*, B2BodyId>)funcTable[127])(worldId, def);
			#else
			return (B2BodyId)((delegate* unmanaged[Cdecl]<B2WorldId, nint, B2BodyId>)funcTable[127])(worldId, (nint)def);
			#endif
		}

		/// <summary>
		/// Create a rigid body given a definition. No reference to the definition is retained. So you can create the definition<br/>
		/// on the stack and pass it as a pointer.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2CreateBody")]
		[return: NativeName(NativeNameType.Type, "b2BodyId")]
		public static B2BodyId CreateBody([NativeName(NativeNameType.Param, "worldId")] [NativeName(NativeNameType.Type, "b2WorldId")] B2WorldId worldId, [NativeName(NativeNameType.Param, "def")] [NativeName(NativeNameType.Type, "b2BodyDef const *")] B2BodyDef* def)
		{
			B2BodyId ret = CreateBodyNative(worldId, def);
			return ret;
		}

		/// <summary>
		/// Create a rigid body given a definition. No reference to the definition is retained. So you can create the definition<br/>
		/// on the stack and pass it as a pointer.<br/>
		/// <br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2CreateBody")]
		[return: NativeName(NativeNameType.Type, "b2BodyId")]
		public static B2BodyId CreateBody([NativeName(NativeNameType.Param, "worldId")] [NativeName(NativeNameType.Type, "b2WorldId")] B2WorldId worldId, [NativeName(NativeNameType.Param, "def")] [NativeName(NativeNameType.Type, "b2BodyDef const *")] ref B2BodyDef def)
		{
			fixed (B2BodyDef* pdef = &def)
			{
				B2BodyId ret = CreateBodyNative(worldId, (B2BodyDef*)pdef);
				return ret;
			}
		}

		/// <summary>
		/// Destroy a rigid body given an id. This destroys all shapes and joints attached to the body.<br/>
		/// Do not keep references to the associated shapes and joints.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2DestroyBody")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DestroyBodyNative([NativeName(NativeNameType.Param, "bodyId")] [NativeName(NativeNameType.Type, "b2BodyId")] B2BodyId bodyId)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<B2BodyId, void>)funcTable[128])(bodyId);
			#else
			((delegate* unmanaged[Cdecl]<B2BodyId, void>)funcTable[128])(bodyId);
			#endif
		}

		/// <summary>
		/// Destroy a rigid body given an id. This destroys all shapes and joints attached to the body.<br/>
		/// Do not keep references to the associated shapes and joints.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2DestroyBody")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void DestroyBody([NativeName(NativeNameType.Param, "bodyId")] [NativeName(NativeNameType.Type, "b2BodyId")] B2BodyId bodyId)
		{
			DestroyBodyNative(bodyId);
		}

		/// <summary>
		/// Body identifier validation. Can be used to detect orphaned ids. Provides validation for up to 64K allocations.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2Body_IsValid")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte BodyIsValidNative([NativeName(NativeNameType.Param, "id")] [NativeName(NativeNameType.Type, "b2BodyId")] B2BodyId id)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<B2BodyId, byte>)funcTable[129])(id);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<B2BodyId, byte>)funcTable[129])(id);
			#endif
		}

		/// <summary>
		/// Body identifier validation. Can be used to detect orphaned ids. Provides validation for up to 64K allocations.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2Body_IsValid")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool BodyIsValid([NativeName(NativeNameType.Param, "id")] [NativeName(NativeNameType.Type, "b2BodyId")] B2BodyId id)
		{
			byte ret = BodyIsValidNative(id);
			return ret != 0;
		}

		/// <summary>
		/// Get the body type: static, kinematic, or dynamic<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2Body_GetType")]
		[return: NativeName(NativeNameType.Type, "b2BodyType")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static B2BodyType BodyGetTypeNative([NativeName(NativeNameType.Param, "bodyId")] [NativeName(NativeNameType.Type, "b2BodyId")] B2BodyId bodyId)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<B2BodyId, B2BodyType>)funcTable[130])(bodyId);
			#else
			return (B2BodyType)((delegate* unmanaged[Cdecl]<B2BodyId, B2BodyType>)funcTable[130])(bodyId);
			#endif
		}

		/// <summary>
		/// Get the body type: static, kinematic, or dynamic<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2Body_GetType")]
		[return: NativeName(NativeNameType.Type, "b2BodyType")]
		public static B2BodyType BodyGetType([NativeName(NativeNameType.Param, "bodyId")] [NativeName(NativeNameType.Type, "b2BodyId")] B2BodyId bodyId)
		{
			B2BodyType ret = BodyGetTypeNative(bodyId);
			return ret;
		}

		/// <summary>
		/// Change the body type. This is an expensive operation. This automatically updates the mass<br/>
		/// properties regardless of the automatic mass setting.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2Body_SetType")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void BodySetTypeNative([NativeName(NativeNameType.Param, "bodyId")] [NativeName(NativeNameType.Type, "b2BodyId")] B2BodyId bodyId, [NativeName(NativeNameType.Param, "type")] [NativeName(NativeNameType.Type, "b2BodyType")] B2BodyType type)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<B2BodyId, B2BodyType, void>)funcTable[131])(bodyId, type);
			#else
			((delegate* unmanaged[Cdecl]<B2BodyId, B2BodyType, void>)funcTable[131])(bodyId, type);
			#endif
		}

		/// <summary>
		/// Change the body type. This is an expensive operation. This automatically updates the mass<br/>
		/// properties regardless of the automatic mass setting.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2Body_SetType")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void BodySetType([NativeName(NativeNameType.Param, "bodyId")] [NativeName(NativeNameType.Type, "b2BodyId")] B2BodyId bodyId, [NativeName(NativeNameType.Param, "type")] [NativeName(NativeNameType.Type, "b2BodyType")] B2BodyType type)
		{
			BodySetTypeNative(bodyId, type);
		}

		/// <summary>
		/// Set the user data for a body<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2Body_SetUserData")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void BodySetUserDataNative([NativeName(NativeNameType.Param, "bodyId")] [NativeName(NativeNameType.Type, "b2BodyId")] B2BodyId bodyId, [NativeName(NativeNameType.Param, "userData")] [NativeName(NativeNameType.Type, "void *")] void* userData)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<B2BodyId, void*, void>)funcTable[132])(bodyId, userData);
			#else
			((delegate* unmanaged[Cdecl]<B2BodyId, nint, void>)funcTable[132])(bodyId, (nint)userData);
			#endif
		}

		/// <summary>
		/// Set the user data for a body<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2Body_SetUserData")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void BodySetUserData([NativeName(NativeNameType.Param, "bodyId")] [NativeName(NativeNameType.Type, "b2BodyId")] B2BodyId bodyId, [NativeName(NativeNameType.Param, "userData")] [NativeName(NativeNameType.Type, "void *")] void* userData)
		{
			BodySetUserDataNative(bodyId, userData);
		}

		/// <summary>
		/// Get the user data stored in a body<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2Body_GetUserData")]
		[return: NativeName(NativeNameType.Type, "void *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void* BodyGetUserDataNative([NativeName(NativeNameType.Param, "bodyId")] [NativeName(NativeNameType.Type, "b2BodyId")] B2BodyId bodyId)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<B2BodyId, void*>)funcTable[133])(bodyId);
			#else
			return (void*)((delegate* unmanaged[Cdecl]<B2BodyId, nint>)funcTable[133])(bodyId);
			#endif
		}

		/// <summary>
		/// Get the user data stored in a body<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2Body_GetUserData")]
		[return: NativeName(NativeNameType.Type, "void *")]
		public static void* BodyGetUserData([NativeName(NativeNameType.Param, "bodyId")] [NativeName(NativeNameType.Type, "b2BodyId")] B2BodyId bodyId)
		{
			void* ret = BodyGetUserDataNative(bodyId);
			return ret;
		}

		/// <summary>
		/// Get the world position of a body. This is the location of the body origin.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2Body_GetPosition")]
		[return: NativeName(NativeNameType.Type, "b2Vec2")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static Vector2 BodyGetPositionNative([NativeName(NativeNameType.Param, "bodyId")] [NativeName(NativeNameType.Type, "b2BodyId")] B2BodyId bodyId)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<B2BodyId, Vector2>)funcTable[134])(bodyId);
			#else
			return (Vector2)((delegate* unmanaged[Cdecl]<B2BodyId, Vector2>)funcTable[134])(bodyId);
			#endif
		}

		/// <summary>
		/// Get the world position of a body. This is the location of the body origin.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2Body_GetPosition")]
		[return: NativeName(NativeNameType.Type, "b2Vec2")]
		public static Vector2 BodyGetPosition([NativeName(NativeNameType.Param, "bodyId")] [NativeName(NativeNameType.Type, "b2BodyId")] B2BodyId bodyId)
		{
			Vector2 ret = BodyGetPositionNative(bodyId);
			return ret;
		}

		/// <summary>
		/// Get the world rotation of a body as a cosine/sine pair (complex number)<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2Body_GetRotation")]
		[return: NativeName(NativeNameType.Type, "b2Rot")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static B2Rot BodyGetRotationNative([NativeName(NativeNameType.Param, "bodyId")] [NativeName(NativeNameType.Type, "b2BodyId")] B2BodyId bodyId)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<B2BodyId, B2Rot>)funcTable[135])(bodyId);
			#else
			return (B2Rot)((delegate* unmanaged[Cdecl]<B2BodyId, B2Rot>)funcTable[135])(bodyId);
			#endif
		}

		/// <summary>
		/// Get the world rotation of a body as a cosine/sine pair (complex number)<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2Body_GetRotation")]
		[return: NativeName(NativeNameType.Type, "b2Rot")]
		public static B2Rot BodyGetRotation([NativeName(NativeNameType.Param, "bodyId")] [NativeName(NativeNameType.Type, "b2BodyId")] B2BodyId bodyId)
		{
			B2Rot ret = BodyGetRotationNative(bodyId);
			return ret;
		}

		/// <summary>
		/// Get the world transform of a body.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2Body_GetTransform")]
		[return: NativeName(NativeNameType.Type, "b2Transform")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static B2Transform BodyGetTransformNative([NativeName(NativeNameType.Param, "bodyId")] [NativeName(NativeNameType.Type, "b2BodyId")] B2BodyId bodyId)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<B2BodyId, B2Transform>)funcTable[136])(bodyId);
			#else
			return (B2Transform)((delegate* unmanaged[Cdecl]<B2BodyId, B2Transform>)funcTable[136])(bodyId);
			#endif
		}

		/// <summary>
		/// Get the world transform of a body.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2Body_GetTransform")]
		[return: NativeName(NativeNameType.Type, "b2Transform")]
		public static B2Transform BodyGetTransform([NativeName(NativeNameType.Param, "bodyId")] [NativeName(NativeNameType.Type, "b2BodyId")] B2BodyId bodyId)
		{
			B2Transform ret = BodyGetTransformNative(bodyId);
			return ret;
		}

		/// <summary>
		/// Set the world transform of a body. This acts as a teleport and is fairly expensive.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2Body_SetTransform")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void BodySetTransformNative([NativeName(NativeNameType.Param, "bodyId")] [NativeName(NativeNameType.Type, "b2BodyId")] B2BodyId bodyId, [NativeName(NativeNameType.Param, "position")] [NativeName(NativeNameType.Type, "b2Vec2")] Vector2 position, [NativeName(NativeNameType.Param, "rotation")] [NativeName(NativeNameType.Type, "b2Rot")] B2Rot rotation)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<B2BodyId, Vector2, B2Rot, void>)funcTable[137])(bodyId, position, rotation);
			#else
			((delegate* unmanaged[Cdecl]<B2BodyId, Vector2, B2Rot, void>)funcTable[137])(bodyId, position, rotation);
			#endif
		}

		/// <summary>
		/// Set the world transform of a body. This acts as a teleport and is fairly expensive.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2Body_SetTransform")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void BodySetTransform([NativeName(NativeNameType.Param, "bodyId")] [NativeName(NativeNameType.Type, "b2BodyId")] B2BodyId bodyId, [NativeName(NativeNameType.Param, "position")] [NativeName(NativeNameType.Type, "b2Vec2")] Vector2 position, [NativeName(NativeNameType.Param, "rotation")] [NativeName(NativeNameType.Type, "b2Rot")] B2Rot rotation)
		{
			BodySetTransformNative(bodyId, position, rotation);
		}

		/// <summary>
		/// Get a local point on a body given a world point<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2Body_GetLocalPoint")]
		[return: NativeName(NativeNameType.Type, "b2Vec2")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static Vector2 BodyGetLocalPointNative([NativeName(NativeNameType.Param, "bodyId")] [NativeName(NativeNameType.Type, "b2BodyId")] B2BodyId bodyId, [NativeName(NativeNameType.Param, "worldPoint")] [NativeName(NativeNameType.Type, "b2Vec2")] Vector2 worldPoint)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<B2BodyId, Vector2, Vector2>)funcTable[138])(bodyId, worldPoint);
			#else
			return (Vector2)((delegate* unmanaged[Cdecl]<B2BodyId, Vector2, Vector2>)funcTable[138])(bodyId, worldPoint);
			#endif
		}

		/// <summary>
		/// Get a local point on a body given a world point<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2Body_GetLocalPoint")]
		[return: NativeName(NativeNameType.Type, "b2Vec2")]
		public static Vector2 BodyGetLocalPoint([NativeName(NativeNameType.Param, "bodyId")] [NativeName(NativeNameType.Type, "b2BodyId")] B2BodyId bodyId, [NativeName(NativeNameType.Param, "worldPoint")] [NativeName(NativeNameType.Type, "b2Vec2")] Vector2 worldPoint)
		{
			Vector2 ret = BodyGetLocalPointNative(bodyId, worldPoint);
			return ret;
		}

		/// <summary>
		/// Get a world point on a body given a local point<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2Body_GetWorldPoint")]
		[return: NativeName(NativeNameType.Type, "b2Vec2")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static Vector2 BodyGetWorldPointNative([NativeName(NativeNameType.Param, "bodyId")] [NativeName(NativeNameType.Type, "b2BodyId")] B2BodyId bodyId, [NativeName(NativeNameType.Param, "localPoint")] [NativeName(NativeNameType.Type, "b2Vec2")] Vector2 localPoint)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<B2BodyId, Vector2, Vector2>)funcTable[139])(bodyId, localPoint);
			#else
			return (Vector2)((delegate* unmanaged[Cdecl]<B2BodyId, Vector2, Vector2>)funcTable[139])(bodyId, localPoint);
			#endif
		}

		/// <summary>
		/// Get a world point on a body given a local point<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2Body_GetWorldPoint")]
		[return: NativeName(NativeNameType.Type, "b2Vec2")]
		public static Vector2 BodyGetWorldPoint([NativeName(NativeNameType.Param, "bodyId")] [NativeName(NativeNameType.Type, "b2BodyId")] B2BodyId bodyId, [NativeName(NativeNameType.Param, "localPoint")] [NativeName(NativeNameType.Type, "b2Vec2")] Vector2 localPoint)
		{
			Vector2 ret = BodyGetWorldPointNative(bodyId, localPoint);
			return ret;
		}

		/// <summary>
		/// Get a local vector on a body given a world vector<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2Body_GetLocalVector")]
		[return: NativeName(NativeNameType.Type, "b2Vec2")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static Vector2 BodyGetLocalVectorNative([NativeName(NativeNameType.Param, "bodyId")] [NativeName(NativeNameType.Type, "b2BodyId")] B2BodyId bodyId, [NativeName(NativeNameType.Param, "worldVector")] [NativeName(NativeNameType.Type, "b2Vec2")] Vector2 worldVector)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<B2BodyId, Vector2, Vector2>)funcTable[140])(bodyId, worldVector);
			#else
			return (Vector2)((delegate* unmanaged[Cdecl]<B2BodyId, Vector2, Vector2>)funcTable[140])(bodyId, worldVector);
			#endif
		}

		/// <summary>
		/// Get a local vector on a body given a world vector<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2Body_GetLocalVector")]
		[return: NativeName(NativeNameType.Type, "b2Vec2")]
		public static Vector2 BodyGetLocalVector([NativeName(NativeNameType.Param, "bodyId")] [NativeName(NativeNameType.Type, "b2BodyId")] B2BodyId bodyId, [NativeName(NativeNameType.Param, "worldVector")] [NativeName(NativeNameType.Type, "b2Vec2")] Vector2 worldVector)
		{
			Vector2 ret = BodyGetLocalVectorNative(bodyId, worldVector);
			return ret;
		}

		/// <summary>
		/// Get a world vector on a body given a local vector<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2Body_GetWorldVector")]
		[return: NativeName(NativeNameType.Type, "b2Vec2")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static Vector2 BodyGetWorldVectorNative([NativeName(NativeNameType.Param, "bodyId")] [NativeName(NativeNameType.Type, "b2BodyId")] B2BodyId bodyId, [NativeName(NativeNameType.Param, "localVector")] [NativeName(NativeNameType.Type, "b2Vec2")] Vector2 localVector)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<B2BodyId, Vector2, Vector2>)funcTable[141])(bodyId, localVector);
			#else
			return (Vector2)((delegate* unmanaged[Cdecl]<B2BodyId, Vector2, Vector2>)funcTable[141])(bodyId, localVector);
			#endif
		}

		/// <summary>
		/// Get a world vector on a body given a local vector<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2Body_GetWorldVector")]
		[return: NativeName(NativeNameType.Type, "b2Vec2")]
		public static Vector2 BodyGetWorldVector([NativeName(NativeNameType.Param, "bodyId")] [NativeName(NativeNameType.Type, "b2BodyId")] B2BodyId bodyId, [NativeName(NativeNameType.Param, "localVector")] [NativeName(NativeNameType.Type, "b2Vec2")] Vector2 localVector)
		{
			Vector2 ret = BodyGetWorldVectorNative(bodyId, localVector);
			return ret;
		}

		/// <summary>
		/// Get the linear velocity of a body's center of mass. Typically in meters per second.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2Body_GetLinearVelocity")]
		[return: NativeName(NativeNameType.Type, "b2Vec2")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static Vector2 BodyGetLinearVelocityNative([NativeName(NativeNameType.Param, "bodyId")] [NativeName(NativeNameType.Type, "b2BodyId")] B2BodyId bodyId)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<B2BodyId, Vector2>)funcTable[142])(bodyId);
			#else
			return (Vector2)((delegate* unmanaged[Cdecl]<B2BodyId, Vector2>)funcTable[142])(bodyId);
			#endif
		}

		/// <summary>
		/// Get the linear velocity of a body's center of mass. Typically in meters per second.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2Body_GetLinearVelocity")]
		[return: NativeName(NativeNameType.Type, "b2Vec2")]
		public static Vector2 BodyGetLinearVelocity([NativeName(NativeNameType.Param, "bodyId")] [NativeName(NativeNameType.Type, "b2BodyId")] B2BodyId bodyId)
		{
			Vector2 ret = BodyGetLinearVelocityNative(bodyId);
			return ret;
		}

		/// <summary>
		/// Get the angular velocity of a body in radians per second<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2Body_GetAngularVelocity")]
		[return: NativeName(NativeNameType.Type, "float")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static float BodyGetAngularVelocityNative([NativeName(NativeNameType.Param, "bodyId")] [NativeName(NativeNameType.Type, "b2BodyId")] B2BodyId bodyId)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<B2BodyId, float>)funcTable[143])(bodyId);
			#else
			return (float)((delegate* unmanaged[Cdecl]<B2BodyId, float>)funcTable[143])(bodyId);
			#endif
		}

		/// <summary>
		/// Get the angular velocity of a body in radians per second<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2Body_GetAngularVelocity")]
		[return: NativeName(NativeNameType.Type, "float")]
		public static float BodyGetAngularVelocity([NativeName(NativeNameType.Param, "bodyId")] [NativeName(NativeNameType.Type, "b2BodyId")] B2BodyId bodyId)
		{
			float ret = BodyGetAngularVelocityNative(bodyId);
			return ret;
		}

		/// <summary>
		/// Set the linear velocity of a body. Typically in meters per second.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2Body_SetLinearVelocity")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void BodySetLinearVelocityNative([NativeName(NativeNameType.Param, "bodyId")] [NativeName(NativeNameType.Type, "b2BodyId")] B2BodyId bodyId, [NativeName(NativeNameType.Param, "linearVelocity")] [NativeName(NativeNameType.Type, "b2Vec2")] Vector2 linearVelocity)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<B2BodyId, Vector2, void>)funcTable[144])(bodyId, linearVelocity);
			#else
			((delegate* unmanaged[Cdecl]<B2BodyId, Vector2, void>)funcTable[144])(bodyId, linearVelocity);
			#endif
		}

		/// <summary>
		/// Set the linear velocity of a body. Typically in meters per second.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2Body_SetLinearVelocity")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void BodySetLinearVelocity([NativeName(NativeNameType.Param, "bodyId")] [NativeName(NativeNameType.Type, "b2BodyId")] B2BodyId bodyId, [NativeName(NativeNameType.Param, "linearVelocity")] [NativeName(NativeNameType.Type, "b2Vec2")] Vector2 linearVelocity)
		{
			BodySetLinearVelocityNative(bodyId, linearVelocity);
		}

		/// <summary>
		/// Set the angular velocity of a body in radians per second<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2Body_SetAngularVelocity")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void BodySetAngularVelocityNative([NativeName(NativeNameType.Param, "bodyId")] [NativeName(NativeNameType.Type, "b2BodyId")] B2BodyId bodyId, [NativeName(NativeNameType.Param, "angularVelocity")] [NativeName(NativeNameType.Type, "float")] float angularVelocity)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<B2BodyId, float, void>)funcTable[145])(bodyId, angularVelocity);
			#else
			((delegate* unmanaged[Cdecl]<B2BodyId, float, void>)funcTable[145])(bodyId, angularVelocity);
			#endif
		}

		/// <summary>
		/// Set the angular velocity of a body in radians per second<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2Body_SetAngularVelocity")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void BodySetAngularVelocity([NativeName(NativeNameType.Param, "bodyId")] [NativeName(NativeNameType.Type, "b2BodyId")] B2BodyId bodyId, [NativeName(NativeNameType.Param, "angularVelocity")] [NativeName(NativeNameType.Type, "float")] float angularVelocity)
		{
			BodySetAngularVelocityNative(bodyId, angularVelocity);
		}

		/// <summary>
		/// Apply a force at a world point. If the force is not applied at the center of mass,<br/>
		/// it will generate a torque and affect the angular velocity. This optionally wakes up the body.<br/>
		/// The force is ignored if the body is not awake.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2Body_ApplyForce")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void BodyApplyForceNative([NativeName(NativeNameType.Param, "bodyId")] [NativeName(NativeNameType.Type, "b2BodyId")] B2BodyId bodyId, [NativeName(NativeNameType.Param, "force")] [NativeName(NativeNameType.Type, "b2Vec2")] Vector2 force, [NativeName(NativeNameType.Param, "point")] [NativeName(NativeNameType.Type, "b2Vec2")] Vector2 point, [NativeName(NativeNameType.Param, "wake")] [NativeName(NativeNameType.Type, "bool")] byte wake)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<B2BodyId, Vector2, Vector2, byte, void>)funcTable[146])(bodyId, force, point, wake);
			#else
			((delegate* unmanaged[Cdecl]<B2BodyId, Vector2, Vector2, byte, void>)funcTable[146])(bodyId, force, point, wake);
			#endif
		}

		/// <summary>
		/// Apply a force at a world point. If the force is not applied at the center of mass,<br/>
		/// it will generate a torque and affect the angular velocity. This optionally wakes up the body.<br/>
		/// The force is ignored if the body is not awake.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2Body_ApplyForce")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void BodyApplyForce([NativeName(NativeNameType.Param, "bodyId")] [NativeName(NativeNameType.Type, "b2BodyId")] B2BodyId bodyId, [NativeName(NativeNameType.Param, "force")] [NativeName(NativeNameType.Type, "b2Vec2")] Vector2 force, [NativeName(NativeNameType.Param, "point")] [NativeName(NativeNameType.Type, "b2Vec2")] Vector2 point, [NativeName(NativeNameType.Param, "wake")] [NativeName(NativeNameType.Type, "bool")] bool wake)
		{
			BodyApplyForceNative(bodyId, force, point, wake ? (byte)1 : (byte)0);
		}

		/// <summary>
		/// Apply a force to the center of mass. This optionally wakes up the body.<br/>
		/// The force is ignored if the body is not awake.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2Body_ApplyForceToCenter")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void BodyApplyForceToCenterNative([NativeName(NativeNameType.Param, "bodyId")] [NativeName(NativeNameType.Type, "b2BodyId")] B2BodyId bodyId, [NativeName(NativeNameType.Param, "force")] [NativeName(NativeNameType.Type, "b2Vec2")] Vector2 force, [NativeName(NativeNameType.Param, "wake")] [NativeName(NativeNameType.Type, "bool")] byte wake)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<B2BodyId, Vector2, byte, void>)funcTable[147])(bodyId, force, wake);
			#else
			((delegate* unmanaged[Cdecl]<B2BodyId, Vector2, byte, void>)funcTable[147])(bodyId, force, wake);
			#endif
		}

		/// <summary>
		/// Apply a force to the center of mass. This optionally wakes up the body.<br/>
		/// The force is ignored if the body is not awake.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2Body_ApplyForceToCenter")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void BodyApplyForceToCenter([NativeName(NativeNameType.Param, "bodyId")] [NativeName(NativeNameType.Type, "b2BodyId")] B2BodyId bodyId, [NativeName(NativeNameType.Param, "force")] [NativeName(NativeNameType.Type, "b2Vec2")] Vector2 force, [NativeName(NativeNameType.Param, "wake")] [NativeName(NativeNameType.Type, "bool")] bool wake)
		{
			BodyApplyForceToCenterNative(bodyId, force, wake ? (byte)1 : (byte)0);
		}

		/// <summary>
		/// Apply a torque. This affects the angular velocity without affecting the linear velocity.<br/>
		/// This optionally wakes the body. The torque is ignored if the body is not awake.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2Body_ApplyTorque")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void BodyApplyTorqueNative([NativeName(NativeNameType.Param, "bodyId")] [NativeName(NativeNameType.Type, "b2BodyId")] B2BodyId bodyId, [NativeName(NativeNameType.Param, "torque")] [NativeName(NativeNameType.Type, "float")] float torque, [NativeName(NativeNameType.Param, "wake")] [NativeName(NativeNameType.Type, "bool")] byte wake)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<B2BodyId, float, byte, void>)funcTable[148])(bodyId, torque, wake);
			#else
			((delegate* unmanaged[Cdecl]<B2BodyId, float, byte, void>)funcTable[148])(bodyId, torque, wake);
			#endif
		}

		/// <summary>
		/// Apply a torque. This affects the angular velocity without affecting the linear velocity.<br/>
		/// This optionally wakes the body. The torque is ignored if the body is not awake.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2Body_ApplyTorque")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void BodyApplyTorque([NativeName(NativeNameType.Param, "bodyId")] [NativeName(NativeNameType.Type, "b2BodyId")] B2BodyId bodyId, [NativeName(NativeNameType.Param, "torque")] [NativeName(NativeNameType.Type, "float")] float torque, [NativeName(NativeNameType.Param, "wake")] [NativeName(NativeNameType.Type, "bool")] bool wake)
		{
			BodyApplyTorqueNative(bodyId, torque, wake ? (byte)1 : (byte)0);
		}

		/// <summary>
		/// Apply an impulse at a point. This immediately modifies the velocity.<br/>
		/// It also modifies the angular velocity if the point of application<br/>
		/// is not at the center of mass. This optionally wakes the body.<br/>
		/// The impulse is ignored if the body is not awake.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2Body_ApplyLinearImpulse")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void BodyApplyLinearImpulseNative([NativeName(NativeNameType.Param, "bodyId")] [NativeName(NativeNameType.Type, "b2BodyId")] B2BodyId bodyId, [NativeName(NativeNameType.Param, "impulse")] [NativeName(NativeNameType.Type, "b2Vec2")] Vector2 impulse, [NativeName(NativeNameType.Param, "point")] [NativeName(NativeNameType.Type, "b2Vec2")] Vector2 point, [NativeName(NativeNameType.Param, "wake")] [NativeName(NativeNameType.Type, "bool")] byte wake)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<B2BodyId, Vector2, Vector2, byte, void>)funcTable[149])(bodyId, impulse, point, wake);
			#else
			((delegate* unmanaged[Cdecl]<B2BodyId, Vector2, Vector2, byte, void>)funcTable[149])(bodyId, impulse, point, wake);
			#endif
		}

		/// <summary>
		/// Apply an impulse at a point. This immediately modifies the velocity.<br/>
		/// It also modifies the angular velocity if the point of application<br/>
		/// is not at the center of mass. This optionally wakes the body.<br/>
		/// The impulse is ignored if the body is not awake.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2Body_ApplyLinearImpulse")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void BodyApplyLinearImpulse([NativeName(NativeNameType.Param, "bodyId")] [NativeName(NativeNameType.Type, "b2BodyId")] B2BodyId bodyId, [NativeName(NativeNameType.Param, "impulse")] [NativeName(NativeNameType.Type, "b2Vec2")] Vector2 impulse, [NativeName(NativeNameType.Param, "point")] [NativeName(NativeNameType.Type, "b2Vec2")] Vector2 point, [NativeName(NativeNameType.Param, "wake")] [NativeName(NativeNameType.Type, "bool")] bool wake)
		{
			BodyApplyLinearImpulseNative(bodyId, impulse, point, wake ? (byte)1 : (byte)0);
		}

		/// <summary>
		/// Apply an impulse to the center of mass. This immediately modifies the velocity.<br/>
		/// The impulse is ignored if the body is not awake. This optionally wakes the body.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2Body_ApplyLinearImpulseToCenter")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void BodyApplyLinearImpulseToCenterNative([NativeName(NativeNameType.Param, "bodyId")] [NativeName(NativeNameType.Type, "b2BodyId")] B2BodyId bodyId, [NativeName(NativeNameType.Param, "impulse")] [NativeName(NativeNameType.Type, "b2Vec2")] Vector2 impulse, [NativeName(NativeNameType.Param, "wake")] [NativeName(NativeNameType.Type, "bool")] byte wake)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<B2BodyId, Vector2, byte, void>)funcTable[150])(bodyId, impulse, wake);
			#else
			((delegate* unmanaged[Cdecl]<B2BodyId, Vector2, byte, void>)funcTable[150])(bodyId, impulse, wake);
			#endif
		}

		/// <summary>
		/// Apply an impulse to the center of mass. This immediately modifies the velocity.<br/>
		/// The impulse is ignored if the body is not awake. This optionally wakes the body.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2Body_ApplyLinearImpulseToCenter")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void BodyApplyLinearImpulseToCenter([NativeName(NativeNameType.Param, "bodyId")] [NativeName(NativeNameType.Type, "b2BodyId")] B2BodyId bodyId, [NativeName(NativeNameType.Param, "impulse")] [NativeName(NativeNameType.Type, "b2Vec2")] Vector2 impulse, [NativeName(NativeNameType.Param, "wake")] [NativeName(NativeNameType.Type, "bool")] bool wake)
		{
			BodyApplyLinearImpulseToCenterNative(bodyId, impulse, wake ? (byte)1 : (byte)0);
		}

		/// <summary>
		/// Apply an angular impulse. The impulse is ignored if the body is not awake.<br/>
		/// This optionally wakes the body.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2Body_ApplyAngularImpulse")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void BodyApplyAngularImpulseNative([NativeName(NativeNameType.Param, "bodyId")] [NativeName(NativeNameType.Type, "b2BodyId")] B2BodyId bodyId, [NativeName(NativeNameType.Param, "impulse")] [NativeName(NativeNameType.Type, "float")] float impulse, [NativeName(NativeNameType.Param, "wake")] [NativeName(NativeNameType.Type, "bool")] byte wake)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<B2BodyId, float, byte, void>)funcTable[151])(bodyId, impulse, wake);
			#else
			((delegate* unmanaged[Cdecl]<B2BodyId, float, byte, void>)funcTable[151])(bodyId, impulse, wake);
			#endif
		}

		/// <summary>
		/// Apply an angular impulse. The impulse is ignored if the body is not awake.<br/>
		/// This optionally wakes the body.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2Body_ApplyAngularImpulse")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void BodyApplyAngularImpulse([NativeName(NativeNameType.Param, "bodyId")] [NativeName(NativeNameType.Type, "b2BodyId")] B2BodyId bodyId, [NativeName(NativeNameType.Param, "impulse")] [NativeName(NativeNameType.Type, "float")] float impulse, [NativeName(NativeNameType.Param, "wake")] [NativeName(NativeNameType.Type, "bool")] bool wake)
		{
			BodyApplyAngularImpulseNative(bodyId, impulse, wake ? (byte)1 : (byte)0);
		}

		/// <summary>
		/// Get the mass of the body, typically in kilograms<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2Body_GetMass")]
		[return: NativeName(NativeNameType.Type, "float")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static float BodyGetMassNative([NativeName(NativeNameType.Param, "bodyId")] [NativeName(NativeNameType.Type, "b2BodyId")] B2BodyId bodyId)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<B2BodyId, float>)funcTable[152])(bodyId);
			#else
			return (float)((delegate* unmanaged[Cdecl]<B2BodyId, float>)funcTable[152])(bodyId);
			#endif
		}

		/// <summary>
		/// Get the mass of the body, typically in kilograms<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2Body_GetMass")]
		[return: NativeName(NativeNameType.Type, "float")]
		public static float BodyGetMass([NativeName(NativeNameType.Param, "bodyId")] [NativeName(NativeNameType.Type, "b2BodyId")] B2BodyId bodyId)
		{
			float ret = BodyGetMassNative(bodyId);
			return ret;
		}

		/// <summary>
		/// Get the inertia tensor of the body, typically in kg*m^2<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2Body_GetInertiaTensor")]
		[return: NativeName(NativeNameType.Type, "float")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static float BodyGetInertiaTensorNative([NativeName(NativeNameType.Param, "bodyId")] [NativeName(NativeNameType.Type, "b2BodyId")] B2BodyId bodyId)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<B2BodyId, float>)funcTable[153])(bodyId);
			#else
			return (float)((delegate* unmanaged[Cdecl]<B2BodyId, float>)funcTable[153])(bodyId);
			#endif
		}

		/// <summary>
		/// Get the inertia tensor of the body, typically in kg*m^2<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2Body_GetInertiaTensor")]
		[return: NativeName(NativeNameType.Type, "float")]
		public static float BodyGetInertiaTensor([NativeName(NativeNameType.Param, "bodyId")] [NativeName(NativeNameType.Type, "b2BodyId")] B2BodyId bodyId)
		{
			float ret = BodyGetInertiaTensorNative(bodyId);
			return ret;
		}

		/// <summary>
		/// Get the center of mass position of the body in local space<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2Body_GetLocalCenterOfMass")]
		[return: NativeName(NativeNameType.Type, "b2Vec2")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static Vector2 BodyGetLocalCenterOfMassNative([NativeName(NativeNameType.Param, "bodyId")] [NativeName(NativeNameType.Type, "b2BodyId")] B2BodyId bodyId)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<B2BodyId, Vector2>)funcTable[154])(bodyId);
			#else
			return (Vector2)((delegate* unmanaged[Cdecl]<B2BodyId, Vector2>)funcTable[154])(bodyId);
			#endif
		}

		/// <summary>
		/// Get the center of mass position of the body in local space<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2Body_GetLocalCenterOfMass")]
		[return: NativeName(NativeNameType.Type, "b2Vec2")]
		public static Vector2 BodyGetLocalCenterOfMass([NativeName(NativeNameType.Param, "bodyId")] [NativeName(NativeNameType.Type, "b2BodyId")] B2BodyId bodyId)
		{
			Vector2 ret = BodyGetLocalCenterOfMassNative(bodyId);
			return ret;
		}

		/// <summary>
		/// Get the center of mass position of the body in world space<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2Body_GetWorldCenterOfMass")]
		[return: NativeName(NativeNameType.Type, "b2Vec2")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static Vector2 BodyGetWorldCenterOfMassNative([NativeName(NativeNameType.Param, "bodyId")] [NativeName(NativeNameType.Type, "b2BodyId")] B2BodyId bodyId)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<B2BodyId, Vector2>)funcTable[155])(bodyId);
			#else
			return (Vector2)((delegate* unmanaged[Cdecl]<B2BodyId, Vector2>)funcTable[155])(bodyId);
			#endif
		}

		/// <summary>
		/// Get the center of mass position of the body in world space<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2Body_GetWorldCenterOfMass")]
		[return: NativeName(NativeNameType.Type, "b2Vec2")]
		public static Vector2 BodyGetWorldCenterOfMass([NativeName(NativeNameType.Param, "bodyId")] [NativeName(NativeNameType.Type, "b2BodyId")] B2BodyId bodyId)
		{
			Vector2 ret = BodyGetWorldCenterOfMassNative(bodyId);
			return ret;
		}

		/// <summary>
		/// Override the body's mass properties. Normally this is computed automatically using the<br/>
		/// shape geometry and density. This information is lost if a shape is added or removed or if the<br/>
		/// body type changes.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2Body_SetMassData")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void BodySetMassDataNative([NativeName(NativeNameType.Param, "bodyId")] [NativeName(NativeNameType.Type, "b2BodyId")] B2BodyId bodyId, [NativeName(NativeNameType.Param, "massData")] [NativeName(NativeNameType.Type, "b2MassData")] B2MassData massData)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<B2BodyId, B2MassData, void>)funcTable[156])(bodyId, massData);
			#else
			((delegate* unmanaged[Cdecl]<B2BodyId, B2MassData, void>)funcTable[156])(bodyId, massData);
			#endif
		}

		/// <summary>
		/// Override the body's mass properties. Normally this is computed automatically using the<br/>
		/// shape geometry and density. This information is lost if a shape is added or removed or if the<br/>
		/// body type changes.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2Body_SetMassData")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void BodySetMassData([NativeName(NativeNameType.Param, "bodyId")] [NativeName(NativeNameType.Type, "b2BodyId")] B2BodyId bodyId, [NativeName(NativeNameType.Param, "massData")] [NativeName(NativeNameType.Type, "b2MassData")] B2MassData massData)
		{
			BodySetMassDataNative(bodyId, massData);
		}

		/// <summary>
		/// Get the mass data for a body<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2Body_GetMassData")]
		[return: NativeName(NativeNameType.Type, "b2MassData")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static B2MassData BodyGetMassDataNative([NativeName(NativeNameType.Param, "bodyId")] [NativeName(NativeNameType.Type, "b2BodyId")] B2BodyId bodyId)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<B2BodyId, B2MassData>)funcTable[157])(bodyId);
			#else
			return (B2MassData)((delegate* unmanaged[Cdecl]<B2BodyId, B2MassData>)funcTable[157])(bodyId);
			#endif
		}

		/// <summary>
		/// Get the mass data for a body<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2Body_GetMassData")]
		[return: NativeName(NativeNameType.Type, "b2MassData")]
		public static B2MassData BodyGetMassData([NativeName(NativeNameType.Param, "bodyId")] [NativeName(NativeNameType.Type, "b2BodyId")] B2BodyId bodyId)
		{
			B2MassData ret = BodyGetMassDataNative(bodyId);
			return ret;
		}

		/// <summary>
		/// This update the mass properties to the sum of the mass properties of the shapes.<br/>
		/// This normally does not need to be called unless you called SetMassData to override<br/>
		/// the mass and you later want to reset the mass.<br/>
		/// You may also use this when automatic mass computation has been disabled.<br/>
		/// You should call this regardless of body type.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2Body_ApplyMassFromShapes")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void BodyApplyMassFromShapesNative([NativeName(NativeNameType.Param, "bodyId")] [NativeName(NativeNameType.Type, "b2BodyId")] B2BodyId bodyId)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<B2BodyId, void>)funcTable[158])(bodyId);
			#else
			((delegate* unmanaged[Cdecl]<B2BodyId, void>)funcTable[158])(bodyId);
			#endif
		}

		/// <summary>
		/// This update the mass properties to the sum of the mass properties of the shapes.<br/>
		/// This normally does not need to be called unless you called SetMassData to override<br/>
		/// the mass and you later want to reset the mass.<br/>
		/// You may also use this when automatic mass computation has been disabled.<br/>
		/// You should call this regardless of body type.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2Body_ApplyMassFromShapes")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void BodyApplyMassFromShapes([NativeName(NativeNameType.Param, "bodyId")] [NativeName(NativeNameType.Type, "b2BodyId")] B2BodyId bodyId)
		{
			BodyApplyMassFromShapesNative(bodyId);
		}

		/// <summary>
		/// Set the automatic mass setting. Normally this is set in b2BodyDef before creation.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2Body_SetAutomaticMass")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void BodySetAutomaticMassNative([NativeName(NativeNameType.Param, "bodyId")] [NativeName(NativeNameType.Type, "b2BodyId")] B2BodyId bodyId, [NativeName(NativeNameType.Param, "automaticMass")] [NativeName(NativeNameType.Type, "bool")] byte automaticMass)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<B2BodyId, byte, void>)funcTable[159])(bodyId, automaticMass);
			#else
			((delegate* unmanaged[Cdecl]<B2BodyId, byte, void>)funcTable[159])(bodyId, automaticMass);
			#endif
		}

		/// <summary>
		/// Set the automatic mass setting. Normally this is set in b2BodyDef before creation.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2Body_SetAutomaticMass")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void BodySetAutomaticMass([NativeName(NativeNameType.Param, "bodyId")] [NativeName(NativeNameType.Type, "b2BodyId")] B2BodyId bodyId, [NativeName(NativeNameType.Param, "automaticMass")] [NativeName(NativeNameType.Type, "bool")] bool automaticMass)
		{
			BodySetAutomaticMassNative(bodyId, automaticMass ? (byte)1 : (byte)0);
		}

		/// <summary>
		/// Get the automatic mass setting<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2Body_GetAutomaticMass")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte BodyGetAutomaticMassNative([NativeName(NativeNameType.Param, "bodyId")] [NativeName(NativeNameType.Type, "b2BodyId")] B2BodyId bodyId)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<B2BodyId, byte>)funcTable[160])(bodyId);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<B2BodyId, byte>)funcTable[160])(bodyId);
			#endif
		}

		/// <summary>
		/// Get the automatic mass setting<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2Body_GetAutomaticMass")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool BodyGetAutomaticMass([NativeName(NativeNameType.Param, "bodyId")] [NativeName(NativeNameType.Type, "b2BodyId")] B2BodyId bodyId)
		{
			byte ret = BodyGetAutomaticMassNative(bodyId);
			return ret != 0;
		}

		/// <summary>
		/// Adjust the linear damping. Normally this is set in b2BodyDef before creation.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2Body_SetLinearDamping")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void BodySetLinearDampingNative([NativeName(NativeNameType.Param, "bodyId")] [NativeName(NativeNameType.Type, "b2BodyId")] B2BodyId bodyId, [NativeName(NativeNameType.Param, "linearDamping")] [NativeName(NativeNameType.Type, "float")] float linearDamping)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<B2BodyId, float, void>)funcTable[161])(bodyId, linearDamping);
			#else
			((delegate* unmanaged[Cdecl]<B2BodyId, float, void>)funcTable[161])(bodyId, linearDamping);
			#endif
		}

		/// <summary>
		/// Adjust the linear damping. Normally this is set in b2BodyDef before creation.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2Body_SetLinearDamping")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void BodySetLinearDamping([NativeName(NativeNameType.Param, "bodyId")] [NativeName(NativeNameType.Type, "b2BodyId")] B2BodyId bodyId, [NativeName(NativeNameType.Param, "linearDamping")] [NativeName(NativeNameType.Type, "float")] float linearDamping)
		{
			BodySetLinearDampingNative(bodyId, linearDamping);
		}

		/// <summary>
		/// Get the current linear damping.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2Body_GetLinearDamping")]
		[return: NativeName(NativeNameType.Type, "float")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static float BodyGetLinearDampingNative([NativeName(NativeNameType.Param, "bodyId")] [NativeName(NativeNameType.Type, "b2BodyId")] B2BodyId bodyId)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<B2BodyId, float>)funcTable[162])(bodyId);
			#else
			return (float)((delegate* unmanaged[Cdecl]<B2BodyId, float>)funcTable[162])(bodyId);
			#endif
		}

		/// <summary>
		/// Get the current linear damping.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2Body_GetLinearDamping")]
		[return: NativeName(NativeNameType.Type, "float")]
		public static float BodyGetLinearDamping([NativeName(NativeNameType.Param, "bodyId")] [NativeName(NativeNameType.Type, "b2BodyId")] B2BodyId bodyId)
		{
			float ret = BodyGetLinearDampingNative(bodyId);
			return ret;
		}

		/// <summary>
		/// Adjust the angular damping. Normally this is set in b2BodyDef before creation.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2Body_SetAngularDamping")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void BodySetAngularDampingNative([NativeName(NativeNameType.Param, "bodyId")] [NativeName(NativeNameType.Type, "b2BodyId")] B2BodyId bodyId, [NativeName(NativeNameType.Param, "angularDamping")] [NativeName(NativeNameType.Type, "float")] float angularDamping)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<B2BodyId, float, void>)funcTable[163])(bodyId, angularDamping);
			#else
			((delegate* unmanaged[Cdecl]<B2BodyId, float, void>)funcTable[163])(bodyId, angularDamping);
			#endif
		}

		/// <summary>
		/// Adjust the angular damping. Normally this is set in b2BodyDef before creation.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2Body_SetAngularDamping")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void BodySetAngularDamping([NativeName(NativeNameType.Param, "bodyId")] [NativeName(NativeNameType.Type, "b2BodyId")] B2BodyId bodyId, [NativeName(NativeNameType.Param, "angularDamping")] [NativeName(NativeNameType.Type, "float")] float angularDamping)
		{
			BodySetAngularDampingNative(bodyId, angularDamping);
		}

		/// <summary>
		/// Get the current angular damping.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2Body_GetAngularDamping")]
		[return: NativeName(NativeNameType.Type, "float")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static float BodyGetAngularDampingNative([NativeName(NativeNameType.Param, "bodyId")] [NativeName(NativeNameType.Type, "b2BodyId")] B2BodyId bodyId)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<B2BodyId, float>)funcTable[164])(bodyId);
			#else
			return (float)((delegate* unmanaged[Cdecl]<B2BodyId, float>)funcTable[164])(bodyId);
			#endif
		}

		/// <summary>
		/// Get the current angular damping.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2Body_GetAngularDamping")]
		[return: NativeName(NativeNameType.Type, "float")]
		public static float BodyGetAngularDamping([NativeName(NativeNameType.Param, "bodyId")] [NativeName(NativeNameType.Type, "b2BodyId")] B2BodyId bodyId)
		{
			float ret = BodyGetAngularDampingNative(bodyId);
			return ret;
		}

		/// <summary>
		/// Adjust the gravity scale. Normally this is set in b2BodyDef before creation.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2Body_SetGravityScale")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void BodySetGravityScaleNative([NativeName(NativeNameType.Param, "bodyId")] [NativeName(NativeNameType.Type, "b2BodyId")] B2BodyId bodyId, [NativeName(NativeNameType.Param, "gravityScale")] [NativeName(NativeNameType.Type, "float")] float gravityScale)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<B2BodyId, float, void>)funcTable[165])(bodyId, gravityScale);
			#else
			((delegate* unmanaged[Cdecl]<B2BodyId, float, void>)funcTable[165])(bodyId, gravityScale);
			#endif
		}

		/// <summary>
		/// Adjust the gravity scale. Normally this is set in b2BodyDef before creation.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2Body_SetGravityScale")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void BodySetGravityScale([NativeName(NativeNameType.Param, "bodyId")] [NativeName(NativeNameType.Type, "b2BodyId")] B2BodyId bodyId, [NativeName(NativeNameType.Param, "gravityScale")] [NativeName(NativeNameType.Type, "float")] float gravityScale)
		{
			BodySetGravityScaleNative(bodyId, gravityScale);
		}

		/// <summary>
		/// Get the current gravity scale<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2Body_GetGravityScale")]
		[return: NativeName(NativeNameType.Type, "float")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static float BodyGetGravityScaleNative([NativeName(NativeNameType.Param, "bodyId")] [NativeName(NativeNameType.Type, "b2BodyId")] B2BodyId bodyId)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<B2BodyId, float>)funcTable[166])(bodyId);
			#else
			return (float)((delegate* unmanaged[Cdecl]<B2BodyId, float>)funcTable[166])(bodyId);
			#endif
		}

		/// <summary>
		/// Get the current gravity scale<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2Body_GetGravityScale")]
		[return: NativeName(NativeNameType.Type, "float")]
		public static float BodyGetGravityScale([NativeName(NativeNameType.Param, "bodyId")] [NativeName(NativeNameType.Type, "b2BodyId")] B2BodyId bodyId)
		{
			float ret = BodyGetGravityScaleNative(bodyId);
			return ret;
		}

		/// <summary>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2Body_IsAwake")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte BodyIsAwakeNative([NativeName(NativeNameType.Param, "bodyId")] [NativeName(NativeNameType.Type, "b2BodyId")] B2BodyId bodyId)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<B2BodyId, byte>)funcTable[167])(bodyId);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<B2BodyId, byte>)funcTable[167])(bodyId);
			#endif
		}

		/// <summary>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2Body_IsAwake")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool BodyIsAwake([NativeName(NativeNameType.Param, "bodyId")] [NativeName(NativeNameType.Type, "b2BodyId")] B2BodyId bodyId)
		{
			byte ret = BodyIsAwakeNative(bodyId);
			return ret != 0;
		}

		/// <summary>
		/// Wake a body from sleep. This wakes the entire island the body is touching.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2Body_SetAwake")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void BodySetAwakeNative([NativeName(NativeNameType.Param, "bodyId")] [NativeName(NativeNameType.Type, "b2BodyId")] B2BodyId bodyId, [NativeName(NativeNameType.Param, "awake")] [NativeName(NativeNameType.Type, "bool")] byte awake)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<B2BodyId, byte, void>)funcTable[168])(bodyId, awake);
			#else
			((delegate* unmanaged[Cdecl]<B2BodyId, byte, void>)funcTable[168])(bodyId, awake);
			#endif
		}

		/// <summary>
		/// Wake a body from sleep. This wakes the entire island the body is touching.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2Body_SetAwake")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void BodySetAwake([NativeName(NativeNameType.Param, "bodyId")] [NativeName(NativeNameType.Type, "b2BodyId")] B2BodyId bodyId, [NativeName(NativeNameType.Param, "awake")] [NativeName(NativeNameType.Type, "bool")] bool awake)
		{
			BodySetAwakeNative(bodyId, awake ? (byte)1 : (byte)0);
		}

		/// <summary>
		/// Enable or disable sleeping for this body. If sleeping is disabled the body will wake.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2Body_EnableSleep")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void BodyEnableSleepNative([NativeName(NativeNameType.Param, "bodyId")] [NativeName(NativeNameType.Type, "b2BodyId")] B2BodyId bodyId, [NativeName(NativeNameType.Param, "enableSleep")] [NativeName(NativeNameType.Type, "bool")] byte enableSleep)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<B2BodyId, byte, void>)funcTable[169])(bodyId, enableSleep);
			#else
			((delegate* unmanaged[Cdecl]<B2BodyId, byte, void>)funcTable[169])(bodyId, enableSleep);
			#endif
		}

		/// <summary>
		/// Enable or disable sleeping for this body. If sleeping is disabled the body will wake.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2Body_EnableSleep")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void BodyEnableSleep([NativeName(NativeNameType.Param, "bodyId")] [NativeName(NativeNameType.Type, "b2BodyId")] B2BodyId bodyId, [NativeName(NativeNameType.Param, "enableSleep")] [NativeName(NativeNameType.Type, "bool")] bool enableSleep)
		{
			BodyEnableSleepNative(bodyId, enableSleep ? (byte)1 : (byte)0);
		}

		/// <summary>
		/// Returns true if sleeping is enabled for this body<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2Body_IsSleepEnabled")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte BodyIsSleepEnabledNative([NativeName(NativeNameType.Param, "bodyId")] [NativeName(NativeNameType.Type, "b2BodyId")] B2BodyId bodyId)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<B2BodyId, byte>)funcTable[170])(bodyId);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<B2BodyId, byte>)funcTable[170])(bodyId);
			#endif
		}

		/// <summary>
		/// Returns true if sleeping is enabled for this body<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2Body_IsSleepEnabled")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool BodyIsSleepEnabled([NativeName(NativeNameType.Param, "bodyId")] [NativeName(NativeNameType.Type, "b2BodyId")] B2BodyId bodyId)
		{
			byte ret = BodyIsSleepEnabledNative(bodyId);
			return ret != 0;
		}

		/// <summary>
		/// Set the sleep threshold, typically in meters per second<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2Body_SetSleepThreshold")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void BodySetSleepThresholdNative([NativeName(NativeNameType.Param, "bodyId")] [NativeName(NativeNameType.Type, "b2BodyId")] B2BodyId bodyId, [NativeName(NativeNameType.Param, "sleepVelocity")] [NativeName(NativeNameType.Type, "float")] float sleepVelocity)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<B2BodyId, float, void>)funcTable[171])(bodyId, sleepVelocity);
			#else
			((delegate* unmanaged[Cdecl]<B2BodyId, float, void>)funcTable[171])(bodyId, sleepVelocity);
			#endif
		}

		/// <summary>
		/// Set the sleep threshold, typically in meters per second<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2Body_SetSleepThreshold")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void BodySetSleepThreshold([NativeName(NativeNameType.Param, "bodyId")] [NativeName(NativeNameType.Type, "b2BodyId")] B2BodyId bodyId, [NativeName(NativeNameType.Param, "sleepVelocity")] [NativeName(NativeNameType.Type, "float")] float sleepVelocity)
		{
			BodySetSleepThresholdNative(bodyId, sleepVelocity);
		}

		/// <summary>
		/// Get the sleep threshold, typically in meters per second.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2Body_GetSleepThreshold")]
		[return: NativeName(NativeNameType.Type, "float")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static float BodyGetSleepThresholdNative([NativeName(NativeNameType.Param, "bodyId")] [NativeName(NativeNameType.Type, "b2BodyId")] B2BodyId bodyId)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<B2BodyId, float>)funcTable[172])(bodyId);
			#else
			return (float)((delegate* unmanaged[Cdecl]<B2BodyId, float>)funcTable[172])(bodyId);
			#endif
		}

		/// <summary>
		/// Get the sleep threshold, typically in meters per second.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2Body_GetSleepThreshold")]
		[return: NativeName(NativeNameType.Type, "float")]
		public static float BodyGetSleepThreshold([NativeName(NativeNameType.Param, "bodyId")] [NativeName(NativeNameType.Type, "b2BodyId")] B2BodyId bodyId)
		{
			float ret = BodyGetSleepThresholdNative(bodyId);
			return ret;
		}

		/// <summary>
		/// Returns true if this body is enabled<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2Body_IsEnabled")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte BodyIsEnabledNative([NativeName(NativeNameType.Param, "bodyId")] [NativeName(NativeNameType.Type, "b2BodyId")] B2BodyId bodyId)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<B2BodyId, byte>)funcTable[173])(bodyId);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<B2BodyId, byte>)funcTable[173])(bodyId);
			#endif
		}

		/// <summary>
		/// Returns true if this body is enabled<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2Body_IsEnabled")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool BodyIsEnabled([NativeName(NativeNameType.Param, "bodyId")] [NativeName(NativeNameType.Type, "b2BodyId")] B2BodyId bodyId)
		{
			byte ret = BodyIsEnabledNative(bodyId);
			return ret != 0;
		}

		/// <summary>
		/// Disable a body by removing it completely from the simulation. This is expensive.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2Body_Disable")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void BodyDisableNative([NativeName(NativeNameType.Param, "bodyId")] [NativeName(NativeNameType.Type, "b2BodyId")] B2BodyId bodyId)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<B2BodyId, void>)funcTable[174])(bodyId);
			#else
			((delegate* unmanaged[Cdecl]<B2BodyId, void>)funcTable[174])(bodyId);
			#endif
		}

		/// <summary>
		/// Disable a body by removing it completely from the simulation. This is expensive.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2Body_Disable")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void BodyDisable([NativeName(NativeNameType.Param, "bodyId")] [NativeName(NativeNameType.Type, "b2BodyId")] B2BodyId bodyId)
		{
			BodyDisableNative(bodyId);
		}

		/// <summary>
		/// Enable a body by adding it to the simulation. This is expensive.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2Body_Enable")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void BodyEnableNative([NativeName(NativeNameType.Param, "bodyId")] [NativeName(NativeNameType.Type, "b2BodyId")] B2BodyId bodyId)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<B2BodyId, void>)funcTable[175])(bodyId);
			#else
			((delegate* unmanaged[Cdecl]<B2BodyId, void>)funcTable[175])(bodyId);
			#endif
		}

		/// <summary>
		/// Enable a body by adding it to the simulation. This is expensive.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2Body_Enable")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void BodyEnable([NativeName(NativeNameType.Param, "bodyId")] [NativeName(NativeNameType.Type, "b2BodyId")] B2BodyId bodyId)
		{
			BodyEnableNative(bodyId);
		}

		/// <summary>
		/// Set this body to have fixed rotation. This causes the mass to be reset in all cases.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2Body_SetFixedRotation")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void BodySetFixedRotationNative([NativeName(NativeNameType.Param, "bodyId")] [NativeName(NativeNameType.Type, "b2BodyId")] B2BodyId bodyId, [NativeName(NativeNameType.Param, "flag")] [NativeName(NativeNameType.Type, "bool")] byte flag)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<B2BodyId, byte, void>)funcTable[176])(bodyId, flag);
			#else
			((delegate* unmanaged[Cdecl]<B2BodyId, byte, void>)funcTable[176])(bodyId, flag);
			#endif
		}

		/// <summary>
		/// Set this body to have fixed rotation. This causes the mass to be reset in all cases.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2Body_SetFixedRotation")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void BodySetFixedRotation([NativeName(NativeNameType.Param, "bodyId")] [NativeName(NativeNameType.Type, "b2BodyId")] B2BodyId bodyId, [NativeName(NativeNameType.Param, "flag")] [NativeName(NativeNameType.Type, "bool")] bool flag)
		{
			BodySetFixedRotationNative(bodyId, flag ? (byte)1 : (byte)0);
		}

		/// <summary>
		/// Does this body have fixed rotation?<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2Body_IsFixedRotation")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte BodyIsFixedRotationNative([NativeName(NativeNameType.Param, "bodyId")] [NativeName(NativeNameType.Type, "b2BodyId")] B2BodyId bodyId)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<B2BodyId, byte>)funcTable[177])(bodyId);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<B2BodyId, byte>)funcTable[177])(bodyId);
			#endif
		}

		/// <summary>
		/// Does this body have fixed rotation?<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2Body_IsFixedRotation")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool BodyIsFixedRotation([NativeName(NativeNameType.Param, "bodyId")] [NativeName(NativeNameType.Type, "b2BodyId")] B2BodyId bodyId)
		{
			byte ret = BodyIsFixedRotationNative(bodyId);
			return ret != 0;
		}

		/// <summary>
		/// Set this body to be a bullet. A bullet does continuous collision detection<br/>
		/// against dynamic bodies (but not other bullets).<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2Body_SetBullet")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void BodySetBulletNative([NativeName(NativeNameType.Param, "bodyId")] [NativeName(NativeNameType.Type, "b2BodyId")] B2BodyId bodyId, [NativeName(NativeNameType.Param, "flag")] [NativeName(NativeNameType.Type, "bool")] byte flag)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<B2BodyId, byte, void>)funcTable[178])(bodyId, flag);
			#else
			((delegate* unmanaged[Cdecl]<B2BodyId, byte, void>)funcTable[178])(bodyId, flag);
			#endif
		}

		/// <summary>
		/// Set this body to be a bullet. A bullet does continuous collision detection<br/>
		/// against dynamic bodies (but not other bullets).<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2Body_SetBullet")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void BodySetBullet([NativeName(NativeNameType.Param, "bodyId")] [NativeName(NativeNameType.Type, "b2BodyId")] B2BodyId bodyId, [NativeName(NativeNameType.Param, "flag")] [NativeName(NativeNameType.Type, "bool")] bool flag)
		{
			BodySetBulletNative(bodyId, flag ? (byte)1 : (byte)0);
		}

		/// <summary>
		/// Is this body a bullet?<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2Body_IsBullet")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte BodyIsBulletNative([NativeName(NativeNameType.Param, "bodyId")] [NativeName(NativeNameType.Type, "b2BodyId")] B2BodyId bodyId)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<B2BodyId, byte>)funcTable[179])(bodyId);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<B2BodyId, byte>)funcTable[179])(bodyId);
			#endif
		}

		/// <summary>
		/// Is this body a bullet?<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2Body_IsBullet")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool BodyIsBullet([NativeName(NativeNameType.Param, "bodyId")] [NativeName(NativeNameType.Type, "b2BodyId")] B2BodyId bodyId)
		{
			byte ret = BodyIsBulletNative(bodyId);
			return ret != 0;
		}

		/// <summary>
		/// Enable/disable hit events on all shapes<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2Body_EnableHitEvents")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void BodyEnableHitEventsNative([NativeName(NativeNameType.Param, "bodyId")] [NativeName(NativeNameType.Type, "b2BodyId")] B2BodyId bodyId, [NativeName(NativeNameType.Param, "enableHitEvents")] [NativeName(NativeNameType.Type, "bool")] byte enableHitEvents)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<B2BodyId, byte, void>)funcTable[180])(bodyId, enableHitEvents);
			#else
			((delegate* unmanaged[Cdecl]<B2BodyId, byte, void>)funcTable[180])(bodyId, enableHitEvents);
			#endif
		}

		/// <summary>
		/// Enable/disable hit events on all shapes<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2Body_EnableHitEvents")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void BodyEnableHitEvents([NativeName(NativeNameType.Param, "bodyId")] [NativeName(NativeNameType.Type, "b2BodyId")] B2BodyId bodyId, [NativeName(NativeNameType.Param, "enableHitEvents")] [NativeName(NativeNameType.Type, "bool")] bool enableHitEvents)
		{
			BodyEnableHitEventsNative(bodyId, enableHitEvents ? (byte)1 : (byte)0);
		}

		/// <summary>
		/// Get the number of shapes on this body<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2Body_GetShapeCount")]
		[return: NativeName(NativeNameType.Type, "int")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int BodyGetShapeCountNative([NativeName(NativeNameType.Param, "bodyId")] [NativeName(NativeNameType.Type, "b2BodyId")] B2BodyId bodyId)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<B2BodyId, int>)funcTable[181])(bodyId);
			#else
			return (int)((delegate* unmanaged[Cdecl]<B2BodyId, int>)funcTable[181])(bodyId);
			#endif
		}

		/// <summary>
		/// Get the number of shapes on this body<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2Body_GetShapeCount")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int BodyGetShapeCount([NativeName(NativeNameType.Param, "bodyId")] [NativeName(NativeNameType.Type, "b2BodyId")] B2BodyId bodyId)
		{
			int ret = BodyGetShapeCountNative(bodyId);
			return ret;
		}

		/// <summary>
		/// Get the shape ids for all shapes on this body, up to the provided capacity.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2Body_GetShapes")]
		[return: NativeName(NativeNameType.Type, "int")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int BodyGetShapesNative([NativeName(NativeNameType.Param, "bodyId")] [NativeName(NativeNameType.Type, "b2BodyId")] B2BodyId bodyId, [NativeName(NativeNameType.Param, "shapeArray")] [NativeName(NativeNameType.Type, "b2ShapeId *")] B2ShapeId* shapeArray, [NativeName(NativeNameType.Param, "capacity")] [NativeName(NativeNameType.Type, "int")] int capacity)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<B2BodyId, B2ShapeId*, int, int>)funcTable[182])(bodyId, shapeArray, capacity);
			#else
			return (int)((delegate* unmanaged[Cdecl]<B2BodyId, nint, int, int>)funcTable[182])(bodyId, (nint)shapeArray, capacity);
			#endif
		}

		/// <summary>
		/// Get the shape ids for all shapes on this body, up to the provided capacity.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2Body_GetShapes")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int BodyGetShapes([NativeName(NativeNameType.Param, "bodyId")] [NativeName(NativeNameType.Type, "b2BodyId")] B2BodyId bodyId, [NativeName(NativeNameType.Param, "shapeArray")] [NativeName(NativeNameType.Type, "b2ShapeId *")] B2ShapeId* shapeArray, [NativeName(NativeNameType.Param, "capacity")] [NativeName(NativeNameType.Type, "int")] int capacity)
		{
			int ret = BodyGetShapesNative(bodyId, shapeArray, capacity);
			return ret;
		}

		/// <summary>
		/// Get the shape ids for all shapes on this body, up to the provided capacity.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2Body_GetShapes")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int BodyGetShapes([NativeName(NativeNameType.Param, "bodyId")] [NativeName(NativeNameType.Type, "b2BodyId")] B2BodyId bodyId, [NativeName(NativeNameType.Param, "shapeArray")] [NativeName(NativeNameType.Type, "b2ShapeId *")] ref B2ShapeId shapeArray, [NativeName(NativeNameType.Param, "capacity")] [NativeName(NativeNameType.Type, "int")] int capacity)
		{
			fixed (B2ShapeId* pshapeArray = &shapeArray)
			{
				int ret = BodyGetShapesNative(bodyId, (B2ShapeId*)pshapeArray, capacity);
				return ret;
			}
		}

		/// <summary>
		/// Get the number of joints on this body<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2Body_GetJointCount")]
		[return: NativeName(NativeNameType.Type, "int")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int BodyGetJointCountNative([NativeName(NativeNameType.Param, "bodyId")] [NativeName(NativeNameType.Type, "b2BodyId")] B2BodyId bodyId)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<B2BodyId, int>)funcTable[183])(bodyId);
			#else
			return (int)((delegate* unmanaged[Cdecl]<B2BodyId, int>)funcTable[183])(bodyId);
			#endif
		}

		/// <summary>
		/// Get the number of joints on this body<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2Body_GetJointCount")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int BodyGetJointCount([NativeName(NativeNameType.Param, "bodyId")] [NativeName(NativeNameType.Type, "b2BodyId")] B2BodyId bodyId)
		{
			int ret = BodyGetJointCountNative(bodyId);
			return ret;
		}

		/// <summary>
		/// Get the joint ids for all joints on this body, up to the provided capacity<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2Body_GetJoints")]
		[return: NativeName(NativeNameType.Type, "int")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int BodyGetJointsNative([NativeName(NativeNameType.Param, "bodyId")] [NativeName(NativeNameType.Type, "b2BodyId")] B2BodyId bodyId, [NativeName(NativeNameType.Param, "jointArray")] [NativeName(NativeNameType.Type, "b2JointId *")] B2JointId* jointArray, [NativeName(NativeNameType.Param, "capacity")] [NativeName(NativeNameType.Type, "int")] int capacity)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<B2BodyId, B2JointId*, int, int>)funcTable[184])(bodyId, jointArray, capacity);
			#else
			return (int)((delegate* unmanaged[Cdecl]<B2BodyId, nint, int, int>)funcTable[184])(bodyId, (nint)jointArray, capacity);
			#endif
		}

		/// <summary>
		/// Get the joint ids for all joints on this body, up to the provided capacity<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2Body_GetJoints")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int BodyGetJoints([NativeName(NativeNameType.Param, "bodyId")] [NativeName(NativeNameType.Type, "b2BodyId")] B2BodyId bodyId, [NativeName(NativeNameType.Param, "jointArray")] [NativeName(NativeNameType.Type, "b2JointId *")] B2JointId* jointArray, [NativeName(NativeNameType.Param, "capacity")] [NativeName(NativeNameType.Type, "int")] int capacity)
		{
			int ret = BodyGetJointsNative(bodyId, jointArray, capacity);
			return ret;
		}

		/// <summary>
		/// Get the joint ids for all joints on this body, up to the provided capacity<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2Body_GetJoints")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int BodyGetJoints([NativeName(NativeNameType.Param, "bodyId")] [NativeName(NativeNameType.Type, "b2BodyId")] B2BodyId bodyId, [NativeName(NativeNameType.Param, "jointArray")] [NativeName(NativeNameType.Type, "b2JointId *")] ref B2JointId jointArray, [NativeName(NativeNameType.Param, "capacity")] [NativeName(NativeNameType.Type, "int")] int capacity)
		{
			fixed (B2JointId* pjointArray = &jointArray)
			{
				int ret = BodyGetJointsNative(bodyId, (B2JointId*)pjointArray, capacity);
				return ret;
			}
		}

		/// <summary>
		/// Get the maximum capacity required for retrieving all the touching contacts on a body<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2Body_GetContactCapacity")]
		[return: NativeName(NativeNameType.Type, "int")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int BodyGetContactCapacityNative([NativeName(NativeNameType.Param, "bodyId")] [NativeName(NativeNameType.Type, "b2BodyId")] B2BodyId bodyId)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<B2BodyId, int>)funcTable[185])(bodyId);
			#else
			return (int)((delegate* unmanaged[Cdecl]<B2BodyId, int>)funcTable[185])(bodyId);
			#endif
		}

		/// <summary>
		/// Get the maximum capacity required for retrieving all the touching contacts on a body<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2Body_GetContactCapacity")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int BodyGetContactCapacity([NativeName(NativeNameType.Param, "bodyId")] [NativeName(NativeNameType.Type, "b2BodyId")] B2BodyId bodyId)
		{
			int ret = BodyGetContactCapacityNative(bodyId);
			return ret;
		}

		/// <summary>
		/// Get the touching contact data for a body<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2Body_GetContactData")]
		[return: NativeName(NativeNameType.Type, "int")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int BodyGetContactDataNative([NativeName(NativeNameType.Param, "bodyId")] [NativeName(NativeNameType.Type, "b2BodyId")] B2BodyId bodyId, [NativeName(NativeNameType.Param, "contactData")] [NativeName(NativeNameType.Type, "b2ContactData *")] B2ContactData* contactData, [NativeName(NativeNameType.Param, "capacity")] [NativeName(NativeNameType.Type, "int")] int capacity)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<B2BodyId, B2ContactData*, int, int>)funcTable[186])(bodyId, contactData, capacity);
			#else
			return (int)((delegate* unmanaged[Cdecl]<B2BodyId, nint, int, int>)funcTable[186])(bodyId, (nint)contactData, capacity);
			#endif
		}

		/// <summary>
		/// Get the touching contact data for a body<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2Body_GetContactData")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int BodyGetContactData([NativeName(NativeNameType.Param, "bodyId")] [NativeName(NativeNameType.Type, "b2BodyId")] B2BodyId bodyId, [NativeName(NativeNameType.Param, "contactData")] [NativeName(NativeNameType.Type, "b2ContactData *")] B2ContactData* contactData, [NativeName(NativeNameType.Param, "capacity")] [NativeName(NativeNameType.Type, "int")] int capacity)
		{
			int ret = BodyGetContactDataNative(bodyId, contactData, capacity);
			return ret;
		}

		/// <summary>
		/// Get the touching contact data for a body<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2Body_GetContactData")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int BodyGetContactData([NativeName(NativeNameType.Param, "bodyId")] [NativeName(NativeNameType.Type, "b2BodyId")] B2BodyId bodyId, [NativeName(NativeNameType.Param, "contactData")] [NativeName(NativeNameType.Type, "b2ContactData *")] ref B2ContactData contactData, [NativeName(NativeNameType.Param, "capacity")] [NativeName(NativeNameType.Type, "int")] int capacity)
		{
			fixed (B2ContactData* pcontactData = &contactData)
			{
				int ret = BodyGetContactDataNative(bodyId, (B2ContactData*)pcontactData, capacity);
				return ret;
			}
		}

		/// <summary>
		/// Get the current world AABB that contains all the attached shapes. Note that this may not encompass the body origin.<br/>
		/// If there are no shapes attached then the returned AABB is empty and centered on the body origin.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2Body_ComputeAABB")]
		[return: NativeName(NativeNameType.Type, "b2AABB")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static B2AABB BodyComputeAABBNative([NativeName(NativeNameType.Param, "bodyId")] [NativeName(NativeNameType.Type, "b2BodyId")] B2BodyId bodyId)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<B2BodyId, B2AABB>)funcTable[187])(bodyId);
			#else
			return (B2AABB)((delegate* unmanaged[Cdecl]<B2BodyId, B2AABB>)funcTable[187])(bodyId);
			#endif
		}

		/// <summary>
		/// Get the current world AABB that contains all the attached shapes. Note that this may not encompass the body origin.<br/>
		/// If there are no shapes attached then the returned AABB is empty and centered on the body origin.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2Body_ComputeAABB")]
		[return: NativeName(NativeNameType.Type, "b2AABB")]
		public static B2AABB BodyComputeAABB([NativeName(NativeNameType.Param, "bodyId")] [NativeName(NativeNameType.Type, "b2BodyId")] B2BodyId bodyId)
		{
			B2AABB ret = BodyComputeAABBNative(bodyId);
			return ret;
		}

		/// <summary>
		/// Create a circle shape and attach it to a body. The shape definition and geometry are fully cloned.<br/>
		/// Contacts are not created until the next time step.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2CreateCircleShape")]
		[return: NativeName(NativeNameType.Type, "b2ShapeId")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static B2ShapeId CreateCircleShapeNative([NativeName(NativeNameType.Param, "bodyId")] [NativeName(NativeNameType.Type, "b2BodyId")] B2BodyId bodyId, [NativeName(NativeNameType.Param, "def")] [NativeName(NativeNameType.Type, "b2ShapeDef const *")] B2ShapeDef* def, [NativeName(NativeNameType.Param, "circle")] [NativeName(NativeNameType.Type, "b2Circle const *")] B2Circle* circle)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<B2BodyId, B2ShapeDef*, B2Circle*, B2ShapeId>)funcTable[188])(bodyId, def, circle);
			#else
			return (B2ShapeId)((delegate* unmanaged[Cdecl]<B2BodyId, nint, nint, B2ShapeId>)funcTable[188])(bodyId, (nint)def, (nint)circle);
			#endif
		}

		/// <summary>
		/// Create a circle shape and attach it to a body. The shape definition and geometry are fully cloned.<br/>
		/// Contacts are not created until the next time step.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2CreateCircleShape")]
		[return: NativeName(NativeNameType.Type, "b2ShapeId")]
		public static B2ShapeId CreateCircleShape([NativeName(NativeNameType.Param, "bodyId")] [NativeName(NativeNameType.Type, "b2BodyId")] B2BodyId bodyId, [NativeName(NativeNameType.Param, "def")] [NativeName(NativeNameType.Type, "b2ShapeDef const *")] B2ShapeDef* def, [NativeName(NativeNameType.Param, "circle")] [NativeName(NativeNameType.Type, "b2Circle const *")] B2Circle* circle)
		{
			B2ShapeId ret = CreateCircleShapeNative(bodyId, def, circle);
			return ret;
		}

		/// <summary>
		/// Create a circle shape and attach it to a body. The shape definition and geometry are fully cloned.<br/>
		/// Contacts are not created until the next time step.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2CreateCircleShape")]
		[return: NativeName(NativeNameType.Type, "b2ShapeId")]
		public static B2ShapeId CreateCircleShape([NativeName(NativeNameType.Param, "bodyId")] [NativeName(NativeNameType.Type, "b2BodyId")] B2BodyId bodyId, [NativeName(NativeNameType.Param, "def")] [NativeName(NativeNameType.Type, "b2ShapeDef const *")] ref B2ShapeDef def, [NativeName(NativeNameType.Param, "circle")] [NativeName(NativeNameType.Type, "b2Circle const *")] B2Circle* circle)
		{
			fixed (B2ShapeDef* pdef = &def)
			{
				B2ShapeId ret = CreateCircleShapeNative(bodyId, (B2ShapeDef*)pdef, circle);
				return ret;
			}
		}

		/// <summary>
		/// Create a circle shape and attach it to a body. The shape definition and geometry are fully cloned.<br/>
		/// Contacts are not created until the next time step.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2CreateCircleShape")]
		[return: NativeName(NativeNameType.Type, "b2ShapeId")]
		public static B2ShapeId CreateCircleShape([NativeName(NativeNameType.Param, "bodyId")] [NativeName(NativeNameType.Type, "b2BodyId")] B2BodyId bodyId, [NativeName(NativeNameType.Param, "def")] [NativeName(NativeNameType.Type, "b2ShapeDef const *")] B2ShapeDef* def, [NativeName(NativeNameType.Param, "circle")] [NativeName(NativeNameType.Type, "b2Circle const *")] ref B2Circle circle)
		{
			fixed (B2Circle* pcircle = &circle)
			{
				B2ShapeId ret = CreateCircleShapeNative(bodyId, def, (B2Circle*)pcircle);
				return ret;
			}
		}

		/// <summary>
		/// Create a circle shape and attach it to a body. The shape definition and geometry are fully cloned.<br/>
		/// Contacts are not created until the next time step.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2CreateCircleShape")]
		[return: NativeName(NativeNameType.Type, "b2ShapeId")]
		public static B2ShapeId CreateCircleShape([NativeName(NativeNameType.Param, "bodyId")] [NativeName(NativeNameType.Type, "b2BodyId")] B2BodyId bodyId, [NativeName(NativeNameType.Param, "def")] [NativeName(NativeNameType.Type, "b2ShapeDef const *")] ref B2ShapeDef def, [NativeName(NativeNameType.Param, "circle")] [NativeName(NativeNameType.Type, "b2Circle const *")] ref B2Circle circle)
		{
			fixed (B2ShapeDef* pdef = &def)
			{
				fixed (B2Circle* pcircle = &circle)
				{
					B2ShapeId ret = CreateCircleShapeNative(bodyId, (B2ShapeDef*)pdef, (B2Circle*)pcircle);
					return ret;
				}
			}
		}

		/// <summary>
		/// Create a line segment shape and attach it to a body. The shape definition and geometry are fully cloned.<br/>
		/// Contacts are not created until the next time step.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2CreateSegmentShape")]
		[return: NativeName(NativeNameType.Type, "b2ShapeId")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static B2ShapeId CreateSegmentShapeNative([NativeName(NativeNameType.Param, "bodyId")] [NativeName(NativeNameType.Type, "b2BodyId")] B2BodyId bodyId, [NativeName(NativeNameType.Param, "def")] [NativeName(NativeNameType.Type, "b2ShapeDef const *")] B2ShapeDef* def, [NativeName(NativeNameType.Param, "segment")] [NativeName(NativeNameType.Type, "b2Segment const *")] B2Segment* segment)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<B2BodyId, B2ShapeDef*, B2Segment*, B2ShapeId>)funcTable[189])(bodyId, def, segment);
			#else
			return (B2ShapeId)((delegate* unmanaged[Cdecl]<B2BodyId, nint, nint, B2ShapeId>)funcTable[189])(bodyId, (nint)def, (nint)segment);
			#endif
		}

		/// <summary>
		/// Create a line segment shape and attach it to a body. The shape definition and geometry are fully cloned.<br/>
		/// Contacts are not created until the next time step.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2CreateSegmentShape")]
		[return: NativeName(NativeNameType.Type, "b2ShapeId")]
		public static B2ShapeId CreateSegmentShape([NativeName(NativeNameType.Param, "bodyId")] [NativeName(NativeNameType.Type, "b2BodyId")] B2BodyId bodyId, [NativeName(NativeNameType.Param, "def")] [NativeName(NativeNameType.Type, "b2ShapeDef const *")] B2ShapeDef* def, [NativeName(NativeNameType.Param, "segment")] [NativeName(NativeNameType.Type, "b2Segment const *")] B2Segment* segment)
		{
			B2ShapeId ret = CreateSegmentShapeNative(bodyId, def, segment);
			return ret;
		}

		/// <summary>
		/// Create a line segment shape and attach it to a body. The shape definition and geometry are fully cloned.<br/>
		/// Contacts are not created until the next time step.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2CreateSegmentShape")]
		[return: NativeName(NativeNameType.Type, "b2ShapeId")]
		public static B2ShapeId CreateSegmentShape([NativeName(NativeNameType.Param, "bodyId")] [NativeName(NativeNameType.Type, "b2BodyId")] B2BodyId bodyId, [NativeName(NativeNameType.Param, "def")] [NativeName(NativeNameType.Type, "b2ShapeDef const *")] ref B2ShapeDef def, [NativeName(NativeNameType.Param, "segment")] [NativeName(NativeNameType.Type, "b2Segment const *")] B2Segment* segment)
		{
			fixed (B2ShapeDef* pdef = &def)
			{
				B2ShapeId ret = CreateSegmentShapeNative(bodyId, (B2ShapeDef*)pdef, segment);
				return ret;
			}
		}

		/// <summary>
		/// Create a line segment shape and attach it to a body. The shape definition and geometry are fully cloned.<br/>
		/// Contacts are not created until the next time step.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2CreateSegmentShape")]
		[return: NativeName(NativeNameType.Type, "b2ShapeId")]
		public static B2ShapeId CreateSegmentShape([NativeName(NativeNameType.Param, "bodyId")] [NativeName(NativeNameType.Type, "b2BodyId")] B2BodyId bodyId, [NativeName(NativeNameType.Param, "def")] [NativeName(NativeNameType.Type, "b2ShapeDef const *")] B2ShapeDef* def, [NativeName(NativeNameType.Param, "segment")] [NativeName(NativeNameType.Type, "b2Segment const *")] ref B2Segment segment)
		{
			fixed (B2Segment* psegment = &segment)
			{
				B2ShapeId ret = CreateSegmentShapeNative(bodyId, def, (B2Segment*)psegment);
				return ret;
			}
		}

		/// <summary>
		/// Create a line segment shape and attach it to a body. The shape definition and geometry are fully cloned.<br/>
		/// Contacts are not created until the next time step.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2CreateSegmentShape")]
		[return: NativeName(NativeNameType.Type, "b2ShapeId")]
		public static B2ShapeId CreateSegmentShape([NativeName(NativeNameType.Param, "bodyId")] [NativeName(NativeNameType.Type, "b2BodyId")] B2BodyId bodyId, [NativeName(NativeNameType.Param, "def")] [NativeName(NativeNameType.Type, "b2ShapeDef const *")] ref B2ShapeDef def, [NativeName(NativeNameType.Param, "segment")] [NativeName(NativeNameType.Type, "b2Segment const *")] ref B2Segment segment)
		{
			fixed (B2ShapeDef* pdef = &def)
			{
				fixed (B2Segment* psegment = &segment)
				{
					B2ShapeId ret = CreateSegmentShapeNative(bodyId, (B2ShapeDef*)pdef, (B2Segment*)psegment);
					return ret;
				}
			}
		}

		/// <summary>
		/// Create a capsule shape and attach it to a body. The shape definition and geometry are fully cloned.<br/>
		/// Contacts are not created until the next time step.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2CreateCapsuleShape")]
		[return: NativeName(NativeNameType.Type, "b2ShapeId")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static B2ShapeId CreateCapsuleShapeNative([NativeName(NativeNameType.Param, "bodyId")] [NativeName(NativeNameType.Type, "b2BodyId")] B2BodyId bodyId, [NativeName(NativeNameType.Param, "def")] [NativeName(NativeNameType.Type, "b2ShapeDef const *")] B2ShapeDef* def, [NativeName(NativeNameType.Param, "capsule")] [NativeName(NativeNameType.Type, "b2Capsule const *")] B2Capsule* capsule)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<B2BodyId, B2ShapeDef*, B2Capsule*, B2ShapeId>)funcTable[190])(bodyId, def, capsule);
			#else
			return (B2ShapeId)((delegate* unmanaged[Cdecl]<B2BodyId, nint, nint, B2ShapeId>)funcTable[190])(bodyId, (nint)def, (nint)capsule);
			#endif
		}

		/// <summary>
		/// Create a capsule shape and attach it to a body. The shape definition and geometry are fully cloned.<br/>
		/// Contacts are not created until the next time step.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2CreateCapsuleShape")]
		[return: NativeName(NativeNameType.Type, "b2ShapeId")]
		public static B2ShapeId CreateCapsuleShape([NativeName(NativeNameType.Param, "bodyId")] [NativeName(NativeNameType.Type, "b2BodyId")] B2BodyId bodyId, [NativeName(NativeNameType.Param, "def")] [NativeName(NativeNameType.Type, "b2ShapeDef const *")] B2ShapeDef* def, [NativeName(NativeNameType.Param, "capsule")] [NativeName(NativeNameType.Type, "b2Capsule const *")] B2Capsule* capsule)
		{
			B2ShapeId ret = CreateCapsuleShapeNative(bodyId, def, capsule);
			return ret;
		}

		/// <summary>
		/// Create a capsule shape and attach it to a body. The shape definition and geometry are fully cloned.<br/>
		/// Contacts are not created until the next time step.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2CreateCapsuleShape")]
		[return: NativeName(NativeNameType.Type, "b2ShapeId")]
		public static B2ShapeId CreateCapsuleShape([NativeName(NativeNameType.Param, "bodyId")] [NativeName(NativeNameType.Type, "b2BodyId")] B2BodyId bodyId, [NativeName(NativeNameType.Param, "def")] [NativeName(NativeNameType.Type, "b2ShapeDef const *")] ref B2ShapeDef def, [NativeName(NativeNameType.Param, "capsule")] [NativeName(NativeNameType.Type, "b2Capsule const *")] B2Capsule* capsule)
		{
			fixed (B2ShapeDef* pdef = &def)
			{
				B2ShapeId ret = CreateCapsuleShapeNative(bodyId, (B2ShapeDef*)pdef, capsule);
				return ret;
			}
		}

		/// <summary>
		/// Create a capsule shape and attach it to a body. The shape definition and geometry are fully cloned.<br/>
		/// Contacts are not created until the next time step.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2CreateCapsuleShape")]
		[return: NativeName(NativeNameType.Type, "b2ShapeId")]
		public static B2ShapeId CreateCapsuleShape([NativeName(NativeNameType.Param, "bodyId")] [NativeName(NativeNameType.Type, "b2BodyId")] B2BodyId bodyId, [NativeName(NativeNameType.Param, "def")] [NativeName(NativeNameType.Type, "b2ShapeDef const *")] B2ShapeDef* def, [NativeName(NativeNameType.Param, "capsule")] [NativeName(NativeNameType.Type, "b2Capsule const *")] ref B2Capsule capsule)
		{
			fixed (B2Capsule* pcapsule = &capsule)
			{
				B2ShapeId ret = CreateCapsuleShapeNative(bodyId, def, (B2Capsule*)pcapsule);
				return ret;
			}
		}

		/// <summary>
		/// Create a capsule shape and attach it to a body. The shape definition and geometry are fully cloned.<br/>
		/// Contacts are not created until the next time step.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2CreateCapsuleShape")]
		[return: NativeName(NativeNameType.Type, "b2ShapeId")]
		public static B2ShapeId CreateCapsuleShape([NativeName(NativeNameType.Param, "bodyId")] [NativeName(NativeNameType.Type, "b2BodyId")] B2BodyId bodyId, [NativeName(NativeNameType.Param, "def")] [NativeName(NativeNameType.Type, "b2ShapeDef const *")] ref B2ShapeDef def, [NativeName(NativeNameType.Param, "capsule")] [NativeName(NativeNameType.Type, "b2Capsule const *")] ref B2Capsule capsule)
		{
			fixed (B2ShapeDef* pdef = &def)
			{
				fixed (B2Capsule* pcapsule = &capsule)
				{
					B2ShapeId ret = CreateCapsuleShapeNative(bodyId, (B2ShapeDef*)pdef, (B2Capsule*)pcapsule);
					return ret;
				}
			}
		}

		/// <summary>
		/// Create a polygon shape and attach it to a body. The shape definition and geometry are fully cloned.<br/>
		/// Contacts are not created until the next time step.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2CreatePolygonShape")]
		[return: NativeName(NativeNameType.Type, "b2ShapeId")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static B2ShapeId CreatePolygonShapeNative([NativeName(NativeNameType.Param, "bodyId")] [NativeName(NativeNameType.Type, "b2BodyId")] B2BodyId bodyId, [NativeName(NativeNameType.Param, "def")] [NativeName(NativeNameType.Type, "b2ShapeDef const *")] B2ShapeDef* def, [NativeName(NativeNameType.Param, "polygon")] [NativeName(NativeNameType.Type, "b2Polygon const *")] B2Polygon* polygon)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<B2BodyId, B2ShapeDef*, B2Polygon*, B2ShapeId>)funcTable[191])(bodyId, def, polygon);
			#else
			return (B2ShapeId)((delegate* unmanaged[Cdecl]<B2BodyId, nint, nint, B2ShapeId>)funcTable[191])(bodyId, (nint)def, (nint)polygon);
			#endif
		}

		/// <summary>
		/// Create a polygon shape and attach it to a body. The shape definition and geometry are fully cloned.<br/>
		/// Contacts are not created until the next time step.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2CreatePolygonShape")]
		[return: NativeName(NativeNameType.Type, "b2ShapeId")]
		public static B2ShapeId CreatePolygonShape([NativeName(NativeNameType.Param, "bodyId")] [NativeName(NativeNameType.Type, "b2BodyId")] B2BodyId bodyId, [NativeName(NativeNameType.Param, "def")] [NativeName(NativeNameType.Type, "b2ShapeDef const *")] B2ShapeDef* def, [NativeName(NativeNameType.Param, "polygon")] [NativeName(NativeNameType.Type, "b2Polygon const *")] B2Polygon* polygon)
		{
			B2ShapeId ret = CreatePolygonShapeNative(bodyId, def, polygon);
			return ret;
		}

		/// <summary>
		/// Create a polygon shape and attach it to a body. The shape definition and geometry are fully cloned.<br/>
		/// Contacts are not created until the next time step.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2CreatePolygonShape")]
		[return: NativeName(NativeNameType.Type, "b2ShapeId")]
		public static B2ShapeId CreatePolygonShape([NativeName(NativeNameType.Param, "bodyId")] [NativeName(NativeNameType.Type, "b2BodyId")] B2BodyId bodyId, [NativeName(NativeNameType.Param, "def")] [NativeName(NativeNameType.Type, "b2ShapeDef const *")] ref B2ShapeDef def, [NativeName(NativeNameType.Param, "polygon")] [NativeName(NativeNameType.Type, "b2Polygon const *")] B2Polygon* polygon)
		{
			fixed (B2ShapeDef* pdef = &def)
			{
				B2ShapeId ret = CreatePolygonShapeNative(bodyId, (B2ShapeDef*)pdef, polygon);
				return ret;
			}
		}

		/// <summary>
		/// Create a polygon shape and attach it to a body. The shape definition and geometry are fully cloned.<br/>
		/// Contacts are not created until the next time step.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2CreatePolygonShape")]
		[return: NativeName(NativeNameType.Type, "b2ShapeId")]
		public static B2ShapeId CreatePolygonShape([NativeName(NativeNameType.Param, "bodyId")] [NativeName(NativeNameType.Type, "b2BodyId")] B2BodyId bodyId, [NativeName(NativeNameType.Param, "def")] [NativeName(NativeNameType.Type, "b2ShapeDef const *")] B2ShapeDef* def, [NativeName(NativeNameType.Param, "polygon")] [NativeName(NativeNameType.Type, "b2Polygon const *")] ref B2Polygon polygon)
		{
			fixed (B2Polygon* ppolygon = &polygon)
			{
				B2ShapeId ret = CreatePolygonShapeNative(bodyId, def, (B2Polygon*)ppolygon);
				return ret;
			}
		}

		/// <summary>
		/// Create a polygon shape and attach it to a body. The shape definition and geometry are fully cloned.<br/>
		/// Contacts are not created until the next time step.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2CreatePolygonShape")]
		[return: NativeName(NativeNameType.Type, "b2ShapeId")]
		public static B2ShapeId CreatePolygonShape([NativeName(NativeNameType.Param, "bodyId")] [NativeName(NativeNameType.Type, "b2BodyId")] B2BodyId bodyId, [NativeName(NativeNameType.Param, "def")] [NativeName(NativeNameType.Type, "b2ShapeDef const *")] ref B2ShapeDef def, [NativeName(NativeNameType.Param, "polygon")] [NativeName(NativeNameType.Type, "b2Polygon const *")] ref B2Polygon polygon)
		{
			fixed (B2ShapeDef* pdef = &def)
			{
				fixed (B2Polygon* ppolygon = &polygon)
				{
					B2ShapeId ret = CreatePolygonShapeNative(bodyId, (B2ShapeDef*)pdef, (B2Polygon*)ppolygon);
					return ret;
				}
			}
		}

		/// <summary>
		/// Destroy a shape<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2DestroyShape")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DestroyShapeNative([NativeName(NativeNameType.Param, "shapeId")] [NativeName(NativeNameType.Type, "b2ShapeId")] B2ShapeId shapeId)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<B2ShapeId, void>)funcTable[192])(shapeId);
			#else
			((delegate* unmanaged[Cdecl]<B2ShapeId, void>)funcTable[192])(shapeId);
			#endif
		}

		/// <summary>
		/// Destroy a shape<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2DestroyShape")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void DestroyShape([NativeName(NativeNameType.Param, "shapeId")] [NativeName(NativeNameType.Type, "b2ShapeId")] B2ShapeId shapeId)
		{
			DestroyShapeNative(shapeId);
		}

		/// <summary>
		/// Shape identifier validation. Provides validation for up to 64K allocations.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2Shape_IsValid")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte ShapeIsValidNative([NativeName(NativeNameType.Param, "id")] [NativeName(NativeNameType.Type, "b2ShapeId")] B2ShapeId id)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<B2ShapeId, byte>)funcTable[193])(id);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<B2ShapeId, byte>)funcTable[193])(id);
			#endif
		}

		/// <summary>
		/// Shape identifier validation. Provides validation for up to 64K allocations.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2Shape_IsValid")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool ShapeIsValid([NativeName(NativeNameType.Param, "id")] [NativeName(NativeNameType.Type, "b2ShapeId")] B2ShapeId id)
		{
			byte ret = ShapeIsValidNative(id);
			return ret != 0;
		}

		/// <summary>
		/// Get the type of a shape<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2Shape_GetType")]
		[return: NativeName(NativeNameType.Type, "b2ShapeType")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static B2ShapeType ShapeGetTypeNative([NativeName(NativeNameType.Param, "shapeId")] [NativeName(NativeNameType.Type, "b2ShapeId")] B2ShapeId shapeId)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<B2ShapeId, B2ShapeType>)funcTable[194])(shapeId);
			#else
			return (B2ShapeType)((delegate* unmanaged[Cdecl]<B2ShapeId, B2ShapeType>)funcTable[194])(shapeId);
			#endif
		}

		/// <summary>
		/// Get the type of a shape<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2Shape_GetType")]
		[return: NativeName(NativeNameType.Type, "b2ShapeType")]
		public static B2ShapeType ShapeGetType([NativeName(NativeNameType.Param, "shapeId")] [NativeName(NativeNameType.Type, "b2ShapeId")] B2ShapeId shapeId)
		{
			B2ShapeType ret = ShapeGetTypeNative(shapeId);
			return ret;
		}

		/// <summary>
		/// Get the id of the body that a shape is attached to<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2Shape_GetBody")]
		[return: NativeName(NativeNameType.Type, "b2BodyId")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static B2BodyId ShapeGetBodyNative([NativeName(NativeNameType.Param, "shapeId")] [NativeName(NativeNameType.Type, "b2ShapeId")] B2ShapeId shapeId)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<B2ShapeId, B2BodyId>)funcTable[195])(shapeId);
			#else
			return (B2BodyId)((delegate* unmanaged[Cdecl]<B2ShapeId, B2BodyId>)funcTable[195])(shapeId);
			#endif
		}

		/// <summary>
		/// Get the id of the body that a shape is attached to<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2Shape_GetBody")]
		[return: NativeName(NativeNameType.Type, "b2BodyId")]
		public static B2BodyId ShapeGetBody([NativeName(NativeNameType.Param, "shapeId")] [NativeName(NativeNameType.Type, "b2ShapeId")] B2ShapeId shapeId)
		{
			B2BodyId ret = ShapeGetBodyNative(shapeId);
			return ret;
		}

		/// <summary>
		/// Returns true If the shape is a sensor<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2Shape_IsSensor")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte ShapeIsSensorNative([NativeName(NativeNameType.Param, "shapeId")] [NativeName(NativeNameType.Type, "b2ShapeId")] B2ShapeId shapeId)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<B2ShapeId, byte>)funcTable[196])(shapeId);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<B2ShapeId, byte>)funcTable[196])(shapeId);
			#endif
		}

		/// <summary>
		/// Returns true If the shape is a sensor<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2Shape_IsSensor")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool ShapeIsSensor([NativeName(NativeNameType.Param, "shapeId")] [NativeName(NativeNameType.Type, "b2ShapeId")] B2ShapeId shapeId)
		{
			byte ret = ShapeIsSensorNative(shapeId);
			return ret != 0;
		}

		/// <summary>
		/// Set the user data for a shape<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2Shape_SetUserData")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ShapeSetUserDataNative([NativeName(NativeNameType.Param, "shapeId")] [NativeName(NativeNameType.Type, "b2ShapeId")] B2ShapeId shapeId, [NativeName(NativeNameType.Param, "userData")] [NativeName(NativeNameType.Type, "void *")] void* userData)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<B2ShapeId, void*, void>)funcTable[197])(shapeId, userData);
			#else
			((delegate* unmanaged[Cdecl]<B2ShapeId, nint, void>)funcTable[197])(shapeId, (nint)userData);
			#endif
		}

		/// <summary>
		/// Set the user data for a shape<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2Shape_SetUserData")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void ShapeSetUserData([NativeName(NativeNameType.Param, "shapeId")] [NativeName(NativeNameType.Type, "b2ShapeId")] B2ShapeId shapeId, [NativeName(NativeNameType.Param, "userData")] [NativeName(NativeNameType.Type, "void *")] void* userData)
		{
			ShapeSetUserDataNative(shapeId, userData);
		}

		/// <summary>
		/// Get the user data for a shape. This is useful when you get a shape id<br/>
		/// from an event or query.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2Shape_GetUserData")]
		[return: NativeName(NativeNameType.Type, "void *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void* ShapeGetUserDataNative([NativeName(NativeNameType.Param, "shapeId")] [NativeName(NativeNameType.Type, "b2ShapeId")] B2ShapeId shapeId)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<B2ShapeId, void*>)funcTable[198])(shapeId);
			#else
			return (void*)((delegate* unmanaged[Cdecl]<B2ShapeId, nint>)funcTable[198])(shapeId);
			#endif
		}

		/// <summary>
		/// Get the user data for a shape. This is useful when you get a shape id<br/>
		/// from an event or query.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2Shape_GetUserData")]
		[return: NativeName(NativeNameType.Type, "void *")]
		public static void* ShapeGetUserData([NativeName(NativeNameType.Param, "shapeId")] [NativeName(NativeNameType.Type, "b2ShapeId")] B2ShapeId shapeId)
		{
			void* ret = ShapeGetUserDataNative(shapeId);
			return ret;
		}

		/// <summary>
		/// Set the mass density of a shape, typically in kg/m^2.<br/>
		/// This will not update the mass properties on the parent body.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2Shape_SetDensity")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ShapeSetDensityNative([NativeName(NativeNameType.Param, "shapeId")] [NativeName(NativeNameType.Type, "b2ShapeId")] B2ShapeId shapeId, [NativeName(NativeNameType.Param, "density")] [NativeName(NativeNameType.Type, "float")] float density)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<B2ShapeId, float, void>)funcTable[199])(shapeId, density);
			#else
			((delegate* unmanaged[Cdecl]<B2ShapeId, float, void>)funcTable[199])(shapeId, density);
			#endif
		}

		/// <summary>
		/// Set the mass density of a shape, typically in kg/m^2.<br/>
		/// This will not update the mass properties on the parent body.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2Shape_SetDensity")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void ShapeSetDensity([NativeName(NativeNameType.Param, "shapeId")] [NativeName(NativeNameType.Type, "b2ShapeId")] B2ShapeId shapeId, [NativeName(NativeNameType.Param, "density")] [NativeName(NativeNameType.Type, "float")] float density)
		{
			ShapeSetDensityNative(shapeId, density);
		}

		/// <summary>
		/// Get the density of a shape, typically in kg/m^2<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2Shape_GetDensity")]
		[return: NativeName(NativeNameType.Type, "float")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static float ShapeGetDensityNative([NativeName(NativeNameType.Param, "shapeId")] [NativeName(NativeNameType.Type, "b2ShapeId")] B2ShapeId shapeId)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<B2ShapeId, float>)funcTable[200])(shapeId);
			#else
			return (float)((delegate* unmanaged[Cdecl]<B2ShapeId, float>)funcTable[200])(shapeId);
			#endif
		}

		/// <summary>
		/// Get the density of a shape, typically in kg/m^2<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2Shape_GetDensity")]
		[return: NativeName(NativeNameType.Type, "float")]
		public static float ShapeGetDensity([NativeName(NativeNameType.Param, "shapeId")] [NativeName(NativeNameType.Type, "b2ShapeId")] B2ShapeId shapeId)
		{
			float ret = ShapeGetDensityNative(shapeId);
			return ret;
		}

		/// <summary>
		/// Set the friction on a shape<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2Shape_SetFriction")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ShapeSetFrictionNative([NativeName(NativeNameType.Param, "shapeId")] [NativeName(NativeNameType.Type, "b2ShapeId")] B2ShapeId shapeId, [NativeName(NativeNameType.Param, "friction")] [NativeName(NativeNameType.Type, "float")] float friction)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<B2ShapeId, float, void>)funcTable[201])(shapeId, friction);
			#else
			((delegate* unmanaged[Cdecl]<B2ShapeId, float, void>)funcTable[201])(shapeId, friction);
			#endif
		}

		/// <summary>
		/// Set the friction on a shape<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2Shape_SetFriction")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void ShapeSetFriction([NativeName(NativeNameType.Param, "shapeId")] [NativeName(NativeNameType.Type, "b2ShapeId")] B2ShapeId shapeId, [NativeName(NativeNameType.Param, "friction")] [NativeName(NativeNameType.Type, "float")] float friction)
		{
			ShapeSetFrictionNative(shapeId, friction);
		}

		/// <summary>
		/// Get the friction of a shape<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2Shape_GetFriction")]
		[return: NativeName(NativeNameType.Type, "float")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static float ShapeGetFrictionNative([NativeName(NativeNameType.Param, "shapeId")] [NativeName(NativeNameType.Type, "b2ShapeId")] B2ShapeId shapeId)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<B2ShapeId, float>)funcTable[202])(shapeId);
			#else
			return (float)((delegate* unmanaged[Cdecl]<B2ShapeId, float>)funcTable[202])(shapeId);
			#endif
		}

		/// <summary>
		/// Get the friction of a shape<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2Shape_GetFriction")]
		[return: NativeName(NativeNameType.Type, "float")]
		public static float ShapeGetFriction([NativeName(NativeNameType.Param, "shapeId")] [NativeName(NativeNameType.Type, "b2ShapeId")] B2ShapeId shapeId)
		{
			float ret = ShapeGetFrictionNative(shapeId);
			return ret;
		}

		/// <summary>
		/// Set the shape restitution (bounciness)<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2Shape_SetRestitution")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ShapeSetRestitutionNative([NativeName(NativeNameType.Param, "shapeId")] [NativeName(NativeNameType.Type, "b2ShapeId")] B2ShapeId shapeId, [NativeName(NativeNameType.Param, "restitution")] [NativeName(NativeNameType.Type, "float")] float restitution)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<B2ShapeId, float, void>)funcTable[203])(shapeId, restitution);
			#else
			((delegate* unmanaged[Cdecl]<B2ShapeId, float, void>)funcTable[203])(shapeId, restitution);
			#endif
		}

		/// <summary>
		/// Set the shape restitution (bounciness)<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2Shape_SetRestitution")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void ShapeSetRestitution([NativeName(NativeNameType.Param, "shapeId")] [NativeName(NativeNameType.Type, "b2ShapeId")] B2ShapeId shapeId, [NativeName(NativeNameType.Param, "restitution")] [NativeName(NativeNameType.Type, "float")] float restitution)
		{
			ShapeSetRestitutionNative(shapeId, restitution);
		}

		/// <summary>
		/// Get the shape restitution<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2Shape_GetRestitution")]
		[return: NativeName(NativeNameType.Type, "float")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static float ShapeGetRestitutionNative([NativeName(NativeNameType.Param, "shapeId")] [NativeName(NativeNameType.Type, "b2ShapeId")] B2ShapeId shapeId)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<B2ShapeId, float>)funcTable[204])(shapeId);
			#else
			return (float)((delegate* unmanaged[Cdecl]<B2ShapeId, float>)funcTable[204])(shapeId);
			#endif
		}

		/// <summary>
		/// Get the shape restitution<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2Shape_GetRestitution")]
		[return: NativeName(NativeNameType.Type, "float")]
		public static float ShapeGetRestitution([NativeName(NativeNameType.Param, "shapeId")] [NativeName(NativeNameType.Type, "b2ShapeId")] B2ShapeId shapeId)
		{
			float ret = ShapeGetRestitutionNative(shapeId);
			return ret;
		}

		/// <summary>
		/// Get the shape filter<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2Shape_GetFilter")]
		[return: NativeName(NativeNameType.Type, "b2Filter")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static B2Filter ShapeGetFilterNative([NativeName(NativeNameType.Param, "shapeId")] [NativeName(NativeNameType.Type, "b2ShapeId")] B2ShapeId shapeId)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<B2ShapeId, B2Filter>)funcTable[205])(shapeId);
			#else
			return (B2Filter)((delegate* unmanaged[Cdecl]<B2ShapeId, B2Filter>)funcTable[205])(shapeId);
			#endif
		}

		/// <summary>
		/// Get the shape filter<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2Shape_GetFilter")]
		[return: NativeName(NativeNameType.Type, "b2Filter")]
		public static B2Filter ShapeGetFilter([NativeName(NativeNameType.Param, "shapeId")] [NativeName(NativeNameType.Type, "b2ShapeId")] B2ShapeId shapeId)
		{
			B2Filter ret = ShapeGetFilterNative(shapeId);
			return ret;
		}

		/// <summary>
		/// Set the current filter. This is almost as expensive as recreating the shape.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2Shape_SetFilter")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ShapeSetFilterNative([NativeName(NativeNameType.Param, "shapeId")] [NativeName(NativeNameType.Type, "b2ShapeId")] B2ShapeId shapeId, [NativeName(NativeNameType.Param, "filter")] [NativeName(NativeNameType.Type, "b2Filter")] B2Filter filter)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<B2ShapeId, B2Filter, void>)funcTable[206])(shapeId, filter);
			#else
			((delegate* unmanaged[Cdecl]<B2ShapeId, B2Filter, void>)funcTable[206])(shapeId, filter);
			#endif
		}

		/// <summary>
		/// Set the current filter. This is almost as expensive as recreating the shape.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2Shape_SetFilter")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void ShapeSetFilter([NativeName(NativeNameType.Param, "shapeId")] [NativeName(NativeNameType.Type, "b2ShapeId")] B2ShapeId shapeId, [NativeName(NativeNameType.Param, "filter")] [NativeName(NativeNameType.Type, "b2Filter")] B2Filter filter)
		{
			ShapeSetFilterNative(shapeId, filter);
		}

		/// <summary>
		/// Enable sensor events for this shape. Only applies to kinematic and dynamic bodies. Ignored for sensors.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2Shape_EnableSensorEvents")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ShapeEnableSensorEventsNative([NativeName(NativeNameType.Param, "shapeId")] [NativeName(NativeNameType.Type, "b2ShapeId")] B2ShapeId shapeId, [NativeName(NativeNameType.Param, "flag")] [NativeName(NativeNameType.Type, "bool")] byte flag)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<B2ShapeId, byte, void>)funcTable[207])(shapeId, flag);
			#else
			((delegate* unmanaged[Cdecl]<B2ShapeId, byte, void>)funcTable[207])(shapeId, flag);
			#endif
		}

		/// <summary>
		/// Enable sensor events for this shape. Only applies to kinematic and dynamic bodies. Ignored for sensors.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2Shape_EnableSensorEvents")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void ShapeEnableSensorEvents([NativeName(NativeNameType.Param, "shapeId")] [NativeName(NativeNameType.Type, "b2ShapeId")] B2ShapeId shapeId, [NativeName(NativeNameType.Param, "flag")] [NativeName(NativeNameType.Type, "bool")] bool flag)
		{
			ShapeEnableSensorEventsNative(shapeId, flag ? (byte)1 : (byte)0);
		}

		/// <summary>
		/// Returns true if sensor events are enabled<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2Shape_AreSensorEventsEnabled")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte ShapeAreSensorEventsEnabledNative([NativeName(NativeNameType.Param, "shapeId")] [NativeName(NativeNameType.Type, "b2ShapeId")] B2ShapeId shapeId)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<B2ShapeId, byte>)funcTable[208])(shapeId);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<B2ShapeId, byte>)funcTable[208])(shapeId);
			#endif
		}

		/// <summary>
		/// Returns true if sensor events are enabled<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2Shape_AreSensorEventsEnabled")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool ShapeAreSensorEventsEnabled([NativeName(NativeNameType.Param, "shapeId")] [NativeName(NativeNameType.Type, "b2ShapeId")] B2ShapeId shapeId)
		{
			byte ret = ShapeAreSensorEventsEnabledNative(shapeId);
			return ret != 0;
		}

		/// <summary>
		/// Enable contact events for this shape. Only applies to kinematic and dynamic bodies. Ignored for sensors.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2Shape_EnableContactEvents")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ShapeEnableContactEventsNative([NativeName(NativeNameType.Param, "shapeId")] [NativeName(NativeNameType.Type, "b2ShapeId")] B2ShapeId shapeId, [NativeName(NativeNameType.Param, "flag")] [NativeName(NativeNameType.Type, "bool")] byte flag)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<B2ShapeId, byte, void>)funcTable[209])(shapeId, flag);
			#else
			((delegate* unmanaged[Cdecl]<B2ShapeId, byte, void>)funcTable[209])(shapeId, flag);
			#endif
		}

		/// <summary>
		/// Enable contact events for this shape. Only applies to kinematic and dynamic bodies. Ignored for sensors.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2Shape_EnableContactEvents")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void ShapeEnableContactEvents([NativeName(NativeNameType.Param, "shapeId")] [NativeName(NativeNameType.Type, "b2ShapeId")] B2ShapeId shapeId, [NativeName(NativeNameType.Param, "flag")] [NativeName(NativeNameType.Type, "bool")] bool flag)
		{
			ShapeEnableContactEventsNative(shapeId, flag ? (byte)1 : (byte)0);
		}

		/// <summary>
		/// Returns true if contact events are enabled<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2Shape_AreContactEventsEnabled")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte ShapeAreContactEventsEnabledNative([NativeName(NativeNameType.Param, "shapeId")] [NativeName(NativeNameType.Type, "b2ShapeId")] B2ShapeId shapeId)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<B2ShapeId, byte>)funcTable[210])(shapeId);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<B2ShapeId, byte>)funcTable[210])(shapeId);
			#endif
		}

		/// <summary>
		/// Returns true if contact events are enabled<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2Shape_AreContactEventsEnabled")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool ShapeAreContactEventsEnabled([NativeName(NativeNameType.Param, "shapeId")] [NativeName(NativeNameType.Type, "b2ShapeId")] B2ShapeId shapeId)
		{
			byte ret = ShapeAreContactEventsEnabledNative(shapeId);
			return ret != 0;
		}

		/// <summary>
		/// Enable pre-solve contact events for this shape. Only applies to dynamic bodies. These are expensive<br/>
		/// and must be carefully handled due to multithreading. Ignored for sensors.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2Shape_EnablePreSolveEvents")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ShapeEnablePreSolveEventsNative([NativeName(NativeNameType.Param, "shapeId")] [NativeName(NativeNameType.Type, "b2ShapeId")] B2ShapeId shapeId, [NativeName(NativeNameType.Param, "flag")] [NativeName(NativeNameType.Type, "bool")] byte flag)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<B2ShapeId, byte, void>)funcTable[211])(shapeId, flag);
			#else
			((delegate* unmanaged[Cdecl]<B2ShapeId, byte, void>)funcTable[211])(shapeId, flag);
			#endif
		}

		/// <summary>
		/// Enable pre-solve contact events for this shape. Only applies to dynamic bodies. These are expensive<br/>
		/// and must be carefully handled due to multithreading. Ignored for sensors.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2Shape_EnablePreSolveEvents")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void ShapeEnablePreSolveEvents([NativeName(NativeNameType.Param, "shapeId")] [NativeName(NativeNameType.Type, "b2ShapeId")] B2ShapeId shapeId, [NativeName(NativeNameType.Param, "flag")] [NativeName(NativeNameType.Type, "bool")] bool flag)
		{
			ShapeEnablePreSolveEventsNative(shapeId, flag ? (byte)1 : (byte)0);
		}

		/// <summary>
		/// Returns true if pre-solve events are enabled<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2Shape_ArePreSolveEventsEnabled")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte ShapeArePreSolveEventsEnabledNative([NativeName(NativeNameType.Param, "shapeId")] [NativeName(NativeNameType.Type, "b2ShapeId")] B2ShapeId shapeId)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<B2ShapeId, byte>)funcTable[212])(shapeId);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<B2ShapeId, byte>)funcTable[212])(shapeId);
			#endif
		}

		/// <summary>
		/// Returns true if pre-solve events are enabled<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2Shape_ArePreSolveEventsEnabled")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool ShapeArePreSolveEventsEnabled([NativeName(NativeNameType.Param, "shapeId")] [NativeName(NativeNameType.Type, "b2ShapeId")] B2ShapeId shapeId)
		{
			byte ret = ShapeArePreSolveEventsEnabledNative(shapeId);
			return ret != 0;
		}

		/// <summary>
		/// Enable contact hit events for this shape. Ignored for sensors.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2Shape_EnableHitEvents")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ShapeEnableHitEventsNative([NativeName(NativeNameType.Param, "shapeId")] [NativeName(NativeNameType.Type, "b2ShapeId")] B2ShapeId shapeId, [NativeName(NativeNameType.Param, "flag")] [NativeName(NativeNameType.Type, "bool")] byte flag)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<B2ShapeId, byte, void>)funcTable[213])(shapeId, flag);
			#else
			((delegate* unmanaged[Cdecl]<B2ShapeId, byte, void>)funcTable[213])(shapeId, flag);
			#endif
		}

		/// <summary>
		/// Enable contact hit events for this shape. Ignored for sensors.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2Shape_EnableHitEvents")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void ShapeEnableHitEvents([NativeName(NativeNameType.Param, "shapeId")] [NativeName(NativeNameType.Type, "b2ShapeId")] B2ShapeId shapeId, [NativeName(NativeNameType.Param, "flag")] [NativeName(NativeNameType.Type, "bool")] bool flag)
		{
			ShapeEnableHitEventsNative(shapeId, flag ? (byte)1 : (byte)0);
		}

		/// <summary>
		/// Returns true if hit events are enabled<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2Shape_AreHitEventsEnabled")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte ShapeAreHitEventsEnabledNative([NativeName(NativeNameType.Param, "shapeId")] [NativeName(NativeNameType.Type, "b2ShapeId")] B2ShapeId shapeId)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<B2ShapeId, byte>)funcTable[214])(shapeId);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<B2ShapeId, byte>)funcTable[214])(shapeId);
			#endif
		}

		/// <summary>
		/// Returns true if hit events are enabled<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2Shape_AreHitEventsEnabled")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool ShapeAreHitEventsEnabled([NativeName(NativeNameType.Param, "shapeId")] [NativeName(NativeNameType.Type, "b2ShapeId")] B2ShapeId shapeId)
		{
			byte ret = ShapeAreHitEventsEnabledNative(shapeId);
			return ret != 0;
		}

		/// <summary>
		/// Test a point for overlap with a shape<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2Shape_TestPoint")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte ShapeTestPointNative([NativeName(NativeNameType.Param, "shapeId")] [NativeName(NativeNameType.Type, "b2ShapeId")] B2ShapeId shapeId, [NativeName(NativeNameType.Param, "point")] [NativeName(NativeNameType.Type, "b2Vec2")] Vector2 point)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<B2ShapeId, Vector2, byte>)funcTable[215])(shapeId, point);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<B2ShapeId, Vector2, byte>)funcTable[215])(shapeId, point);
			#endif
		}

		/// <summary>
		/// Test a point for overlap with a shape<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2Shape_TestPoint")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool ShapeTestPoint([NativeName(NativeNameType.Param, "shapeId")] [NativeName(NativeNameType.Type, "b2ShapeId")] B2ShapeId shapeId, [NativeName(NativeNameType.Param, "point")] [NativeName(NativeNameType.Type, "b2Vec2")] Vector2 point)
		{
			byte ret = ShapeTestPointNative(shapeId, point);
			return ret != 0;
		}

		/// <summary>
		/// Ray cast a shape directly<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2Shape_RayCast")]
		[return: NativeName(NativeNameType.Type, "b2CastOutput")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static B2CastOutput ShapeRayCastNative([NativeName(NativeNameType.Param, "shapeId")] [NativeName(NativeNameType.Type, "b2ShapeId")] B2ShapeId shapeId, [NativeName(NativeNameType.Param, "origin")] [NativeName(NativeNameType.Type, "b2Vec2")] Vector2 origin, [NativeName(NativeNameType.Param, "translation")] [NativeName(NativeNameType.Type, "b2Vec2")] Vector2 translation)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<B2ShapeId, Vector2, Vector2, B2CastOutput>)funcTable[216])(shapeId, origin, translation);
			#else
			return (B2CastOutput)((delegate* unmanaged[Cdecl]<B2ShapeId, Vector2, Vector2, B2CastOutput>)funcTable[216])(shapeId, origin, translation);
			#endif
		}

		/// <summary>
		/// Ray cast a shape directly<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2Shape_RayCast")]
		[return: NativeName(NativeNameType.Type, "b2CastOutput")]
		public static B2CastOutput ShapeRayCast([NativeName(NativeNameType.Param, "shapeId")] [NativeName(NativeNameType.Type, "b2ShapeId")] B2ShapeId shapeId, [NativeName(NativeNameType.Param, "origin")] [NativeName(NativeNameType.Type, "b2Vec2")] Vector2 origin, [NativeName(NativeNameType.Param, "translation")] [NativeName(NativeNameType.Type, "b2Vec2")] Vector2 translation)
		{
			B2CastOutput ret = ShapeRayCastNative(shapeId, origin, translation);
			return ret;
		}

		/// <summary>
		/// Get a copy of the shape's circle. Asserts the type is correct.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2Shape_GetCircle")]
		[return: NativeName(NativeNameType.Type, "b2Circle")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static B2Circle ShapeGetCircleNative([NativeName(NativeNameType.Param, "shapeId")] [NativeName(NativeNameType.Type, "b2ShapeId")] B2ShapeId shapeId)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<B2ShapeId, B2Circle>)funcTable[217])(shapeId);
			#else
			return (B2Circle)((delegate* unmanaged[Cdecl]<B2ShapeId, B2Circle>)funcTable[217])(shapeId);
			#endif
		}

		/// <summary>
		/// Get a copy of the shape's circle. Asserts the type is correct.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2Shape_GetCircle")]
		[return: NativeName(NativeNameType.Type, "b2Circle")]
		public static B2Circle ShapeGetCircle([NativeName(NativeNameType.Param, "shapeId")] [NativeName(NativeNameType.Type, "b2ShapeId")] B2ShapeId shapeId)
		{
			B2Circle ret = ShapeGetCircleNative(shapeId);
			return ret;
		}

		/// <summary>
		/// Get a copy of the shape's line segment. Asserts the type is correct.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2Shape_GetSegment")]
		[return: NativeName(NativeNameType.Type, "b2Segment")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static B2Segment ShapeGetSegmentNative([NativeName(NativeNameType.Param, "shapeId")] [NativeName(NativeNameType.Type, "b2ShapeId")] B2ShapeId shapeId)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<B2ShapeId, B2Segment>)funcTable[218])(shapeId);
			#else
			return (B2Segment)((delegate* unmanaged[Cdecl]<B2ShapeId, B2Segment>)funcTable[218])(shapeId);
			#endif
		}

		/// <summary>
		/// Get a copy of the shape's line segment. Asserts the type is correct.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2Shape_GetSegment")]
		[return: NativeName(NativeNameType.Type, "b2Segment")]
		public static B2Segment ShapeGetSegment([NativeName(NativeNameType.Param, "shapeId")] [NativeName(NativeNameType.Type, "b2ShapeId")] B2ShapeId shapeId)
		{
			B2Segment ret = ShapeGetSegmentNative(shapeId);
			return ret;
		}

		/// <summary>
		/// Get a copy of the shape's smooth line segment. These come from chain shapes.<br/>
		/// Asserts the type is correct.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2Shape_GetSmoothSegment")]
		[return: NativeName(NativeNameType.Type, "b2SmoothSegment")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static B2SmoothSegment ShapeGetSmoothSegmentNative([NativeName(NativeNameType.Param, "shapeId")] [NativeName(NativeNameType.Type, "b2ShapeId")] B2ShapeId shapeId)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<B2ShapeId, B2SmoothSegment>)funcTable[219])(shapeId);
			#else
			return (B2SmoothSegment)((delegate* unmanaged[Cdecl]<B2ShapeId, B2SmoothSegment>)funcTable[219])(shapeId);
			#endif
		}

		/// <summary>
		/// Get a copy of the shape's smooth line segment. These come from chain shapes.<br/>
		/// Asserts the type is correct.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2Shape_GetSmoothSegment")]
		[return: NativeName(NativeNameType.Type, "b2SmoothSegment")]
		public static B2SmoothSegment ShapeGetSmoothSegment([NativeName(NativeNameType.Param, "shapeId")] [NativeName(NativeNameType.Type, "b2ShapeId")] B2ShapeId shapeId)
		{
			B2SmoothSegment ret = ShapeGetSmoothSegmentNative(shapeId);
			return ret;
		}

		/// <summary>
		/// Get a copy of the shape's capsule. Asserts the type is correct.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2Shape_GetCapsule")]
		[return: NativeName(NativeNameType.Type, "b2Capsule")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static B2Capsule ShapeGetCapsuleNative([NativeName(NativeNameType.Param, "shapeId")] [NativeName(NativeNameType.Type, "b2ShapeId")] B2ShapeId shapeId)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<B2ShapeId, B2Capsule>)funcTable[220])(shapeId);
			#else
			return (B2Capsule)((delegate* unmanaged[Cdecl]<B2ShapeId, B2Capsule>)funcTable[220])(shapeId);
			#endif
		}

		/// <summary>
		/// Get a copy of the shape's capsule. Asserts the type is correct.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2Shape_GetCapsule")]
		[return: NativeName(NativeNameType.Type, "b2Capsule")]
		public static B2Capsule ShapeGetCapsule([NativeName(NativeNameType.Param, "shapeId")] [NativeName(NativeNameType.Type, "b2ShapeId")] B2ShapeId shapeId)
		{
			B2Capsule ret = ShapeGetCapsuleNative(shapeId);
			return ret;
		}

		/// <summary>
		/// Get a copy of the shape's convex polygon. Asserts the type is correct.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2Shape_GetPolygon")]
		[return: NativeName(NativeNameType.Type, "b2Polygon")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static B2Polygon ShapeGetPolygonNative([NativeName(NativeNameType.Param, "shapeId")] [NativeName(NativeNameType.Type, "b2ShapeId")] B2ShapeId shapeId)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<B2ShapeId, B2Polygon>)funcTable[221])(shapeId);
			#else
			return (B2Polygon)((delegate* unmanaged[Cdecl]<B2ShapeId, B2Polygon>)funcTable[221])(shapeId);
			#endif
		}

		/// <summary>
		/// Get a copy of the shape's convex polygon. Asserts the type is correct.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2Shape_GetPolygon")]
		[return: NativeName(NativeNameType.Type, "b2Polygon")]
		public static B2Polygon ShapeGetPolygon([NativeName(NativeNameType.Param, "shapeId")] [NativeName(NativeNameType.Type, "b2ShapeId")] B2ShapeId shapeId)
		{
			B2Polygon ret = ShapeGetPolygonNative(shapeId);
			return ret;
		}

		/// <summary>
		/// Allows you to change a shape to be a circle or update the current circle.<br/>
		/// This does not modify the mass properties.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2Shape_SetCircle")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ShapeSetCircleNative([NativeName(NativeNameType.Param, "shapeId")] [NativeName(NativeNameType.Type, "b2ShapeId")] B2ShapeId shapeId, [NativeName(NativeNameType.Param, "circle")] [NativeName(NativeNameType.Type, "b2Circle const *")] B2Circle* circle)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<B2ShapeId, B2Circle*, void>)funcTable[222])(shapeId, circle);
			#else
			((delegate* unmanaged[Cdecl]<B2ShapeId, nint, void>)funcTable[222])(shapeId, (nint)circle);
			#endif
		}

		/// <summary>
		/// Allows you to change a shape to be a circle or update the current circle.<br/>
		/// This does not modify the mass properties.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2Shape_SetCircle")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void ShapeSetCircle([NativeName(NativeNameType.Param, "shapeId")] [NativeName(NativeNameType.Type, "b2ShapeId")] B2ShapeId shapeId, [NativeName(NativeNameType.Param, "circle")] [NativeName(NativeNameType.Type, "b2Circle const *")] B2Circle* circle)
		{
			ShapeSetCircleNative(shapeId, circle);
		}

		/// <summary>
		/// Allows you to change a shape to be a circle or update the current circle.<br/>
		/// This does not modify the mass properties.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2Shape_SetCircle")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void ShapeSetCircle([NativeName(NativeNameType.Param, "shapeId")] [NativeName(NativeNameType.Type, "b2ShapeId")] B2ShapeId shapeId, [NativeName(NativeNameType.Param, "circle")] [NativeName(NativeNameType.Type, "b2Circle const *")] ref B2Circle circle)
		{
			fixed (B2Circle* pcircle = &circle)
			{
				ShapeSetCircleNative(shapeId, (B2Circle*)pcircle);
			}
		}

		/// <summary>
		/// Allows you to change a shape to be a capsule or update the current capsule.<br/>
		/// This does not modify the mass properties.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2Shape_SetCapsule")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ShapeSetCapsuleNative([NativeName(NativeNameType.Param, "shapeId")] [NativeName(NativeNameType.Type, "b2ShapeId")] B2ShapeId shapeId, [NativeName(NativeNameType.Param, "capsule")] [NativeName(NativeNameType.Type, "b2Capsule const *")] B2Capsule* capsule)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<B2ShapeId, B2Capsule*, void>)funcTable[223])(shapeId, capsule);
			#else
			((delegate* unmanaged[Cdecl]<B2ShapeId, nint, void>)funcTable[223])(shapeId, (nint)capsule);
			#endif
		}

		/// <summary>
		/// Allows you to change a shape to be a capsule or update the current capsule.<br/>
		/// This does not modify the mass properties.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2Shape_SetCapsule")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void ShapeSetCapsule([NativeName(NativeNameType.Param, "shapeId")] [NativeName(NativeNameType.Type, "b2ShapeId")] B2ShapeId shapeId, [NativeName(NativeNameType.Param, "capsule")] [NativeName(NativeNameType.Type, "b2Capsule const *")] B2Capsule* capsule)
		{
			ShapeSetCapsuleNative(shapeId, capsule);
		}

		/// <summary>
		/// Allows you to change a shape to be a capsule or update the current capsule.<br/>
		/// This does not modify the mass properties.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2Shape_SetCapsule")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void ShapeSetCapsule([NativeName(NativeNameType.Param, "shapeId")] [NativeName(NativeNameType.Type, "b2ShapeId")] B2ShapeId shapeId, [NativeName(NativeNameType.Param, "capsule")] [NativeName(NativeNameType.Type, "b2Capsule const *")] ref B2Capsule capsule)
		{
			fixed (B2Capsule* pcapsule = &capsule)
			{
				ShapeSetCapsuleNative(shapeId, (B2Capsule*)pcapsule);
			}
		}

		/// <summary>
		/// Allows you to change a shape to be a segment or update the current segment.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2Shape_SetSegment")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ShapeSetSegmentNative([NativeName(NativeNameType.Param, "shapeId")] [NativeName(NativeNameType.Type, "b2ShapeId")] B2ShapeId shapeId, [NativeName(NativeNameType.Param, "segment")] [NativeName(NativeNameType.Type, "b2Segment const *")] B2Segment* segment)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<B2ShapeId, B2Segment*, void>)funcTable[224])(shapeId, segment);
			#else
			((delegate* unmanaged[Cdecl]<B2ShapeId, nint, void>)funcTable[224])(shapeId, (nint)segment);
			#endif
		}

		/// <summary>
		/// Allows you to change a shape to be a segment or update the current segment.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2Shape_SetSegment")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void ShapeSetSegment([NativeName(NativeNameType.Param, "shapeId")] [NativeName(NativeNameType.Type, "b2ShapeId")] B2ShapeId shapeId, [NativeName(NativeNameType.Param, "segment")] [NativeName(NativeNameType.Type, "b2Segment const *")] B2Segment* segment)
		{
			ShapeSetSegmentNative(shapeId, segment);
		}

		/// <summary>
		/// Allows you to change a shape to be a segment or update the current segment.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2Shape_SetSegment")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void ShapeSetSegment([NativeName(NativeNameType.Param, "shapeId")] [NativeName(NativeNameType.Type, "b2ShapeId")] B2ShapeId shapeId, [NativeName(NativeNameType.Param, "segment")] [NativeName(NativeNameType.Type, "b2Segment const *")] ref B2Segment segment)
		{
			fixed (B2Segment* psegment = &segment)
			{
				ShapeSetSegmentNative(shapeId, (B2Segment*)psegment);
			}
		}

		/// <summary>
		/// Allows you to change a shape to be a polygon or update the current polygon.<br/>
		/// This does not modify the mass properties.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2Shape_SetPolygon")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ShapeSetPolygonNative([NativeName(NativeNameType.Param, "shapeId")] [NativeName(NativeNameType.Type, "b2ShapeId")] B2ShapeId shapeId, [NativeName(NativeNameType.Param, "polygon")] [NativeName(NativeNameType.Type, "b2Polygon const *")] B2Polygon* polygon)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<B2ShapeId, B2Polygon*, void>)funcTable[225])(shapeId, polygon);
			#else
			((delegate* unmanaged[Cdecl]<B2ShapeId, nint, void>)funcTable[225])(shapeId, (nint)polygon);
			#endif
		}

		/// <summary>
		/// Allows you to change a shape to be a polygon or update the current polygon.<br/>
		/// This does not modify the mass properties.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2Shape_SetPolygon")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void ShapeSetPolygon([NativeName(NativeNameType.Param, "shapeId")] [NativeName(NativeNameType.Type, "b2ShapeId")] B2ShapeId shapeId, [NativeName(NativeNameType.Param, "polygon")] [NativeName(NativeNameType.Type, "b2Polygon const *")] B2Polygon* polygon)
		{
			ShapeSetPolygonNative(shapeId, polygon);
		}

		/// <summary>
		/// Allows you to change a shape to be a polygon or update the current polygon.<br/>
		/// This does not modify the mass properties.<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2Shape_SetPolygon")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void ShapeSetPolygon([NativeName(NativeNameType.Param, "shapeId")] [NativeName(NativeNameType.Type, "b2ShapeId")] B2ShapeId shapeId, [NativeName(NativeNameType.Param, "polygon")] [NativeName(NativeNameType.Type, "b2Polygon const *")] ref B2Polygon polygon)
		{
			fixed (B2Polygon* ppolygon = &polygon)
			{
				ShapeSetPolygonNative(shapeId, (B2Polygon*)ppolygon);
			}
		}

		/// <summary>
		/// Get the parent chain id if the shape type is b2_smoothSegmentShape, otherwise<br/>
		/// returns b2_nullChainId.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2Shape_GetParentChain")]
		[return: NativeName(NativeNameType.Type, "b2ChainId")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static B2ChainId ShapeGetParentChainNative([NativeName(NativeNameType.Param, "shapeId")] [NativeName(NativeNameType.Type, "b2ShapeId")] B2ShapeId shapeId)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<B2ShapeId, B2ChainId>)funcTable[226])(shapeId);
			#else
			return (B2ChainId)((delegate* unmanaged[Cdecl]<B2ShapeId, B2ChainId>)funcTable[226])(shapeId);
			#endif
		}

		/// <summary>
		/// Get the parent chain id if the shape type is b2_smoothSegmentShape, otherwise<br/>
		/// returns b2_nullChainId.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2Shape_GetParentChain")]
		[return: NativeName(NativeNameType.Type, "b2ChainId")]
		public static B2ChainId ShapeGetParentChain([NativeName(NativeNameType.Param, "shapeId")] [NativeName(NativeNameType.Type, "b2ShapeId")] B2ShapeId shapeId)
		{
			B2ChainId ret = ShapeGetParentChainNative(shapeId);
			return ret;
		}

		/// <summary>
		/// Get the maximum capacity required for retrieving all the touching contacts on a shape<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2Shape_GetContactCapacity")]
		[return: NativeName(NativeNameType.Type, "int")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int ShapeGetContactCapacityNative([NativeName(NativeNameType.Param, "shapeId")] [NativeName(NativeNameType.Type, "b2ShapeId")] B2ShapeId shapeId)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<B2ShapeId, int>)funcTable[227])(shapeId);
			#else
			return (int)((delegate* unmanaged[Cdecl]<B2ShapeId, int>)funcTable[227])(shapeId);
			#endif
		}

		/// <summary>
		/// Get the maximum capacity required for retrieving all the touching contacts on a shape<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2Shape_GetContactCapacity")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int ShapeGetContactCapacity([NativeName(NativeNameType.Param, "shapeId")] [NativeName(NativeNameType.Type, "b2ShapeId")] B2ShapeId shapeId)
		{
			int ret = ShapeGetContactCapacityNative(shapeId);
			return ret;
		}

		/// <summary>
		/// Get the touching contact data for a shape. The provided shapeId will be either shapeIdA or shapeIdB on the contact data.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2Shape_GetContactData")]
		[return: NativeName(NativeNameType.Type, "int")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static int ShapeGetContactDataNative([NativeName(NativeNameType.Param, "shapeId")] [NativeName(NativeNameType.Type, "b2ShapeId")] B2ShapeId shapeId, [NativeName(NativeNameType.Param, "contactData")] [NativeName(NativeNameType.Type, "b2ContactData *")] B2ContactData* contactData, [NativeName(NativeNameType.Param, "capacity")] [NativeName(NativeNameType.Type, "int")] int capacity)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<B2ShapeId, B2ContactData*, int, int>)funcTable[228])(shapeId, contactData, capacity);
			#else
			return (int)((delegate* unmanaged[Cdecl]<B2ShapeId, nint, int, int>)funcTable[228])(shapeId, (nint)contactData, capacity);
			#endif
		}

		/// <summary>
		/// Get the touching contact data for a shape. The provided shapeId will be either shapeIdA or shapeIdB on the contact data.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2Shape_GetContactData")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int ShapeGetContactData([NativeName(NativeNameType.Param, "shapeId")] [NativeName(NativeNameType.Type, "b2ShapeId")] B2ShapeId shapeId, [NativeName(NativeNameType.Param, "contactData")] [NativeName(NativeNameType.Type, "b2ContactData *")] B2ContactData* contactData, [NativeName(NativeNameType.Param, "capacity")] [NativeName(NativeNameType.Type, "int")] int capacity)
		{
			int ret = ShapeGetContactDataNative(shapeId, contactData, capacity);
			return ret;
		}

		/// <summary>
		/// Get the touching contact data for a shape. The provided shapeId will be either shapeIdA or shapeIdB on the contact data.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2Shape_GetContactData")]
		[return: NativeName(NativeNameType.Type, "int")]
		public static int ShapeGetContactData([NativeName(NativeNameType.Param, "shapeId")] [NativeName(NativeNameType.Type, "b2ShapeId")] B2ShapeId shapeId, [NativeName(NativeNameType.Param, "contactData")] [NativeName(NativeNameType.Type, "b2ContactData *")] ref B2ContactData contactData, [NativeName(NativeNameType.Param, "capacity")] [NativeName(NativeNameType.Type, "int")] int capacity)
		{
			fixed (B2ContactData* pcontactData = &contactData)
			{
				int ret = ShapeGetContactDataNative(shapeId, (B2ContactData*)pcontactData, capacity);
				return ret;
			}
		}

		/// <summary>
		/// Get the current world AABB<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2Shape_GetAABB")]
		[return: NativeName(NativeNameType.Type, "b2AABB")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static B2AABB ShapeGetAABBNative([NativeName(NativeNameType.Param, "shapeId")] [NativeName(NativeNameType.Type, "b2ShapeId")] B2ShapeId shapeId)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<B2ShapeId, B2AABB>)funcTable[229])(shapeId);
			#else
			return (B2AABB)((delegate* unmanaged[Cdecl]<B2ShapeId, B2AABB>)funcTable[229])(shapeId);
			#endif
		}

		/// <summary>
		/// Get the current world AABB<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2Shape_GetAABB")]
		[return: NativeName(NativeNameType.Type, "b2AABB")]
		public static B2AABB ShapeGetAABB([NativeName(NativeNameType.Param, "shapeId")] [NativeName(NativeNameType.Type, "b2ShapeId")] B2ShapeId shapeId)
		{
			B2AABB ret = ShapeGetAABBNative(shapeId);
			return ret;
		}

		/// <summary>
		/// Get the closest point on a shape to a target point. Target and result are in world space.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2Shape_GetClosestPoint")]
		[return: NativeName(NativeNameType.Type, "b2Vec2")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static Vector2 ShapeGetClosestPointNative([NativeName(NativeNameType.Param, "shapeId")] [NativeName(NativeNameType.Type, "b2ShapeId")] B2ShapeId shapeId, [NativeName(NativeNameType.Param, "target")] [NativeName(NativeNameType.Type, "b2Vec2")] Vector2 target)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<B2ShapeId, Vector2, Vector2>)funcTable[230])(shapeId, target);
			#else
			return (Vector2)((delegate* unmanaged[Cdecl]<B2ShapeId, Vector2, Vector2>)funcTable[230])(shapeId, target);
			#endif
		}

		/// <summary>
		/// Get the closest point on a shape to a target point. Target and result are in world space.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2Shape_GetClosestPoint")]
		[return: NativeName(NativeNameType.Type, "b2Vec2")]
		public static Vector2 ShapeGetClosestPoint([NativeName(NativeNameType.Param, "shapeId")] [NativeName(NativeNameType.Type, "b2ShapeId")] B2ShapeId shapeId, [NativeName(NativeNameType.Param, "target")] [NativeName(NativeNameType.Type, "b2Vec2")] Vector2 target)
		{
			Vector2 ret = ShapeGetClosestPointNative(shapeId, target);
			return ret;
		}

		/// <summary>
		/// Create a chain shape<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2CreateChain")]
		[return: NativeName(NativeNameType.Type, "b2ChainId")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static B2ChainId CreateChainNative([NativeName(NativeNameType.Param, "bodyId")] [NativeName(NativeNameType.Type, "b2BodyId")] B2BodyId bodyId, [NativeName(NativeNameType.Param, "def")] [NativeName(NativeNameType.Type, "b2ChainDef const *")] B2ChainDef* def)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<B2BodyId, B2ChainDef*, B2ChainId>)funcTable[231])(bodyId, def);
			#else
			return (B2ChainId)((delegate* unmanaged[Cdecl]<B2BodyId, nint, B2ChainId>)funcTable[231])(bodyId, (nint)def);
			#endif
		}

		/// <summary>
		/// Create a chain shape<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2CreateChain")]
		[return: NativeName(NativeNameType.Type, "b2ChainId")]
		public static B2ChainId CreateChain([NativeName(NativeNameType.Param, "bodyId")] [NativeName(NativeNameType.Type, "b2BodyId")] B2BodyId bodyId, [NativeName(NativeNameType.Param, "def")] [NativeName(NativeNameType.Type, "b2ChainDef const *")] B2ChainDef* def)
		{
			B2ChainId ret = CreateChainNative(bodyId, def);
			return ret;
		}

		/// <summary>
		/// Create a chain shape<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2CreateChain")]
		[return: NativeName(NativeNameType.Type, "b2ChainId")]
		public static B2ChainId CreateChain([NativeName(NativeNameType.Param, "bodyId")] [NativeName(NativeNameType.Type, "b2BodyId")] B2BodyId bodyId, [NativeName(NativeNameType.Param, "def")] [NativeName(NativeNameType.Type, "b2ChainDef const *")] ref B2ChainDef def)
		{
			fixed (B2ChainDef* pdef = &def)
			{
				B2ChainId ret = CreateChainNative(bodyId, (B2ChainDef*)pdef);
				return ret;
			}
		}

		/// <summary>
		/// Destroy a chain shape<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2DestroyChain")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DestroyChainNative([NativeName(NativeNameType.Param, "chainId")] [NativeName(NativeNameType.Type, "b2ChainId")] B2ChainId chainId)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<B2ChainId, void>)funcTable[232])(chainId);
			#else
			((delegate* unmanaged[Cdecl]<B2ChainId, void>)funcTable[232])(chainId);
			#endif
		}

		/// <summary>
		/// Destroy a chain shape<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2DestroyChain")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void DestroyChain([NativeName(NativeNameType.Param, "chainId")] [NativeName(NativeNameType.Type, "b2ChainId")] B2ChainId chainId)
		{
			DestroyChainNative(chainId);
		}

		/// <summary>
		/// Set the chain friction<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2Chain_SetFriction")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ChainSetFrictionNative([NativeName(NativeNameType.Param, "chainId")] [NativeName(NativeNameType.Type, "b2ChainId")] B2ChainId chainId, [NativeName(NativeNameType.Param, "friction")] [NativeName(NativeNameType.Type, "float")] float friction)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<B2ChainId, float, void>)funcTable[233])(chainId, friction);
			#else
			((delegate* unmanaged[Cdecl]<B2ChainId, float, void>)funcTable[233])(chainId, friction);
			#endif
		}

		/// <summary>
		/// Set the chain friction<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2Chain_SetFriction")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void ChainSetFriction([NativeName(NativeNameType.Param, "chainId")] [NativeName(NativeNameType.Type, "b2ChainId")] B2ChainId chainId, [NativeName(NativeNameType.Param, "friction")] [NativeName(NativeNameType.Type, "float")] float friction)
		{
			ChainSetFrictionNative(chainId, friction);
		}

		/// <summary>
		/// Set the chain restitution (bounciness)<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2Chain_SetRestitution")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void ChainSetRestitutionNative([NativeName(NativeNameType.Param, "chainId")] [NativeName(NativeNameType.Type, "b2ChainId")] B2ChainId chainId, [NativeName(NativeNameType.Param, "restitution")] [NativeName(NativeNameType.Type, "float")] float restitution)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<B2ChainId, float, void>)funcTable[234])(chainId, restitution);
			#else
			((delegate* unmanaged[Cdecl]<B2ChainId, float, void>)funcTable[234])(chainId, restitution);
			#endif
		}

		/// <summary>
		/// Set the chain restitution (bounciness)<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2Chain_SetRestitution")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void ChainSetRestitution([NativeName(NativeNameType.Param, "chainId")] [NativeName(NativeNameType.Type, "b2ChainId")] B2ChainId chainId, [NativeName(NativeNameType.Param, "restitution")] [NativeName(NativeNameType.Type, "float")] float restitution)
		{
			ChainSetRestitutionNative(chainId, restitution);
		}

		/// <summary>
		/// Chain identifier validation. Provides validation for up to 64K allocations.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2Chain_IsValid")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte ChainIsValidNative([NativeName(NativeNameType.Param, "id")] [NativeName(NativeNameType.Type, "b2ChainId")] B2ChainId id)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<B2ChainId, byte>)funcTable[235])(id);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<B2ChainId, byte>)funcTable[235])(id);
			#endif
		}

		/// <summary>
		/// Chain identifier validation. Provides validation for up to 64K allocations.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2Chain_IsValid")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool ChainIsValid([NativeName(NativeNameType.Param, "id")] [NativeName(NativeNameType.Type, "b2ChainId")] B2ChainId id)
		{
			byte ret = ChainIsValidNative(id);
			return ret != 0;
		}

		/// <summary>
		/// Destroy a joint<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2DestroyJoint")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DestroyJointNative([NativeName(NativeNameType.Param, "jointId")] [NativeName(NativeNameType.Type, "b2JointId")] B2JointId jointId)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<B2JointId, void>)funcTable[236])(jointId);
			#else
			((delegate* unmanaged[Cdecl]<B2JointId, void>)funcTable[236])(jointId);
			#endif
		}

		/// <summary>
		/// Destroy a joint<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2DestroyJoint")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void DestroyJoint([NativeName(NativeNameType.Param, "jointId")] [NativeName(NativeNameType.Type, "b2JointId")] B2JointId jointId)
		{
			DestroyJointNative(jointId);
		}

		/// <summary>
		/// Joint identifier validation. Provides validation for up to 64K allocations.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2Joint_IsValid")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte JointIsValidNative([NativeName(NativeNameType.Param, "id")] [NativeName(NativeNameType.Type, "b2JointId")] B2JointId id)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<B2JointId, byte>)funcTable[237])(id);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<B2JointId, byte>)funcTable[237])(id);
			#endif
		}

		/// <summary>
		/// Joint identifier validation. Provides validation for up to 64K allocations.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2Joint_IsValid")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool JointIsValid([NativeName(NativeNameType.Param, "id")] [NativeName(NativeNameType.Type, "b2JointId")] B2JointId id)
		{
			byte ret = JointIsValidNative(id);
			return ret != 0;
		}

		/// <summary>
		/// Get the joint type<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2Joint_GetType")]
		[return: NativeName(NativeNameType.Type, "b2JointType")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static B2JointType JointGetTypeNative([NativeName(NativeNameType.Param, "jointId")] [NativeName(NativeNameType.Type, "b2JointId")] B2JointId jointId)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<B2JointId, B2JointType>)funcTable[238])(jointId);
			#else
			return (B2JointType)((delegate* unmanaged[Cdecl]<B2JointId, B2JointType>)funcTable[238])(jointId);
			#endif
		}

		/// <summary>
		/// Get the joint type<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2Joint_GetType")]
		[return: NativeName(NativeNameType.Type, "b2JointType")]
		public static B2JointType JointGetType([NativeName(NativeNameType.Param, "jointId")] [NativeName(NativeNameType.Type, "b2JointId")] B2JointId jointId)
		{
			B2JointType ret = JointGetTypeNative(jointId);
			return ret;
		}

		/// <summary>
		/// Get body A id on a joint<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2Joint_GetBodyA")]
		[return: NativeName(NativeNameType.Type, "b2BodyId")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static B2BodyId JointGetBodyANative([NativeName(NativeNameType.Param, "jointId")] [NativeName(NativeNameType.Type, "b2JointId")] B2JointId jointId)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<B2JointId, B2BodyId>)funcTable[239])(jointId);
			#else
			return (B2BodyId)((delegate* unmanaged[Cdecl]<B2JointId, B2BodyId>)funcTable[239])(jointId);
			#endif
		}

		/// <summary>
		/// Get body A id on a joint<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2Joint_GetBodyA")]
		[return: NativeName(NativeNameType.Type, "b2BodyId")]
		public static B2BodyId JointGetBodyA([NativeName(NativeNameType.Param, "jointId")] [NativeName(NativeNameType.Type, "b2JointId")] B2JointId jointId)
		{
			B2BodyId ret = JointGetBodyANative(jointId);
			return ret;
		}

		/// <summary>
		/// Get body B id on a joint<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2Joint_GetBodyB")]
		[return: NativeName(NativeNameType.Type, "b2BodyId")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static B2BodyId JointGetBodyBNative([NativeName(NativeNameType.Param, "jointId")] [NativeName(NativeNameType.Type, "b2JointId")] B2JointId jointId)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<B2JointId, B2BodyId>)funcTable[240])(jointId);
			#else
			return (B2BodyId)((delegate* unmanaged[Cdecl]<B2JointId, B2BodyId>)funcTable[240])(jointId);
			#endif
		}

		/// <summary>
		/// Get body B id on a joint<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2Joint_GetBodyB")]
		[return: NativeName(NativeNameType.Type, "b2BodyId")]
		public static B2BodyId JointGetBodyB([NativeName(NativeNameType.Param, "jointId")] [NativeName(NativeNameType.Type, "b2JointId")] B2JointId jointId)
		{
			B2BodyId ret = JointGetBodyBNative(jointId);
			return ret;
		}

		/// <summary>
		/// Get the local anchor on bodyA<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2Joint_GetLocalAnchorA")]
		[return: NativeName(NativeNameType.Type, "b2Vec2")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static Vector2 JointGetLocalAnchorANative([NativeName(NativeNameType.Param, "jointId")] [NativeName(NativeNameType.Type, "b2JointId")] B2JointId jointId)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<B2JointId, Vector2>)funcTable[241])(jointId);
			#else
			return (Vector2)((delegate* unmanaged[Cdecl]<B2JointId, Vector2>)funcTable[241])(jointId);
			#endif
		}

		/// <summary>
		/// Get the local anchor on bodyA<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2Joint_GetLocalAnchorA")]
		[return: NativeName(NativeNameType.Type, "b2Vec2")]
		public static Vector2 JointGetLocalAnchorA([NativeName(NativeNameType.Param, "jointId")] [NativeName(NativeNameType.Type, "b2JointId")] B2JointId jointId)
		{
			Vector2 ret = JointGetLocalAnchorANative(jointId);
			return ret;
		}

		/// <summary>
		/// Get the local anchor on bodyB<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2Joint_GetLocalAnchorB")]
		[return: NativeName(NativeNameType.Type, "b2Vec2")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static Vector2 JointGetLocalAnchorBNative([NativeName(NativeNameType.Param, "jointId")] [NativeName(NativeNameType.Type, "b2JointId")] B2JointId jointId)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<B2JointId, Vector2>)funcTable[242])(jointId);
			#else
			return (Vector2)((delegate* unmanaged[Cdecl]<B2JointId, Vector2>)funcTable[242])(jointId);
			#endif
		}

		/// <summary>
		/// Get the local anchor on bodyB<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2Joint_GetLocalAnchorB")]
		[return: NativeName(NativeNameType.Type, "b2Vec2")]
		public static Vector2 JointGetLocalAnchorB([NativeName(NativeNameType.Param, "jointId")] [NativeName(NativeNameType.Type, "b2JointId")] B2JointId jointId)
		{
			Vector2 ret = JointGetLocalAnchorBNative(jointId);
			return ret;
		}

		/// <summary>
		/// Toggle collision between connected bodies<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2Joint_SetCollideConnected")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void JointSetCollideConnectedNative([NativeName(NativeNameType.Param, "jointId")] [NativeName(NativeNameType.Type, "b2JointId")] B2JointId jointId, [NativeName(NativeNameType.Param, "shouldCollide")] [NativeName(NativeNameType.Type, "bool")] byte shouldCollide)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<B2JointId, byte, void>)funcTable[243])(jointId, shouldCollide);
			#else
			((delegate* unmanaged[Cdecl]<B2JointId, byte, void>)funcTable[243])(jointId, shouldCollide);
			#endif
		}

		/// <summary>
		/// Toggle collision between connected bodies<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2Joint_SetCollideConnected")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void JointSetCollideConnected([NativeName(NativeNameType.Param, "jointId")] [NativeName(NativeNameType.Type, "b2JointId")] B2JointId jointId, [NativeName(NativeNameType.Param, "shouldCollide")] [NativeName(NativeNameType.Type, "bool")] bool shouldCollide)
		{
			JointSetCollideConnectedNative(jointId, shouldCollide ? (byte)1 : (byte)0);
		}

		/// <summary>
		/// Is collision allowed between connected bodies?<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2Joint_GetCollideConnected")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte JointGetCollideConnectedNative([NativeName(NativeNameType.Param, "jointId")] [NativeName(NativeNameType.Type, "b2JointId")] B2JointId jointId)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<B2JointId, byte>)funcTable[244])(jointId);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<B2JointId, byte>)funcTable[244])(jointId);
			#endif
		}

		/// <summary>
		/// Is collision allowed between connected bodies?<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2Joint_GetCollideConnected")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool JointGetCollideConnected([NativeName(NativeNameType.Param, "jointId")] [NativeName(NativeNameType.Type, "b2JointId")] B2JointId jointId)
		{
			byte ret = JointGetCollideConnectedNative(jointId);
			return ret != 0;
		}

		/// <summary>
		/// Set the user data on a joint<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2Joint_SetUserData")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void JointSetUserDataNative([NativeName(NativeNameType.Param, "jointId")] [NativeName(NativeNameType.Type, "b2JointId")] B2JointId jointId, [NativeName(NativeNameType.Param, "userData")] [NativeName(NativeNameType.Type, "void *")] void* userData)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<B2JointId, void*, void>)funcTable[245])(jointId, userData);
			#else
			((delegate* unmanaged[Cdecl]<B2JointId, nint, void>)funcTable[245])(jointId, (nint)userData);
			#endif
		}

		/// <summary>
		/// Set the user data on a joint<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2Joint_SetUserData")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void JointSetUserData([NativeName(NativeNameType.Param, "jointId")] [NativeName(NativeNameType.Type, "b2JointId")] B2JointId jointId, [NativeName(NativeNameType.Param, "userData")] [NativeName(NativeNameType.Type, "void *")] void* userData)
		{
			JointSetUserDataNative(jointId, userData);
		}

		/// <summary>
		/// Get the user data on a joint<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2Joint_GetUserData")]
		[return: NativeName(NativeNameType.Type, "void *")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void* JointGetUserDataNative([NativeName(NativeNameType.Param, "jointId")] [NativeName(NativeNameType.Type, "b2JointId")] B2JointId jointId)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<B2JointId, void*>)funcTable[246])(jointId);
			#else
			return (void*)((delegate* unmanaged[Cdecl]<B2JointId, nint>)funcTable[246])(jointId);
			#endif
		}

		/// <summary>
		/// Get the user data on a joint<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2Joint_GetUserData")]
		[return: NativeName(NativeNameType.Type, "void *")]
		public static void* JointGetUserData([NativeName(NativeNameType.Param, "jointId")] [NativeName(NativeNameType.Type, "b2JointId")] B2JointId jointId)
		{
			void* ret = JointGetUserDataNative(jointId);
			return ret;
		}

		/// <summary>
		/// Wake the bodies connect to this joint<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2Joint_WakeBodies")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void JointWakeBodiesNative([NativeName(NativeNameType.Param, "jointId")] [NativeName(NativeNameType.Type, "b2JointId")] B2JointId jointId)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<B2JointId, void>)funcTable[247])(jointId);
			#else
			((delegate* unmanaged[Cdecl]<B2JointId, void>)funcTable[247])(jointId);
			#endif
		}

		/// <summary>
		/// Wake the bodies connect to this joint<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2Joint_WakeBodies")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void JointWakeBodies([NativeName(NativeNameType.Param, "jointId")] [NativeName(NativeNameType.Type, "b2JointId")] B2JointId jointId)
		{
			JointWakeBodiesNative(jointId);
		}

		/// <summary>
		/// Get the current constraint force for this joint<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2Joint_GetConstraintForce")]
		[return: NativeName(NativeNameType.Type, "b2Vec2")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static Vector2 JointGetConstraintForceNative([NativeName(NativeNameType.Param, "jointId")] [NativeName(NativeNameType.Type, "b2JointId")] B2JointId jointId)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<B2JointId, Vector2>)funcTable[248])(jointId);
			#else
			return (Vector2)((delegate* unmanaged[Cdecl]<B2JointId, Vector2>)funcTable[248])(jointId);
			#endif
		}

		/// <summary>
		/// Get the current constraint force for this joint<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2Joint_GetConstraintForce")]
		[return: NativeName(NativeNameType.Type, "b2Vec2")]
		public static Vector2 JointGetConstraintForce([NativeName(NativeNameType.Param, "jointId")] [NativeName(NativeNameType.Type, "b2JointId")] B2JointId jointId)
		{
			Vector2 ret = JointGetConstraintForceNative(jointId);
			return ret;
		}

		/// <summary>
		/// Get the current constraint torque for this joint<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2Joint_GetConstraintTorque")]
		[return: NativeName(NativeNameType.Type, "float")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static float JointGetConstraintTorqueNative([NativeName(NativeNameType.Param, "jointId")] [NativeName(NativeNameType.Type, "b2JointId")] B2JointId jointId)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<B2JointId, float>)funcTable[249])(jointId);
			#else
			return (float)((delegate* unmanaged[Cdecl]<B2JointId, float>)funcTable[249])(jointId);
			#endif
		}

		/// <summary>
		/// Get the current constraint torque for this joint<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2Joint_GetConstraintTorque")]
		[return: NativeName(NativeNameType.Type, "float")]
		public static float JointGetConstraintTorque([NativeName(NativeNameType.Param, "jointId")] [NativeName(NativeNameType.Type, "b2JointId")] B2JointId jointId)
		{
			float ret = JointGetConstraintTorqueNative(jointId);
			return ret;
		}

		/// <summary>
		/// Create a distance joint<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2CreateDistanceJoint")]
		[return: NativeName(NativeNameType.Type, "b2JointId")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static B2JointId CreateDistanceJointNative([NativeName(NativeNameType.Param, "worldId")] [NativeName(NativeNameType.Type, "b2WorldId")] B2WorldId worldId, [NativeName(NativeNameType.Param, "def")] [NativeName(NativeNameType.Type, "b2DistanceJointDef const *")] B2DistanceJointDef* def)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<B2WorldId, B2DistanceJointDef*, B2JointId>)funcTable[250])(worldId, def);
			#else
			return (B2JointId)((delegate* unmanaged[Cdecl]<B2WorldId, nint, B2JointId>)funcTable[250])(worldId, (nint)def);
			#endif
		}

		/// <summary>
		/// Create a distance joint<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2CreateDistanceJoint")]
		[return: NativeName(NativeNameType.Type, "b2JointId")]
		public static B2JointId CreateDistanceJoint([NativeName(NativeNameType.Param, "worldId")] [NativeName(NativeNameType.Type, "b2WorldId")] B2WorldId worldId, [NativeName(NativeNameType.Param, "def")] [NativeName(NativeNameType.Type, "b2DistanceJointDef const *")] B2DistanceJointDef* def)
		{
			B2JointId ret = CreateDistanceJointNative(worldId, def);
			return ret;
		}

		/// <summary>
		/// Create a distance joint<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2CreateDistanceJoint")]
		[return: NativeName(NativeNameType.Type, "b2JointId")]
		public static B2JointId CreateDistanceJoint([NativeName(NativeNameType.Param, "worldId")] [NativeName(NativeNameType.Type, "b2WorldId")] B2WorldId worldId, [NativeName(NativeNameType.Param, "def")] [NativeName(NativeNameType.Type, "b2DistanceJointDef const *")] ref B2DistanceJointDef def)
		{
			fixed (B2DistanceJointDef* pdef = &def)
			{
				B2JointId ret = CreateDistanceJointNative(worldId, (B2DistanceJointDef*)pdef);
				return ret;
			}
		}

		/// <summary>
		/// Set the rest length of a distance joint<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2DistanceJoint_SetLength")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DistanceJointSetLengthNative([NativeName(NativeNameType.Param, "jointId")] [NativeName(NativeNameType.Type, "b2JointId")] B2JointId jointId, [NativeName(NativeNameType.Param, "length")] [NativeName(NativeNameType.Type, "float")] float length)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<B2JointId, float, void>)funcTable[251])(jointId, length);
			#else
			((delegate* unmanaged[Cdecl]<B2JointId, float, void>)funcTable[251])(jointId, length);
			#endif
		}

		/// <summary>
		/// Set the rest length of a distance joint<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2DistanceJoint_SetLength")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void DistanceJointSetLength([NativeName(NativeNameType.Param, "jointId")] [NativeName(NativeNameType.Type, "b2JointId")] B2JointId jointId, [NativeName(NativeNameType.Param, "length")] [NativeName(NativeNameType.Type, "float")] float length)
		{
			DistanceJointSetLengthNative(jointId, length);
		}

		/// <summary>
		/// Get the rest length of a distance joint<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2DistanceJoint_GetLength")]
		[return: NativeName(NativeNameType.Type, "float")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static float DistanceJointGetLengthNative([NativeName(NativeNameType.Param, "jointId")] [NativeName(NativeNameType.Type, "b2JointId")] B2JointId jointId)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<B2JointId, float>)funcTable[252])(jointId);
			#else
			return (float)((delegate* unmanaged[Cdecl]<B2JointId, float>)funcTable[252])(jointId);
			#endif
		}

		/// <summary>
		/// Get the rest length of a distance joint<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2DistanceJoint_GetLength")]
		[return: NativeName(NativeNameType.Type, "float")]
		public static float DistanceJointGetLength([NativeName(NativeNameType.Param, "jointId")] [NativeName(NativeNameType.Type, "b2JointId")] B2JointId jointId)
		{
			float ret = DistanceJointGetLengthNative(jointId);
			return ret;
		}

		/// <summary>
		/// Enable/disable the distance joint spring. When disabled the distance joint is rigid.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2DistanceJoint_EnableSpring")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DistanceJointEnableSpringNative([NativeName(NativeNameType.Param, "jointId")] [NativeName(NativeNameType.Type, "b2JointId")] B2JointId jointId, [NativeName(NativeNameType.Param, "enableSpring")] [NativeName(NativeNameType.Type, "bool")] byte enableSpring)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<B2JointId, byte, void>)funcTable[253])(jointId, enableSpring);
			#else
			((delegate* unmanaged[Cdecl]<B2JointId, byte, void>)funcTable[253])(jointId, enableSpring);
			#endif
		}

		/// <summary>
		/// Enable/disable the distance joint spring. When disabled the distance joint is rigid.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2DistanceJoint_EnableSpring")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void DistanceJointEnableSpring([NativeName(NativeNameType.Param, "jointId")] [NativeName(NativeNameType.Type, "b2JointId")] B2JointId jointId, [NativeName(NativeNameType.Param, "enableSpring")] [NativeName(NativeNameType.Type, "bool")] bool enableSpring)
		{
			DistanceJointEnableSpringNative(jointId, enableSpring ? (byte)1 : (byte)0);
		}

		/// <summary>
		/// Is the distance joint spring enabled?<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2DistanceJoint_IsSpringEnabled")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte DistanceJointIsSpringEnabledNative([NativeName(NativeNameType.Param, "jointId")] [NativeName(NativeNameType.Type, "b2JointId")] B2JointId jointId)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<B2JointId, byte>)funcTable[254])(jointId);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<B2JointId, byte>)funcTable[254])(jointId);
			#endif
		}

		/// <summary>
		/// Is the distance joint spring enabled?<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2DistanceJoint_IsSpringEnabled")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool DistanceJointIsSpringEnabled([NativeName(NativeNameType.Param, "jointId")] [NativeName(NativeNameType.Type, "b2JointId")] B2JointId jointId)
		{
			byte ret = DistanceJointIsSpringEnabledNative(jointId);
			return ret != 0;
		}

		/// <summary>
		/// Set the spring stiffness in Hertz<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2DistanceJoint_SetSpringHertz")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DistanceJointSetSpringHertzNative([NativeName(NativeNameType.Param, "jointId")] [NativeName(NativeNameType.Type, "b2JointId")] B2JointId jointId, [NativeName(NativeNameType.Param, "hertz")] [NativeName(NativeNameType.Type, "float")] float hertz)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<B2JointId, float, void>)funcTable[255])(jointId, hertz);
			#else
			((delegate* unmanaged[Cdecl]<B2JointId, float, void>)funcTable[255])(jointId, hertz);
			#endif
		}

		/// <summary>
		/// Set the spring stiffness in Hertz<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2DistanceJoint_SetSpringHertz")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void DistanceJointSetSpringHertz([NativeName(NativeNameType.Param, "jointId")] [NativeName(NativeNameType.Type, "b2JointId")] B2JointId jointId, [NativeName(NativeNameType.Param, "hertz")] [NativeName(NativeNameType.Type, "float")] float hertz)
		{
			DistanceJointSetSpringHertzNative(jointId, hertz);
		}

		/// <summary>
		/// Set the spring damping ratio, non-dimensional<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2DistanceJoint_SetSpringDampingRatio")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DistanceJointSetSpringDampingRatioNative([NativeName(NativeNameType.Param, "jointId")] [NativeName(NativeNameType.Type, "b2JointId")] B2JointId jointId, [NativeName(NativeNameType.Param, "dampingRatio")] [NativeName(NativeNameType.Type, "float")] float dampingRatio)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<B2JointId, float, void>)funcTable[256])(jointId, dampingRatio);
			#else
			((delegate* unmanaged[Cdecl]<B2JointId, float, void>)funcTable[256])(jointId, dampingRatio);
			#endif
		}

		/// <summary>
		/// Set the spring damping ratio, non-dimensional<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2DistanceJoint_SetSpringDampingRatio")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void DistanceJointSetSpringDampingRatio([NativeName(NativeNameType.Param, "jointId")] [NativeName(NativeNameType.Type, "b2JointId")] B2JointId jointId, [NativeName(NativeNameType.Param, "dampingRatio")] [NativeName(NativeNameType.Type, "float")] float dampingRatio)
		{
			DistanceJointSetSpringDampingRatioNative(jointId, dampingRatio);
		}

		/// <summary>
		/// Get the spring Hertz<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2DistanceJoint_GetHertz")]
		[return: NativeName(NativeNameType.Type, "float")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static float DistanceJointGetHertzNative([NativeName(NativeNameType.Param, "jointId")] [NativeName(NativeNameType.Type, "b2JointId")] B2JointId jointId)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<B2JointId, float>)funcTable[257])(jointId);
			#else
			return (float)((delegate* unmanaged[Cdecl]<B2JointId, float>)funcTable[257])(jointId);
			#endif
		}

		/// <summary>
		/// Get the spring Hertz<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2DistanceJoint_GetHertz")]
		[return: NativeName(NativeNameType.Type, "float")]
		public static float DistanceJointGetHertz([NativeName(NativeNameType.Param, "jointId")] [NativeName(NativeNameType.Type, "b2JointId")] B2JointId jointId)
		{
			float ret = DistanceJointGetHertzNative(jointId);
			return ret;
		}

		/// <summary>
		/// Get the spring damping ratio<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2DistanceJoint_GetDampingRatio")]
		[return: NativeName(NativeNameType.Type, "float")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static float DistanceJointGetDampingRatioNative([NativeName(NativeNameType.Param, "jointId")] [NativeName(NativeNameType.Type, "b2JointId")] B2JointId jointId)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<B2JointId, float>)funcTable[258])(jointId);
			#else
			return (float)((delegate* unmanaged[Cdecl]<B2JointId, float>)funcTable[258])(jointId);
			#endif
		}

		/// <summary>
		/// Get the spring damping ratio<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2DistanceJoint_GetDampingRatio")]
		[return: NativeName(NativeNameType.Type, "float")]
		public static float DistanceJointGetDampingRatio([NativeName(NativeNameType.Param, "jointId")] [NativeName(NativeNameType.Type, "b2JointId")] B2JointId jointId)
		{
			float ret = DistanceJointGetDampingRatioNative(jointId);
			return ret;
		}

		/// <summary>
		/// Enable joint limit. The limit only works if the joint spring is enabled. Otherwise the joint is rigid<br/>
		/// and the limit has no effect.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2DistanceJoint_EnableLimit")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DistanceJointEnableLimitNative([NativeName(NativeNameType.Param, "jointId")] [NativeName(NativeNameType.Type, "b2JointId")] B2JointId jointId, [NativeName(NativeNameType.Param, "enableLimit")] [NativeName(NativeNameType.Type, "bool")] byte enableLimit)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<B2JointId, byte, void>)funcTable[259])(jointId, enableLimit);
			#else
			((delegate* unmanaged[Cdecl]<B2JointId, byte, void>)funcTable[259])(jointId, enableLimit);
			#endif
		}

		/// <summary>
		/// Enable joint limit. The limit only works if the joint spring is enabled. Otherwise the joint is rigid<br/>
		/// and the limit has no effect.<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2DistanceJoint_EnableLimit")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void DistanceJointEnableLimit([NativeName(NativeNameType.Param, "jointId")] [NativeName(NativeNameType.Type, "b2JointId")] B2JointId jointId, [NativeName(NativeNameType.Param, "enableLimit")] [NativeName(NativeNameType.Type, "bool")] bool enableLimit)
		{
			DistanceJointEnableLimitNative(jointId, enableLimit ? (byte)1 : (byte)0);
		}

		/// <summary>
		/// Is the distance joint limit enabled?<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2DistanceJoint_IsLimitEnabled")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte DistanceJointIsLimitEnabledNative([NativeName(NativeNameType.Param, "jointId")] [NativeName(NativeNameType.Type, "b2JointId")] B2JointId jointId)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<B2JointId, byte>)funcTable[260])(jointId);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<B2JointId, byte>)funcTable[260])(jointId);
			#endif
		}

		/// <summary>
		/// Is the distance joint limit enabled?<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2DistanceJoint_IsLimitEnabled")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool DistanceJointIsLimitEnabled([NativeName(NativeNameType.Param, "jointId")] [NativeName(NativeNameType.Type, "b2JointId")] B2JointId jointId)
		{
			byte ret = DistanceJointIsLimitEnabledNative(jointId);
			return ret != 0;
		}

		/// <summary>
		/// Set the minimum and maximum length parameters of a distance joint<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2DistanceJoint_SetLengthRange")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DistanceJointSetLengthRangeNative([NativeName(NativeNameType.Param, "jointId")] [NativeName(NativeNameType.Type, "b2JointId")] B2JointId jointId, [NativeName(NativeNameType.Param, "minLength")] [NativeName(NativeNameType.Type, "float")] float minLength, [NativeName(NativeNameType.Param, "maxLength")] [NativeName(NativeNameType.Type, "float")] float maxLength)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<B2JointId, float, float, void>)funcTable[261])(jointId, minLength, maxLength);
			#else
			((delegate* unmanaged[Cdecl]<B2JointId, float, float, void>)funcTable[261])(jointId, minLength, maxLength);
			#endif
		}

		/// <summary>
		/// Set the minimum and maximum length parameters of a distance joint<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2DistanceJoint_SetLengthRange")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void DistanceJointSetLengthRange([NativeName(NativeNameType.Param, "jointId")] [NativeName(NativeNameType.Type, "b2JointId")] B2JointId jointId, [NativeName(NativeNameType.Param, "minLength")] [NativeName(NativeNameType.Type, "float")] float minLength, [NativeName(NativeNameType.Param, "maxLength")] [NativeName(NativeNameType.Type, "float")] float maxLength)
		{
			DistanceJointSetLengthRangeNative(jointId, minLength, maxLength);
		}

		/// <summary>
		/// Get the distance joint minimum length<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2DistanceJoint_GetMinLength")]
		[return: NativeName(NativeNameType.Type, "float")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static float DistanceJointGetMinLengthNative([NativeName(NativeNameType.Param, "jointId")] [NativeName(NativeNameType.Type, "b2JointId")] B2JointId jointId)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<B2JointId, float>)funcTable[262])(jointId);
			#else
			return (float)((delegate* unmanaged[Cdecl]<B2JointId, float>)funcTable[262])(jointId);
			#endif
		}

		/// <summary>
		/// Get the distance joint minimum length<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2DistanceJoint_GetMinLength")]
		[return: NativeName(NativeNameType.Type, "float")]
		public static float DistanceJointGetMinLength([NativeName(NativeNameType.Param, "jointId")] [NativeName(NativeNameType.Type, "b2JointId")] B2JointId jointId)
		{
			float ret = DistanceJointGetMinLengthNative(jointId);
			return ret;
		}

		/// <summary>
		/// Get the distance joint maximum length<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2DistanceJoint_GetMaxLength")]
		[return: NativeName(NativeNameType.Type, "float")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static float DistanceJointGetMaxLengthNative([NativeName(NativeNameType.Param, "jointId")] [NativeName(NativeNameType.Type, "b2JointId")] B2JointId jointId)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<B2JointId, float>)funcTable[263])(jointId);
			#else
			return (float)((delegate* unmanaged[Cdecl]<B2JointId, float>)funcTable[263])(jointId);
			#endif
		}

		/// <summary>
		/// Get the distance joint maximum length<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2DistanceJoint_GetMaxLength")]
		[return: NativeName(NativeNameType.Type, "float")]
		public static float DistanceJointGetMaxLength([NativeName(NativeNameType.Param, "jointId")] [NativeName(NativeNameType.Type, "b2JointId")] B2JointId jointId)
		{
			float ret = DistanceJointGetMaxLengthNative(jointId);
			return ret;
		}

		/// <summary>
		/// Get the current length of a distance joint<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2DistanceJoint_GetCurrentLength")]
		[return: NativeName(NativeNameType.Type, "float")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static float DistanceJointGetCurrentLengthNative([NativeName(NativeNameType.Param, "jointId")] [NativeName(NativeNameType.Type, "b2JointId")] B2JointId jointId)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<B2JointId, float>)funcTable[264])(jointId);
			#else
			return (float)((delegate* unmanaged[Cdecl]<B2JointId, float>)funcTable[264])(jointId);
			#endif
		}

		/// <summary>
		/// Get the current length of a distance joint<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2DistanceJoint_GetCurrentLength")]
		[return: NativeName(NativeNameType.Type, "float")]
		public static float DistanceJointGetCurrentLength([NativeName(NativeNameType.Param, "jointId")] [NativeName(NativeNameType.Type, "b2JointId")] B2JointId jointId)
		{
			float ret = DistanceJointGetCurrentLengthNative(jointId);
			return ret;
		}

		/// <summary>
		/// Enable/disable the distance joint motor<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2DistanceJoint_EnableMotor")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DistanceJointEnableMotorNative([NativeName(NativeNameType.Param, "jointId")] [NativeName(NativeNameType.Type, "b2JointId")] B2JointId jointId, [NativeName(NativeNameType.Param, "enableMotor")] [NativeName(NativeNameType.Type, "bool")] byte enableMotor)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<B2JointId, byte, void>)funcTable[265])(jointId, enableMotor);
			#else
			((delegate* unmanaged[Cdecl]<B2JointId, byte, void>)funcTable[265])(jointId, enableMotor);
			#endif
		}

		/// <summary>
		/// Enable/disable the distance joint motor<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2DistanceJoint_EnableMotor")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void DistanceJointEnableMotor([NativeName(NativeNameType.Param, "jointId")] [NativeName(NativeNameType.Type, "b2JointId")] B2JointId jointId, [NativeName(NativeNameType.Param, "enableMotor")] [NativeName(NativeNameType.Type, "bool")] bool enableMotor)
		{
			DistanceJointEnableMotorNative(jointId, enableMotor ? (byte)1 : (byte)0);
		}

		/// <summary>
		/// Is the distance joint motor enabled?<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2DistanceJoint_IsMotorEnabled")]
		[return: NativeName(NativeNameType.Type, "bool")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static byte DistanceJointIsMotorEnabledNative([NativeName(NativeNameType.Param, "jointId")] [NativeName(NativeNameType.Type, "b2JointId")] B2JointId jointId)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<B2JointId, byte>)funcTable[266])(jointId);
			#else
			return (byte)((delegate* unmanaged[Cdecl]<B2JointId, byte>)funcTable[266])(jointId);
			#endif
		}

		/// <summary>
		/// Is the distance joint motor enabled?<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2DistanceJoint_IsMotorEnabled")]
		[return: NativeName(NativeNameType.Type, "bool")]
		public static bool DistanceJointIsMotorEnabled([NativeName(NativeNameType.Param, "jointId")] [NativeName(NativeNameType.Type, "b2JointId")] B2JointId jointId)
		{
			byte ret = DistanceJointIsMotorEnabledNative(jointId);
			return ret != 0;
		}

		/// <summary>
		/// Set the distance joint motor speed, typically in meters per second<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2DistanceJoint_SetMotorSpeed")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DistanceJointSetMotorSpeedNative([NativeName(NativeNameType.Param, "jointId")] [NativeName(NativeNameType.Type, "b2JointId")] B2JointId jointId, [NativeName(NativeNameType.Param, "motorSpeed")] [NativeName(NativeNameType.Type, "float")] float motorSpeed)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<B2JointId, float, void>)funcTable[267])(jointId, motorSpeed);
			#else
			((delegate* unmanaged[Cdecl]<B2JointId, float, void>)funcTable[267])(jointId, motorSpeed);
			#endif
		}

		/// <summary>
		/// Set the distance joint motor speed, typically in meters per second<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2DistanceJoint_SetMotorSpeed")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void DistanceJointSetMotorSpeed([NativeName(NativeNameType.Param, "jointId")] [NativeName(NativeNameType.Type, "b2JointId")] B2JointId jointId, [NativeName(NativeNameType.Param, "motorSpeed")] [NativeName(NativeNameType.Type, "float")] float motorSpeed)
		{
			DistanceJointSetMotorSpeedNative(jointId, motorSpeed);
		}

		/// <summary>
		/// Get the distance joint motor speed, typically in meters per second<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2DistanceJoint_GetMotorSpeed")]
		[return: NativeName(NativeNameType.Type, "float")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static float DistanceJointGetMotorSpeedNative([NativeName(NativeNameType.Param, "jointId")] [NativeName(NativeNameType.Type, "b2JointId")] B2JointId jointId)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<B2JointId, float>)funcTable[268])(jointId);
			#else
			return (float)((delegate* unmanaged[Cdecl]<B2JointId, float>)funcTable[268])(jointId);
			#endif
		}

		/// <summary>
		/// Get the distance joint motor speed, typically in meters per second<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2DistanceJoint_GetMotorSpeed")]
		[return: NativeName(NativeNameType.Type, "float")]
		public static float DistanceJointGetMotorSpeed([NativeName(NativeNameType.Param, "jointId")] [NativeName(NativeNameType.Type, "b2JointId")] B2JointId jointId)
		{
			float ret = DistanceJointGetMotorSpeedNative(jointId);
			return ret;
		}

		/// <summary>
		/// Set the distance joint maximum motor force, typically in newtons<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2DistanceJoint_SetMaxMotorForce")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void DistanceJointSetMaxMotorForceNative([NativeName(NativeNameType.Param, "jointId")] [NativeName(NativeNameType.Type, "b2JointId")] B2JointId jointId, [NativeName(NativeNameType.Param, "force")] [NativeName(NativeNameType.Type, "float")] float force)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<B2JointId, float, void>)funcTable[269])(jointId, force);
			#else
			((delegate* unmanaged[Cdecl]<B2JointId, float, void>)funcTable[269])(jointId, force);
			#endif
		}

		/// <summary>
		/// Set the distance joint maximum motor force, typically in newtons<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2DistanceJoint_SetMaxMotorForce")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void DistanceJointSetMaxMotorForce([NativeName(NativeNameType.Param, "jointId")] [NativeName(NativeNameType.Type, "b2JointId")] B2JointId jointId, [NativeName(NativeNameType.Param, "force")] [NativeName(NativeNameType.Type, "float")] float force)
		{
			DistanceJointSetMaxMotorForceNative(jointId, force);
		}

		/// <summary>
		/// Get the distance joint maximum motor force, typically in newtons<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2DistanceJoint_GetMaxMotorForce")]
		[return: NativeName(NativeNameType.Type, "float")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static float DistanceJointGetMaxMotorForceNative([NativeName(NativeNameType.Param, "jointId")] [NativeName(NativeNameType.Type, "b2JointId")] B2JointId jointId)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<B2JointId, float>)funcTable[270])(jointId);
			#else
			return (float)((delegate* unmanaged[Cdecl]<B2JointId, float>)funcTable[270])(jointId);
			#endif
		}

		/// <summary>
		/// Get the distance joint maximum motor force, typically in newtons<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2DistanceJoint_GetMaxMotorForce")]
		[return: NativeName(NativeNameType.Type, "float")]
		public static float DistanceJointGetMaxMotorForce([NativeName(NativeNameType.Param, "jointId")] [NativeName(NativeNameType.Type, "b2JointId")] B2JointId jointId)
		{
			float ret = DistanceJointGetMaxMotorForceNative(jointId);
			return ret;
		}

		/// <summary>
		/// Get the distance joint current motor force, typically in newtons<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2DistanceJoint_GetMotorForce")]
		[return: NativeName(NativeNameType.Type, "float")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static float DistanceJointGetMotorForceNative([NativeName(NativeNameType.Param, "jointId")] [NativeName(NativeNameType.Type, "b2JointId")] B2JointId jointId)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<B2JointId, float>)funcTable[271])(jointId);
			#else
			return (float)((delegate* unmanaged[Cdecl]<B2JointId, float>)funcTable[271])(jointId);
			#endif
		}

		/// <summary>
		/// Get the distance joint current motor force, typically in newtons<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2DistanceJoint_GetMotorForce")]
		[return: NativeName(NativeNameType.Type, "float")]
		public static float DistanceJointGetMotorForce([NativeName(NativeNameType.Param, "jointId")] [NativeName(NativeNameType.Type, "b2JointId")] B2JointId jointId)
		{
			float ret = DistanceJointGetMotorForceNative(jointId);
			return ret;
		}

		/// <summary>
		/// Create a motor joint<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2CreateMotorJoint")]
		[return: NativeName(NativeNameType.Type, "b2JointId")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static B2JointId CreateMotorJointNative([NativeName(NativeNameType.Param, "worldId")] [NativeName(NativeNameType.Type, "b2WorldId")] B2WorldId worldId, [NativeName(NativeNameType.Param, "def")] [NativeName(NativeNameType.Type, "b2MotorJointDef const *")] B2MotorJointDef* def)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<B2WorldId, B2MotorJointDef*, B2JointId>)funcTable[272])(worldId, def);
			#else
			return (B2JointId)((delegate* unmanaged[Cdecl]<B2WorldId, nint, B2JointId>)funcTable[272])(worldId, (nint)def);
			#endif
		}

		/// <summary>
		/// Create a motor joint<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2CreateMotorJoint")]
		[return: NativeName(NativeNameType.Type, "b2JointId")]
		public static B2JointId CreateMotorJoint([NativeName(NativeNameType.Param, "worldId")] [NativeName(NativeNameType.Type, "b2WorldId")] B2WorldId worldId, [NativeName(NativeNameType.Param, "def")] [NativeName(NativeNameType.Type, "b2MotorJointDef const *")] B2MotorJointDef* def)
		{
			B2JointId ret = CreateMotorJointNative(worldId, def);
			return ret;
		}

		/// <summary>
		/// Create a motor joint<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2CreateMotorJoint")]
		[return: NativeName(NativeNameType.Type, "b2JointId")]
		public static B2JointId CreateMotorJoint([NativeName(NativeNameType.Param, "worldId")] [NativeName(NativeNameType.Type, "b2WorldId")] B2WorldId worldId, [NativeName(NativeNameType.Param, "def")] [NativeName(NativeNameType.Type, "b2MotorJointDef const *")] ref B2MotorJointDef def)
		{
			fixed (B2MotorJointDef* pdef = &def)
			{
				B2JointId ret = CreateMotorJointNative(worldId, (B2MotorJointDef*)pdef);
				return ret;
			}
		}

		/// <summary>
		/// Set the motor joint linear offset target<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2MotorJoint_SetLinearOffset")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MotorJointSetLinearOffsetNative([NativeName(NativeNameType.Param, "jointId")] [NativeName(NativeNameType.Type, "b2JointId")] B2JointId jointId, [NativeName(NativeNameType.Param, "linearOffset")] [NativeName(NativeNameType.Type, "b2Vec2")] Vector2 linearOffset)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<B2JointId, Vector2, void>)funcTable[273])(jointId, linearOffset);
			#else
			((delegate* unmanaged[Cdecl]<B2JointId, Vector2, void>)funcTable[273])(jointId, linearOffset);
			#endif
		}

		/// <summary>
		/// Set the motor joint linear offset target<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2MotorJoint_SetLinearOffset")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void MotorJointSetLinearOffset([NativeName(NativeNameType.Param, "jointId")] [NativeName(NativeNameType.Type, "b2JointId")] B2JointId jointId, [NativeName(NativeNameType.Param, "linearOffset")] [NativeName(NativeNameType.Type, "b2Vec2")] Vector2 linearOffset)
		{
			MotorJointSetLinearOffsetNative(jointId, linearOffset);
		}

		/// <summary>
		/// Get the motor joint linear offset target<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2MotorJoint_GetLinearOffset")]
		[return: NativeName(NativeNameType.Type, "b2Vec2")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static Vector2 MotorJointGetLinearOffsetNative([NativeName(NativeNameType.Param, "jointId")] [NativeName(NativeNameType.Type, "b2JointId")] B2JointId jointId)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<B2JointId, Vector2>)funcTable[274])(jointId);
			#else
			return (Vector2)((delegate* unmanaged[Cdecl]<B2JointId, Vector2>)funcTable[274])(jointId);
			#endif
		}

		/// <summary>
		/// Get the motor joint linear offset target<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2MotorJoint_GetLinearOffset")]
		[return: NativeName(NativeNameType.Type, "b2Vec2")]
		public static Vector2 MotorJointGetLinearOffset([NativeName(NativeNameType.Param, "jointId")] [NativeName(NativeNameType.Type, "b2JointId")] B2JointId jointId)
		{
			Vector2 ret = MotorJointGetLinearOffsetNative(jointId);
			return ret;
		}

		/// <summary>
		/// Set the motor joint angular offset target in radians<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2MotorJoint_SetAngularOffset")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MotorJointSetAngularOffsetNative([NativeName(NativeNameType.Param, "jointId")] [NativeName(NativeNameType.Type, "b2JointId")] B2JointId jointId, [NativeName(NativeNameType.Param, "angularOffset")] [NativeName(NativeNameType.Type, "float")] float angularOffset)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<B2JointId, float, void>)funcTable[275])(jointId, angularOffset);
			#else
			((delegate* unmanaged[Cdecl]<B2JointId, float, void>)funcTable[275])(jointId, angularOffset);
			#endif
		}

		/// <summary>
		/// Set the motor joint angular offset target in radians<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2MotorJoint_SetAngularOffset")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void MotorJointSetAngularOffset([NativeName(NativeNameType.Param, "jointId")] [NativeName(NativeNameType.Type, "b2JointId")] B2JointId jointId, [NativeName(NativeNameType.Param, "angularOffset")] [NativeName(NativeNameType.Type, "float")] float angularOffset)
		{
			MotorJointSetAngularOffsetNative(jointId, angularOffset);
		}

		/// <summary>
		/// Get the motor joint angular offset target in radians<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2MotorJoint_GetAngularOffset")]
		[return: NativeName(NativeNameType.Type, "float")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static float MotorJointGetAngularOffsetNative([NativeName(NativeNameType.Param, "jointId")] [NativeName(NativeNameType.Type, "b2JointId")] B2JointId jointId)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<B2JointId, float>)funcTable[276])(jointId);
			#else
			return (float)((delegate* unmanaged[Cdecl]<B2JointId, float>)funcTable[276])(jointId);
			#endif
		}

		/// <summary>
		/// Get the motor joint angular offset target in radians<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2MotorJoint_GetAngularOffset")]
		[return: NativeName(NativeNameType.Type, "float")]
		public static float MotorJointGetAngularOffset([NativeName(NativeNameType.Param, "jointId")] [NativeName(NativeNameType.Type, "b2JointId")] B2JointId jointId)
		{
			float ret = MotorJointGetAngularOffsetNative(jointId);
			return ret;
		}

		/// <summary>
		/// Set the motor joint maximum force, typically in newtons<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2MotorJoint_SetMaxForce")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MotorJointSetMaxForceNative([NativeName(NativeNameType.Param, "jointId")] [NativeName(NativeNameType.Type, "b2JointId")] B2JointId jointId, [NativeName(NativeNameType.Param, "maxForce")] [NativeName(NativeNameType.Type, "float")] float maxForce)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<B2JointId, float, void>)funcTable[277])(jointId, maxForce);
			#else
			((delegate* unmanaged[Cdecl]<B2JointId, float, void>)funcTable[277])(jointId, maxForce);
			#endif
		}

		/// <summary>
		/// Set the motor joint maximum force, typically in newtons<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2MotorJoint_SetMaxForce")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void MotorJointSetMaxForce([NativeName(NativeNameType.Param, "jointId")] [NativeName(NativeNameType.Type, "b2JointId")] B2JointId jointId, [NativeName(NativeNameType.Param, "maxForce")] [NativeName(NativeNameType.Type, "float")] float maxForce)
		{
			MotorJointSetMaxForceNative(jointId, maxForce);
		}

		/// <summary>
		/// Get the motor joint maximum force, typically in newtons<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2MotorJoint_GetMaxForce")]
		[return: NativeName(NativeNameType.Type, "float")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static float MotorJointGetMaxForceNative([NativeName(NativeNameType.Param, "jointId")] [NativeName(NativeNameType.Type, "b2JointId")] B2JointId jointId)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<B2JointId, float>)funcTable[278])(jointId);
			#else
			return (float)((delegate* unmanaged[Cdecl]<B2JointId, float>)funcTable[278])(jointId);
			#endif
		}

		/// <summary>
		/// Get the motor joint maximum force, typically in newtons<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2MotorJoint_GetMaxForce")]
		[return: NativeName(NativeNameType.Type, "float")]
		public static float MotorJointGetMaxForce([NativeName(NativeNameType.Param, "jointId")] [NativeName(NativeNameType.Type, "b2JointId")] B2JointId jointId)
		{
			float ret = MotorJointGetMaxForceNative(jointId);
			return ret;
		}

		/// <summary>
		/// Set the motor joint maximum torque, typically in newton-meters<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2MotorJoint_SetMaxTorque")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MotorJointSetMaxTorqueNative([NativeName(NativeNameType.Param, "jointId")] [NativeName(NativeNameType.Type, "b2JointId")] B2JointId jointId, [NativeName(NativeNameType.Param, "maxTorque")] [NativeName(NativeNameType.Type, "float")] float maxTorque)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<B2JointId, float, void>)funcTable[279])(jointId, maxTorque);
			#else
			((delegate* unmanaged[Cdecl]<B2JointId, float, void>)funcTable[279])(jointId, maxTorque);
			#endif
		}

		/// <summary>
		/// Set the motor joint maximum torque, typically in newton-meters<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2MotorJoint_SetMaxTorque")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void MotorJointSetMaxTorque([NativeName(NativeNameType.Param, "jointId")] [NativeName(NativeNameType.Type, "b2JointId")] B2JointId jointId, [NativeName(NativeNameType.Param, "maxTorque")] [NativeName(NativeNameType.Type, "float")] float maxTorque)
		{
			MotorJointSetMaxTorqueNative(jointId, maxTorque);
		}

		/// <summary>
		/// Get the motor joint maximum torque, typically in newton-meters<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2MotorJoint_GetMaxTorque")]
		[return: NativeName(NativeNameType.Type, "float")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static float MotorJointGetMaxTorqueNative([NativeName(NativeNameType.Param, "jointId")] [NativeName(NativeNameType.Type, "b2JointId")] B2JointId jointId)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<B2JointId, float>)funcTable[280])(jointId);
			#else
			return (float)((delegate* unmanaged[Cdecl]<B2JointId, float>)funcTable[280])(jointId);
			#endif
		}

		/// <summary>
		/// Get the motor joint maximum torque, typically in newton-meters<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2MotorJoint_GetMaxTorque")]
		[return: NativeName(NativeNameType.Type, "float")]
		public static float MotorJointGetMaxTorque([NativeName(NativeNameType.Param, "jointId")] [NativeName(NativeNameType.Type, "b2JointId")] B2JointId jointId)
		{
			float ret = MotorJointGetMaxTorqueNative(jointId);
			return ret;
		}

		/// <summary>
		/// Set the motor joint correction factor, typically in [0, 1]<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2MotorJoint_SetCorrectionFactor")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MotorJointSetCorrectionFactorNative([NativeName(NativeNameType.Param, "jointId")] [NativeName(NativeNameType.Type, "b2JointId")] B2JointId jointId, [NativeName(NativeNameType.Param, "correctionFactor")] [NativeName(NativeNameType.Type, "float")] float correctionFactor)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<B2JointId, float, void>)funcTable[281])(jointId, correctionFactor);
			#else
			((delegate* unmanaged[Cdecl]<B2JointId, float, void>)funcTable[281])(jointId, correctionFactor);
			#endif
		}

		/// <summary>
		/// Set the motor joint correction factor, typically in [0, 1]<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2MotorJoint_SetCorrectionFactor")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void MotorJointSetCorrectionFactor([NativeName(NativeNameType.Param, "jointId")] [NativeName(NativeNameType.Type, "b2JointId")] B2JointId jointId, [NativeName(NativeNameType.Param, "correctionFactor")] [NativeName(NativeNameType.Type, "float")] float correctionFactor)
		{
			MotorJointSetCorrectionFactorNative(jointId, correctionFactor);
		}

		/// <summary>
		/// Get the motor joint correction factor, typically in [0, 1]<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2MotorJoint_GetCorrectionFactor")]
		[return: NativeName(NativeNameType.Type, "float")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static float MotorJointGetCorrectionFactorNative([NativeName(NativeNameType.Param, "jointId")] [NativeName(NativeNameType.Type, "b2JointId")] B2JointId jointId)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<B2JointId, float>)funcTable[282])(jointId);
			#else
			return (float)((delegate* unmanaged[Cdecl]<B2JointId, float>)funcTable[282])(jointId);
			#endif
		}

		/// <summary>
		/// Get the motor joint correction factor, typically in [0, 1]<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2MotorJoint_GetCorrectionFactor")]
		[return: NativeName(NativeNameType.Type, "float")]
		public static float MotorJointGetCorrectionFactor([NativeName(NativeNameType.Param, "jointId")] [NativeName(NativeNameType.Type, "b2JointId")] B2JointId jointId)
		{
			float ret = MotorJointGetCorrectionFactorNative(jointId);
			return ret;
		}

		/// <summary>
		/// Create a mouse joint<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2CreateMouseJoint")]
		[return: NativeName(NativeNameType.Type, "b2JointId")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static B2JointId CreateMouseJointNative([NativeName(NativeNameType.Param, "worldId")] [NativeName(NativeNameType.Type, "b2WorldId")] B2WorldId worldId, [NativeName(NativeNameType.Param, "def")] [NativeName(NativeNameType.Type, "b2MouseJointDef const *")] B2MouseJointDef* def)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<B2WorldId, B2MouseJointDef*, B2JointId>)funcTable[283])(worldId, def);
			#else
			return (B2JointId)((delegate* unmanaged[Cdecl]<B2WorldId, nint, B2JointId>)funcTable[283])(worldId, (nint)def);
			#endif
		}

		/// <summary>
		/// Create a mouse joint<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2CreateMouseJoint")]
		[return: NativeName(NativeNameType.Type, "b2JointId")]
		public static B2JointId CreateMouseJoint([NativeName(NativeNameType.Param, "worldId")] [NativeName(NativeNameType.Type, "b2WorldId")] B2WorldId worldId, [NativeName(NativeNameType.Param, "def")] [NativeName(NativeNameType.Type, "b2MouseJointDef const *")] B2MouseJointDef* def)
		{
			B2JointId ret = CreateMouseJointNative(worldId, def);
			return ret;
		}

		/// <summary>
		/// Create a mouse joint<br/>
		/// <br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2CreateMouseJoint")]
		[return: NativeName(NativeNameType.Type, "b2JointId")]
		public static B2JointId CreateMouseJoint([NativeName(NativeNameType.Param, "worldId")] [NativeName(NativeNameType.Type, "b2WorldId")] B2WorldId worldId, [NativeName(NativeNameType.Param, "def")] [NativeName(NativeNameType.Type, "b2MouseJointDef const *")] ref B2MouseJointDef def)
		{
			fixed (B2MouseJointDef* pdef = &def)
			{
				B2JointId ret = CreateMouseJointNative(worldId, (B2MouseJointDef*)pdef);
				return ret;
			}
		}

		/// <summary>
		/// Set the mouse joint target<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2MouseJoint_SetTarget")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MouseJointSetTargetNative([NativeName(NativeNameType.Param, "jointId")] [NativeName(NativeNameType.Type, "b2JointId")] B2JointId jointId, [NativeName(NativeNameType.Param, "target")] [NativeName(NativeNameType.Type, "b2Vec2")] Vector2 target)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<B2JointId, Vector2, void>)funcTable[284])(jointId, target);
			#else
			((delegate* unmanaged[Cdecl]<B2JointId, Vector2, void>)funcTable[284])(jointId, target);
			#endif
		}

		/// <summary>
		/// Set the mouse joint target<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2MouseJoint_SetTarget")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void MouseJointSetTarget([NativeName(NativeNameType.Param, "jointId")] [NativeName(NativeNameType.Type, "b2JointId")] B2JointId jointId, [NativeName(NativeNameType.Param, "target")] [NativeName(NativeNameType.Type, "b2Vec2")] Vector2 target)
		{
			MouseJointSetTargetNative(jointId, target);
		}

		/// <summary>
		/// Get the mouse joint target<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2MouseJoint_GetTarget")]
		[return: NativeName(NativeNameType.Type, "b2Vec2")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static Vector2 MouseJointGetTargetNative([NativeName(NativeNameType.Param, "jointId")] [NativeName(NativeNameType.Type, "b2JointId")] B2JointId jointId)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<B2JointId, Vector2>)funcTable[285])(jointId);
			#else
			return (Vector2)((delegate* unmanaged[Cdecl]<B2JointId, Vector2>)funcTable[285])(jointId);
			#endif
		}

		/// <summary>
		/// Get the mouse joint target<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2MouseJoint_GetTarget")]
		[return: NativeName(NativeNameType.Type, "b2Vec2")]
		public static Vector2 MouseJointGetTarget([NativeName(NativeNameType.Param, "jointId")] [NativeName(NativeNameType.Type, "b2JointId")] B2JointId jointId)
		{
			Vector2 ret = MouseJointGetTargetNative(jointId);
			return ret;
		}

		/// <summary>
		/// Set the mouse joint spring stiffness in Hertz<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2MouseJoint_SetSpringHertz")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MouseJointSetSpringHertzNative([NativeName(NativeNameType.Param, "jointId")] [NativeName(NativeNameType.Type, "b2JointId")] B2JointId jointId, [NativeName(NativeNameType.Param, "hertz")] [NativeName(NativeNameType.Type, "float")] float hertz)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<B2JointId, float, void>)funcTable[286])(jointId, hertz);
			#else
			((delegate* unmanaged[Cdecl]<B2JointId, float, void>)funcTable[286])(jointId, hertz);
			#endif
		}

		/// <summary>
		/// Set the mouse joint spring stiffness in Hertz<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2MouseJoint_SetSpringHertz")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void MouseJointSetSpringHertz([NativeName(NativeNameType.Param, "jointId")] [NativeName(NativeNameType.Type, "b2JointId")] B2JointId jointId, [NativeName(NativeNameType.Param, "hertz")] [NativeName(NativeNameType.Type, "float")] float hertz)
		{
			MouseJointSetSpringHertzNative(jointId, hertz);
		}

		/// <summary>
		/// Get the mouse joint spring stiffness in Hertz<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2MouseJoint_GetSpringHertz")]
		[return: NativeName(NativeNameType.Type, "float")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static float MouseJointGetSpringHertzNative([NativeName(NativeNameType.Param, "jointId")] [NativeName(NativeNameType.Type, "b2JointId")] B2JointId jointId)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<B2JointId, float>)funcTable[287])(jointId);
			#else
			return (float)((delegate* unmanaged[Cdecl]<B2JointId, float>)funcTable[287])(jointId);
			#endif
		}

		/// <summary>
		/// Get the mouse joint spring stiffness in Hertz<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2MouseJoint_GetSpringHertz")]
		[return: NativeName(NativeNameType.Type, "float")]
		public static float MouseJointGetSpringHertz([NativeName(NativeNameType.Param, "jointId")] [NativeName(NativeNameType.Type, "b2JointId")] B2JointId jointId)
		{
			float ret = MouseJointGetSpringHertzNative(jointId);
			return ret;
		}

		/// <summary>
		/// Set the mouse joint spring damping ratio, non-dimensional<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2MouseJoint_SetSpringDampingRatio")]
		[return: NativeName(NativeNameType.Type, "void")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static void MouseJointSetSpringDampingRatioNative([NativeName(NativeNameType.Param, "jointId")] [NativeName(NativeNameType.Type, "b2JointId")] B2JointId jointId, [NativeName(NativeNameType.Param, "dampingRatio")] [NativeName(NativeNameType.Type, "float")] float dampingRatio)
		{
			#if NET5_0_OR_GREATER
			((delegate* unmanaged[Cdecl]<B2JointId, float, void>)funcTable[288])(jointId, dampingRatio);
			#else
			((delegate* unmanaged[Cdecl]<B2JointId, float, void>)funcTable[288])(jointId, dampingRatio);
			#endif
		}

		/// <summary>
		/// Set the mouse joint spring damping ratio, non-dimensional<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2MouseJoint_SetSpringDampingRatio")]
		[return: NativeName(NativeNameType.Type, "void")]
		public static void MouseJointSetSpringDampingRatio([NativeName(NativeNameType.Param, "jointId")] [NativeName(NativeNameType.Type, "b2JointId")] B2JointId jointId, [NativeName(NativeNameType.Param, "dampingRatio")] [NativeName(NativeNameType.Type, "float")] float dampingRatio)
		{
			MouseJointSetSpringDampingRatioNative(jointId, dampingRatio);
		}

		/// <summary>
		/// Get the mouse joint damping ratio, non-dimensional<br/>
		/// </summary>
		[NativeName(NativeNameType.Func, "b2MouseJoint_GetSpringDampingRatio")]
		[return: NativeName(NativeNameType.Type, "float")]
		[MethodImpl(MethodImplOptions.AggressiveInlining)]
		internal static float MouseJointGetSpringDampingRatioNative([NativeName(NativeNameType.Param, "jointId")] [NativeName(NativeNameType.Type, "b2JointId")] B2JointId jointId)
		{
			#if NET5_0_OR_GREATER
			return ((delegate* unmanaged[Cdecl]<B2JointId, float>)funcTable[289])(jointId);
			#else
			return (float)((delegate* unmanaged[Cdecl]<B2JointId, float>)funcTable[289])(jointId);
			#endif
		}
	}
}
